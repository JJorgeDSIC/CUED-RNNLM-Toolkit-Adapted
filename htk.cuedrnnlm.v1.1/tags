!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
#1	HTKBook/HTK.tex	/^  \\newpage$/;"	c
#1	HTKBook/HTK.tex	/^\\newcommand{\\mysect}[2]{$/;"	s
#1	HTKBook/HTK.tex	/^\\newcommand{\\mysubsect}[2]{$/;"	u
#1	HTKBook/HTK.tex	/^\\newcommand{\\mysubsub}[2]{$/;"	b
A	HTKLib/HParm.c	/^   Vector A;          \/* Parameters for decompressing *\/$/;"	m	struct:__anon76	file:
ABS	HTKTools/HHEd.c	5315;"	d	file:
ABS	HTKTools/HMMIRest.c	63;"	d	file:
ACCWINDOW	HTKLib/HParm.c	/^   ACCWINDOW,     \/* Window size for 2nd diffs *\/$/;"	e	enum:__anon77	file:
ACTUAL_MLP_NSIZE	HTKLib/HLM.c	/^static int ACTUAL_MLP_NSIZE = MLP_NSIZE;\/* Actual N-length of MLP LM *\/$/;"	v	file:
ADAPTKIND	HTKLib/HModel.c	/^   NUMCLASSES, ADAPTKIND, PREQUAL, INPUTXFORM,$/;"	e	enum:__anon40	file:
ADDDITHER	HTKLib/HParm.c	/^   ADDDITHER,     \/* Amount of additional dither added to file *\/$/;"	e	enum:__anon77	file:
ADJ_OFS	HTKTools/HSLab.c	1149;"	d	file:
ADS_CLOSED	HTKLib/HAudio.c	/^               ADS_STOPPED, ADS_CLOSED } AudioDevStatus;$/;"	e	enum:__anon52	file:
ADS_INIT	HTKLib/HAudio.c	/^typedef enum { ADS_INIT, ADS_OPEN, ADS_SAMPLING, $/;"	e	enum:__anon52	file:
ADS_OPEN	HTKLib/HAudio.c	/^typedef enum { ADS_INIT, ADS_OPEN, ADS_SAMPLING, $/;"	e	enum:__anon52	file:
ADS_SAMPLING	HTKLib/HAudio.c	/^typedef enum { ADS_INIT, ADS_OPEN, ADS_SAMPLING, $/;"	e	enum:__anon52	file:
ADS_STOPPED	HTKLib/HAudio.c	/^               ADS_STOPPED, ADS_CLOSED } AudioDevStatus;$/;"	e	enum:__anon52	file:
AEntry	HTKTools/HLStats.c	/^} AEntry;$/;"	t	typeref:struct:aentry	file:
AIFF	HTKLib/HWave.h	/^        AIFF,              \/* Apple Audio Interchange format *\/$/;"	e	enum:__anon36
AI_CLEARED	HTKLib/HAudio.h	/^   AI_CLEARED,    \/* Not sampling and buffer empty *\/$/;"	e	enum:__anon98
AI_ERROR	HTKLib/HAudio.h	/^   AI_ERROR       \/* Error state - eg buffer overflow *\/$/;"	e	enum:__anon98
AI_SAMPLING	HTKLib/HAudio.h	/^   AI_SAMPLING,   \/* Sampling speech and filling buffer *\/   $/;"	e	enum:__anon98
AI_STOPPED	HTKLib/HAudio.h	/^   AI_STOPPED,    \/* Stopped but waiting for buffer to be emptied *\/$/;"	e	enum:__anon98
AI_WAITSIG	HTKLib/HAudio.h	/^   AI_WAITSIG,    \/* Wait for start signal *\/$/;"	e	enum:__anon98
AInfo	HTKLib/HAdapt.c	/^} AInfo;$/;"	t	typeref:struct:_AInfo	file:
ALIEN	HTKLib/HWave.h	/^        ALIEN,             \/* Unknown *\/$/;"	e	enum:__anon36
ALIEN and NOHEAD File Formats	HTKBook/speechio.tex	/^data files is \\texttt{VAX} (little-endian).$/;"	u
ALTPATHCHAR	HTKLib/HShell.h	489;"	d
ALT_DOWN	HTKLib/HGraf_WIN32.c	/^enum _AltState {ALT_UP,ALT_DOWN}; \/* keep track of Alt key *\/$/;"	e	enum:_AltState	file:
ALT_UP	HTKLib/HGraf_WIN32.c	/^enum _AltState {ALT_UP,ALT_DOWN}; \/* keep track of Alt key *\/$/;"	e	enum:_AltState	file:
AMPL_RANGE	HTKTools/HSLab.c	88;"	d	file:
ANON	HTKLib/HParm.h	/^      ANON};$/;"	e	enum:_BaseParmKind
APPSIL	HTKTools/HDMan.c	/^              TCTXT, APPSIL, REMSTRESS, REPLACEW, RAWMODE, $/;"	e	enum:__anon158	file:
ARRAY	HTKLib/esignal.h	65;"	d
ASCII	HTKLib/esignal.h	106;"	d
ASIZE	HTKTools/HLStats.c	324;"	d	file:
ASpec2LPCep	HTKLib/HSigP.c	/^void ASpec2LPCep (Vector as, Vector ac, Vector lp, Vector c, DMatrix cm)$/;"	f
AT	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon168	file:
AU	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon168	file:
AUDBUFSIZE	HTKLib/HAudio.c	140;"	d	file:
AUDIOSIG	HTKLib/HParm.c	/^   AUDIOSIG,      \/* Signal for audio control *\/$/;"	e	enum:__anon77	file:
AUDIO_BSIZE	HTKTools/HList.c	335;"	d	file:
AUDIO_DEV	HTKLib/HAudio.c	126;"	d	file:
AUDIO_DEV	HTKLib/HAudio.c	81;"	d	file:
AUDIO_DEV	HTKLib/HAudio.c	83;"	d	file:
AUDIO_IO	HTKLib/HAudio.c	106;"	d	file:
AUDIO_IO	HTKLib/HAudio.c	97;"	d	file:
AUDIO_IODEV	HTKLib/HAudio.c	105;"	d	file:
AUDIO_IODEV	HTKLib/HAudio.c	96;"	d	file:
AUDIO_RD	HTKLib/HAudio.c	128;"	d	file:
AUDIO_WR	HTKLib/HAudio.c	129;"	d	file:
AccAdaptBaseTriMat	HTKLib/HAdapt.c	/^static Boolean AccAdaptBaseTriMat(AdaptXForm *xform)$/;"	f	file:
AccAdaptFrame	HTKLib/HAdapt.c	/^void AccAdaptFrame(HMMSet *hset, double Lr, Vector svec, MixPDF *mp, int t)$/;"	f
AccAdaptMean	HTKLib/HAdapt.c	/^static Boolean AccAdaptMean(AdaptXForm *xform)$/;"	f	file:
AccAdaptVar	HTKLib/HAdapt.c	/^static Boolean AccAdaptVar(AdaptXForm *xform)$/;"	f	file:
AccBaseClassStats	HTKLib/HAdapt.c	/^static void AccBaseClassStats(MixPDF *mp, AccStruct *accs)$/;"	f	file:
AccBaseTriMat	HTKLib/HAdapt.c	/^static void AccBaseTriMat(HMMSet *hset, double Lr, Vector svec, MixPDF *mp, int t)$/;"	f	file:
AccCMLLRBaseStats	HTKLib/HAdapt.c	/^static void AccCMLLRBaseStats(MixPDF *mp, AccStruct *accs)$/;"	f	file:
AccCMLLRPDFStats	HTKLib/HAdapt.c	/^static void AccCMLLRPDFStats(MixPDF *mp,  AccStruct *accs)$/;"	f	file:
AccCache	HTKLib/HAdapt.c	/^} AccCache;                       \/* acc cache to save accumulators related to parent XForm *\/  $/;"	t	typeref:struct:_AccCache	file:
AccGenUtt	HTKTools/HCompV.c	/^SpkrAcc *AccGenUtt(char *SpkrPattern, char *UttFileName, SpkrAcc *sa)$/;"	f
AccMLLRCOVPDFStats	HTKLib/HAdapt.c	/^static void AccMLLRCOVPDFStats(MixPDF *mp,  AccStruct *accs)$/;"	f	file:
AccMLLRPDFStats	HTKLib/HAdapt.c	/^static void AccMLLRPDFStats(MixPDF *mp,  AccStruct *accs)$/;"	f	file:
AccMixPDFSemiTiedStats	HTKLib/HAdapt.c	/^static void AccMixPDFSemiTiedStats(HMMSet *hset,MixPDF *mp, AccStruct *accs)$/;"	f	file:
AccMixPDFStats	HTKLib/HAdapt.c	/^static void AccMixPDFStats(HMMSet *hset, MixPDF *mp, AccStruct *accs)$/;"	f	file:
AccNodeStats	HTKLib/HAdapt.c	/^static void AccNodeStats(RegNode *node, AccStruct *accs, $/;"	f	file:
AccScale	HTKLib/HFBLat.h	/^  float AccScale; \/*normally 1.0*\/$/;"	m	struct:__anon54
AccStruct	HTKLib/HAdapt.c	/^} AccStruct;$/;"	t	typeref:struct:__anon92	file:
AccSum	HTKTools/HHEd.c	/^} AccSum;$/;"	t	typeref:struct:_AccSum	file:
AccSumProb	HTKTools/HHEd.c	/^float AccSumProb(AccSum *acc)$/;"	f
AccVar	HTKTools/HCompV.c	/^void AccVar(Observation obs)$/;"	f
AccessInfo	HLMLib/LModel.h	/^typedef struct _AccessInfo  AccessInfo; \/* abstract type for access stats structure *\/$/;"	t	typeref:struct:_AccessInfo
Acoustic	HTKLib/HArc.h	/^} Acoustic;  \/* for calculating acoustic likelihoods... *\/$/;"	t	typeref:struct:_Acoustic
AdaptKind	HTKLib/HModel.h	/^typedef enum _AdaptKind AdaptKind;$/;"	t	typeref:enum:_AdaptKind
AdaptKind2Str	HTKLib/HModel.c	/^char *AdaptKind2Str(AdaptKind akind, char *buf)$/;"	f
AdaptWgt	HTKLib/HModel.h	/^} AdaptWgt; $/;"	t	typeref:union:__anon67
AdaptXForm	HTKLib/HModel.h	/^} AdaptXForm;$/;"	t	typeref:struct:_AdaptXForm
AdaptXForm2InputXForm	HTKLib/HAdapt.c	/^InputXForm *AdaptXForm2InputXForm(HMMSet *hset, AdaptXForm *xform)$/;"	f
AddArcTrans	HTKLib/HArc.c	/^void AddArcTrans(MemHeap *mem,  HArc *start, HArc *end, float lmlike){$/;"	f
AddAuxLab	HTKLib/HLabel.c	/^void AddAuxLab(LLink lab, int n, LabId *auxLab, float *auxScore)$/;"	f
AddBinEntries	HTKTools/HQuant.c	/^VQNode AddBinEntries(ClusterSet *cs, short nid, int s)$/;"	f
AddChain	HTKLib/HNet.c	/^static void AddChain(Network*net, NetNode *hd)$/;"	f	file:
AddChar	HTKLib/esig_asc.c	/^AddChar(int     ch,$/;"	f	file:
AddDiffs	HTKLib/HParm.c	/^static void AddDiffs(float *data, int nRows, int nCols, int si, int ti, int d, $/;"	f	file:
AddEquiv	HLMTools/LPlex.c	/^static void AddEquiv(char * cl, char * eq)$/;"	f	file:
AddEquiv	HTKTools/HResults.c	/^void AddEquiv(char * cl, char * eq)$/;"	f
AddField	HTKLib/esignal.c	/^AddField(FieldList   *list,     \/* variable containing field list *\/$/;"	f
AddHCIContext	HTKLib/HNet.c	/^int AddHCIContext(HMMSetCxtInfo *hci,LabId labid)$/;"	f
AddHeadRegress	HTKLib/HSigP.c	/^void AddHeadRegress(float *data, int vSize, int n, int step, int offset,$/;"	f
AddInXFormDir	HTKLib/HModel.c	/^void AddInXFormDir(HMMSet *hset, char *dirname)$/;"	f
AddInitialFinal	HTKLib/HNet.c	/^static void AddInitialFinal(Lattice *wnet, Network *net,int xc)$/;"	f	file:
AddInputGFile	HLMLib/LGBase.c	/^void AddInputGFile(NGInputSet *inset, char *fn, float weight)$/;"	f
AddItem	HTKLib/HUtil.c	/^void AddItem(HLink owner, Ptr item, ILink *list)$/;"	f
AddJMix	HTKTools/HHEd.c	/^void AddJMix(MixtureElem *me)$/;"	f
AddLabel	HTKLib/HLabel.c	/^LLink AddLabel(MemHeap *x, LabList *ll, LabId id,$/;"	f
AddLabelList	HTKLib/HLabel.c	/^void AddLabelList(LabList *ll, Transcription *t)$/;"	f
AddLinEntries	HTKTools/HQuant.c	/^VQNode  AddLinEntries(ClusterSet *cs, int s)$/;"	f
AddMMF	HTKLib/HModel.c	/^MILink AddMMF(HMMSet *hset, char *fname)$/;"	f
AddMember	HTKLib/HUtil.c	/^void AddMember(IntSet s, int x)$/;"	f
AddPriorsFromPriorHMM	HTKTools/HMMIRest.c	/^void AddPriorsFromPriorHMM(int dst_index, float Tau, float K, Boolean IsMMI, float ISmoothTau){$/;"	f
AddQualifiers	HTKLib/HParm.c	/^static void AddQualifiers(ParmBuf pbuf,float *data, int nRows, IOConfig cf, $/;"	f	file:
AddRegression	HTKLib/HSigP.c	/^void AddRegression(float *data, int vSize, int n, int step, int offset,$/;"	f
AddSpot	HTKTools/HResults.c	/^void AddSpot(LabId key, Boolean hit, float score)$/;"	f
AddStats	HLMTools/LPlex.c	/^static void AddStats(PStats *ps1, PStats *ps2)$/;"	f	file:
AddSubfield	HTKLib/esignal.c	/^AddSubfield(FieldSpec   *field,    \/* field to aquire subfield *\/$/;"	f
AddTLoopBeginEnd	HTKTools/HParse.c	/^int AddTLoopBeginEnd(int numElements, SplitName* trilist, Link a, Link b)$/;"	f
AddTailRegress	HTKLib/HSigP.c	/^void AddTailRegress(float *data, int vSize, int n, int step, int offset,$/;"	f
AddToBuffer	HTKLib/HParm.c	/^void AddToBuffer(ParmBuf pbuf, Observation o)$/;"	f
AddTrans	HTKLib/HExactMPE.c	/^void AddTrans(MemHeap *x, CorrN *start, CorrN *end, float sc_lmlike){$/;"	f
AddTransP	HTKLib/HUtil.c	/^static void AddTransP(ILink models, ILink *ilist, char *type)$/;"	f	file:
AddUnseenCommand	HTKTools/HHEd.c	/^void AddUnseenCommand(void)$/;"	f
AddWordExtern	HTKTools/HParse.c	/^void AddWordExtern(Vocab *voc, Link p)$/;"	f
AddWordModel	HTKTools/HParse.c	/^void AddWordModel(Vocab *voc, Link p, Link history)$/;"	f
AddWordToClass	HLMLib/LCMap.c	/^void AddWordToClass(ClassMap *c, int clndx, int wdndx)$/;"	f
AddWordToMap	HLMLib/LWMap.c	/^void AddWordToMap(WordMap *wm, LabId word)$/;"	f
AddWrdtoFilter	HLMTools/LGList.c	/^void AddWrdtoFilter(char *s, int ndx)$/;"	f
AddXFormItem	HTKLib/HModel.c	/^static void AddXFormItem(MemHeap *x, Ptr item, Ptr owner, ILink *list)$/;"	f	file:
AdjSubList	HTKLib/HNet.c	/^SubLatDef *AdjSubList(Lattice *lat,LabId subLatId,Lattice *subLat,int adj)$/;"	f
AdjustBounds	HTKTools/HSLab.c	/^void AdjustBounds(RectWin *win)$/;"	f
AlarmOn	HTKLib/HGraf.c	/^static void AlarmOn(void)$/;"	f	file:
Align	HTKLib/HRec.h	/^typedef struct align Align;        \/* Alignment route (HRec.c) *\/$/;"	t	typeref:struct:align
AllocBlock	HTKLib/HMem.c	/^static BlockP AllocBlock(size_t size, size_t num, HeapType type)$/;"	f	file:
AllocSamples	HTKLib/esignal.c	/^AllocSamples(long       nrec,$/;"	f
AllocateVectors	HTKLib/HTrain.c	/^static int AllocateVectors(float *totalCost)$/;"	f	file:
AlphaBeta	HTKLib/HFB.h	/^} AlphaBeta;$/;"	t	typeref:struct:__anon138
AltKeyState	HTKLib/HGraf_WIN32.c	/^static AltState AltKeyState = ALT_UP;$/;"	v	file:
AltState	HTKLib/HGraf_WIN32.c	/^typedef enum _AltState AltState;$/;"	t	typeref:enum:_AltState	file:
Analysis Tool	HTKBook/htkoview.tex	/^\\end{itemize}$/;"	u
Annot	HTKLib/esignal.h	/^struct Annot {$/;"	s
Annot	HTKLib/esignal.h	/^typedef struct Annot	Annot;$/;"	t	typeref:struct:Annot
AnswerQuestion	HTKTools/HHEd.c	/^void AnswerQuestion(CLink clist,QLink q)$/;"	f
AnyCKind	HTKLib/HShell.h	/^   AnyCKind             \/* dont care *\/$/;"	e	enum:__anon85
AppendCell	HTKTools/HResults.c	/^void AppendCell(int i, int j, char *tb, char *rb)$/;"	f
AppendItem	HTKTools/HResults.c	/^void AppendItem(char *s, char *item, int len, int width)$/;"	f
AppendLabs	HTKTools/HCopy.c	/^void AppendLabs(Transcription *t, HTime len)$/;"	f
AppendPair	HTKTools/HResults.c	/^void AppendPair(char *linea, char *a, char *lineb, char *b)$/;"	f
AppendParm	HTKTools/HCopy.c	/^HTime AppendParm(char *src)$/;"	f
AppendPhone	HTKTools/HDMan.c	/^void AppendPhone(Pronunciation *p, LabId id)$/;"	f
AppendSilenceOp	HTKTools/HDMan.c	/^void AppendSilenceOp(WordBuf *wb, LabId *args)$/;"	f
AppendSpeechFile	HTKTools/HCopy.c	/^void AppendSpeechFile(char *s)$/;"	f
AppendSpkrAccList	HTKTools/HCompV.c	/^SpkrAccListItem *AppendSpkrAccList(SpkrAccListItem *sal, SpkrAcc *sa)$/;"	f
AppendTrace	HTKTools/HCopy.c	/^void AppendTrace(char *str)$/;"	f
AppendWave	HTKTools/HCopy.c	/^HTime AppendWave(char *src)$/;"	f
AppendWordBuf	HTKTools/HDMan.c	/^void AppendWordBuf(DBuffer *s, DBuffer *t)$/;"	f
ApplyABS	HLMLib/LPCalc.c	/^static double ApplyABS(BackOffInfo *boi, FLEntry *tgtFE, double tMass) $/;"	f	file:
ApplyCompFXForm	HTKLib/HAdapt.c	/^Vector ApplyCompFXForm(MixPDF *mp, Vector svec, AdaptXForm *xform, LogFloat *det, int t)$/;"	f
ApplyCompXForm	HTKLib/HAdapt.c	/^void ApplyCompXForm(MixPDF *mp, AdaptXForm *xform)$/;"	f
ApplyHMMSetXForm	HTKLib/HAdapt.c	/^void ApplyHMMSetXForm(HMMSet *hset, AdaptXForm *xform)$/;"	f
ApplyNGram2LabLat	HTKLib/HLat.c	/^void ApplyNGram2LabLat(Lattice *lat, LModel *lm)$/;"	f
ApplyRule	HLMTools/LGPrep.c	/^void ApplyRule(RuleDef *r, LabId *buf)$/;"	f
ApplyStaticMat	HTKLib/HParm.c	/^static void ApplyStaticMat(IOConfig cf, float *data, Matrix trans, int vSize, int n, int step, int offset)$/;"	f	file:
ApplyTG	HLMLib/LPCalc.c	/^static double ApplyTG(BackOffInfo *boi, FLEntry *tgtFE, double tMass, int nSize)$/;"	f	file:
ApplyTie	HTKTools/HHEd.c	/^void ApplyTie(ILink ilist, char *macName, char type)$/;"	f
ApplyVFloor	HTKLib/HModel.c	/^void ApplyVFloor(HMMSet *hset)$/;"	f
ApplyWPNet2LabLat	HTKLib/HLat.c	/^void ApplyWPNet2LabLat(Lattice *lat, Lattice *wdNet)$/;"	f
ApplyXForm2TriMat	HTKLib/HAdapt.c	/^static void ApplyXForm2TriMat(LinXForm *linXForm, TriMat t, Matrix m)$/;"	f	file:
ApplyXForm2Vector	HTKLib/HAdapt.c	/^static void ApplyXForm2Vector(LinXForm *linXForm, Vector mean)$/;"	f	file:
ApplyXForm2Vector	HTKLib/HParm.c	/^static void ApplyXForm2Vector(LinXForm *linXForm, Vector mean)$/;"	f	file:
ApproxWidth	HTKLib/esig_asc.c	/^ApproxWidth(int type)$/;"	f	file:
ArcFromLat	HTKLib/HArc.c	/^void ArcFromLat(ArcInfo *aInfo, HMMSet *hset){$/;"	f
ArcId	HTKLib/HNet.h	/^typedef struct larc *ArcId;$/;"	t	typeref:struct:larc
ArcInfo	HTKLib/HArc.h	/^}ArcInfo;$/;"	t	typeref:struct:ArcInfoStruct
ArcInfoStruct	HTKLib/HArc.h	/^typedef struct ArcInfoStruct{$/;"	s
ArcList	HTKLib/HArc.c	/^} ArcList;$/;"	t	typeref:struct:_ArcList	file:
ArcTrans	HTKLib/HArc.h	/^typedef struct _ArcTrans ArcTrans;$/;"	t	typeref:struct:_ArcTrans
ArgError	HTKLib/HShell.c	/^static void ArgError(char *s)$/;"	f	file:
ArgKind	HTKLib/HShell.h	/^typedef enum {SWITCHARG, STRINGARG, INTARG, FLOATARG, NOARG} ArgKind;$/;"	t	typeref:enum:__anon88
Array	HTKLib/esignal.h	/^struct Array {$/;"	s
Array	HTKLib/esignal.h	/^typedef struct Array	Array;$/;"	t	typeref:struct:Array
AsciiRead	HTKLib/esig_asc.c	/^AsciiRead(void  *datap,$/;"	f	file:
AsciiWrite	HTKLib/esig_asc.c	/^AsciiWrite(void     *datap,$/;"	f	file:
AsciiWriteChar	HTKLib/esig_asc.c	/^AsciiWriteChar(char     *data,$/;"	f	file:
AsciiWriteSub	HTKLib/esig_asc.c	/^AsciiWriteSub(void  *data,$/;"	f	file:
AsciiWriteWchar	HTKLib/esig_asc.c	/^AsciiWriteWchar(Wchar   *data,$/;"	f	file:
AssignHiddenAc	HTKLib/HRNLM.c	/^void AssignHiddenAc (Layer *self, Vector v)$/;"	f
AssignRNNLMHiddenVector	HTKLib/HRNLM.c	/^void AssignRNNLMHiddenVector (RNNLM *lm, Vector v)$/;"	f
AssignRNNLMHistVector_v1_0	HTKLib/HRNLM.c	/^void AssignRNNLMHistVector_v1_0 (RNNLM *lm, Vector v)$/;"	f
AssignStructure	HTKTools/HHEd.c	/^Ptr AssignStructure(LabId id, int state)$/;"	f
AttachAccessInfo	HLMLib/LModel.c	/^void AttachAccessInfo(BackOffLM *lm)$/;"	f
AttachAccs	HTKLib/HTrain.c	/^void AttachAccs(HMMSet *hset, MemHeap *x, UPDSet uFlags){ AttachAccsParallel(hset,x,uFlags,1); }$/;"	f
AttachAccsParallel	HTKLib/HTrain.c	/^void AttachAccsParallel(HMMSet *hset, MemHeap *x, UPDSet uFlags, int nPara)$/;"	f
AttachInst	HTKLib/HRec.c	/^static void AttachInst(NetNode *node)$/;"	f	file:
AttachMPEInfo	HTKLib/HArc.c	/^void AttachMPEInfo(ArcInfo *aInfo){  \/* attach the "mpe" structure to the arcs. *\/$/;"	f
AttachNodeInfos	HTKTools/HParse.c	/^void AttachNodeInfos(HPNetwork *theNet)$/;"	f
AttachPreComps	HTKLib/HTrain.c	/^void AttachPreComps(HMMSet *hset, MemHeap *x)$/;"	f
AttachRegAccs	HTKLib/HAdapt.c	/^static void AttachRegAccs(HMMSet *hset, AdaptXForm *xform)$/;"	f	file:
AttachReplayBuf	HTKLib/HAudio.c	/^void AttachReplayBuf(AudioIn a, int bufSize)$/;"	f
AttachSource	HTKLib/HShell.c	/^void AttachSource(FILE *file, Source *src)$/;"	f
AttachWtAccLists	HTKTools/HSmooth.c	/^void AttachWtAccLists()$/;"	f
AttachWtTrAccs	HTKLib/HFB.c	/^static void AttachWtTrAccs(HMMSet *hset, MemHeap *x)$/;"	f	file:
AttachXFormInfo	HTKLib/HAdapt.c	/^static void AttachXFormInfo(HMMSet *hset)$/;"	f	file:
AudioDevInput	HTKLib/HAudio.c	/^int AudioDevInput(int *mask) $/;"	f
AudioDevOutput	HTKLib/HAudio.c	/^int AudioDevOutput(int *mask) $/;"	f
AudioDevStatus	HTKLib/HAudio.c	/^               ADS_STOPPED, ADS_CLOSED } AudioDevStatus;$/;"	t	typeref:enum:__anon52	file:
AudioIn	HTKLib/HAudio.h	/^typedef struct _AudioIn  *AudioIn;    \/* Abstract audio input stream *\/$/;"	t	typeref:struct:_AudioIn
AudioInRec	HTKLib/HAudio.c	/^}AudioInRec;$/;"	t	typeref:struct:_AudioIn	file:
AudioInStatus	HTKLib/HAudio.h	/^}AudioInStatus;$/;"	t	typeref:enum:__anon98
AudioOut	HTKLib/HAudio.h	/^typedef struct _AudioOut *AudioOut;   \/* Abstract audio output stream *\/$/;"	t	typeref:struct:_AudioOut
AudioOutRec	HTKLib/HAudio.c	/^}AudioOutRec;$/;"	t	typeref:struct:_AudioOut	file:
AudioSigHandler	HTKLib/HAudio.c	/^static void AudioSigHandler(void)$/;"	f	file:
AutoCorrelate	HTKLib/HSigP.c	/^static float AutoCorrelate(Vector s, Vector r, int p, int frameSize)$/;"	f	file:
AuxLabEndTime	HTKLib/HLabel.c	/^HTime AuxLabEndTime(LLink p, int i)$/;"	f
AvgCorr	HTKLib/HFBLat.h	/^  float AvgCorr; \/* averate correctness. *\/$/;"	m	struct:__anon54
B	HTKLib/HParm.c	/^   Vector B;          \/*  HTK parameterised files *\/$/;"	m	struct:__anon76	file:
BARSYM	HTKTools/HParse.c	/^             LTRISYM,RTRISYM,EQSYM, SEMISYM, BARSYM, PERCENTSYM, $/;"	e	enum:_Symbol	file:
BAR_BORDER	HTKTools/HSLab.c	334;"	d	file:
BAR_HEIGHT	HTKTools/HSLab.c	333;"	d	file:
BAR_WIDTH	HTKTools/HSLab.c	332;"	d	file:
BASE	HTKLib/HModel.h	/^enum _AdaptKind {TREE, BASE};$/;"	e	enum:_AdaptKind
BASECLASS	HTKLib/HModel.c	/^   LINXFORM, OFFSET, BIAS, LOGDET, BLOCKINFO, BLOCK, BASECLASS, $/;"	e	enum:__anon40	file:
BASEMASK	HTKLib/HParm.h	69;"	d
BASEWORDNDX	HLMLib/LWMap.h	42;"	d
BAddSearch	HTKLib/HNet.c	/^static int BAddSearch(HMMSetCxtInfo *hci,LabId labid, int *np,LabId **ap)$/;"	f	file:
BEGINHMM	HTKLib/HModel.c	/^   BEGINHMM, USEMAC, ENDHMM, NUMMIXES, $/;"	e	enum:__anon40	file:
BIAS	HTKLib/HModel.c	/^   LINXFORM, OFFSET, BIAS, LOGDET, BLOCKINFO, BLOCK, BASECLASS, $/;"	e	enum:__anon40	file:
BIG_FLOAT	HTKTools/HHEd.c	60;"	d	file:
BINARY	HTKLib/HRNLM.h	/^enum FileTypeEnum {TEXT, BINARY, COMPRESSED};$/;"	e	enum:FileTypeEnum
BIN_ARPA_HAS_BOWT	HTKLib/HLM.c	722;"	d	file:
BIN_ARPA_INT_LMID	HTKLib/HLM.c	723;"	d	file:
BLACK	HTKLib/HGraf.h	/^                LIGHT_GREY, GREY, DARK_GREY, BLACK};$/;"	e	enum:_HColour
BLOCK	HTKLib/HModel.c	/^   LINXFORM, OFFSET, BIAS, LOGDET, BLOCKINFO, BLOCK, BASECLASS, $/;"	e	enum:__anon40	file:
BLOCKINFO	HTKLib/HModel.c	/^   LINXFORM, OFFSET, BIAS, LOGDET, BLOCKINFO, BLOCK, BASECLASS, $/;"	e	enum:__anon40	file:
BOOL	HTKLib/esignal.h	74;"	d
BOWT_LOG_TO_SHORT	HLMLib/LModel.c	366;"	d	file:
BOWT_LOG_TO_SHORT	HLMLib/LModel.c	377;"	d	file:
BOWT_SHORT_TO_LOG	HLMLib/LModel.c	371;"	d	file:
BOWT_SHORT_TO_LOG	HLMLib/LModel.c	378;"	d	file:
BSearch	HTKLib/HNet.c	/^static int BSearch(LabId labid, int n,LabId *array)$/;"	f	file:
BTN_AREA_H	HTKTools/HSLab.c	92;"	d	file:
BTN_AREA_W	HTKTools/HSLab.c	91;"	d	file:
BTN_AREA_X	HTKTools/HSLab.c	93;"	d	file:
BTN_AREA_Y	HTKTools/HSLab.c	94;"	d	file:
BTN_H_SPC	HTKTools/HSLab.c	97;"	d	file:
BTN_LINE_WIDTH	HTKLib/HGraf.c	622;"	d	file:
BTN_LINE_WIDTH	HTKLib/HGraf_WIN32.c	916;"	d	file:
BTN_PER_COL	HTKTools/HSLab.c	96;"	d	file:
BTN_PER_ROW	HTKTools/HSLab.c	95;"	d	file:
BTN_V_SPC	HTKTools/HSLab.c	98;"	d	file:
BTN_WAIT	HTKLib/HGraf.c	621;"	d	file:
BTN_WAIT	HTKLib/HGraf_WIN32.c	915;"	d	file:
BT_ABOUT	HTKTools/HSLab.c	/^   BT_LEDIT, BT_LSELECT, BT_ABOUT, BT_ADJUST, $/;"	e	enum:__anon144	file:
BT_ADJUST	HTKTools/HSLab.c	/^   BT_LEDIT, BT_LSELECT, BT_ABOUT, BT_ADJUST, $/;"	e	enum:__anon144	file:
BT_LABEL	HTKTools/HSLab.c	/^   BT_LABSTR, BT_LABEL, BT_LABELAS, BT_LDELETE, $/;"	e	enum:__anon144	file:
BT_LABELAS	HTKTools/HSLab.c	/^   BT_LABSTR, BT_LABEL, BT_LABELAS, BT_LDELETE, $/;"	e	enum:__anon144	file:
BT_LABSET	HTKTools/HSLab.c	/^   BT_LABSET, BT_NEWSET,$/;"	e	enum:__anon144	file:
BT_LABSTR	HTKTools/HSLab.c	/^   BT_LABSTR, BT_LABEL, BT_LABELAS, BT_LDELETE, $/;"	e	enum:__anon144	file:
BT_LDELETE	HTKTools/HSLab.c	/^   BT_LABSTR, BT_LABEL, BT_LABELAS, BT_LDELETE, $/;"	e	enum:__anon144	file:
BT_LEDIT	HTKTools/HSLab.c	/^   BT_LEDIT, BT_LSELECT, BT_ABOUT, BT_ADJUST, $/;"	e	enum:__anon144	file:
BT_LOAD	HTKTools/HSLab.c	/^   BT_NONE, BT_LOAD, BT_SAVE, BT_SCRLL, BT_SCRLR, $/;"	e	enum:__anon144	file:
BT_LSELECT	HTKTools/HSLab.c	/^   BT_LEDIT, BT_LSELECT, BT_ABOUT, BT_ADJUST, $/;"	e	enum:__anon144	file:
BT_MARK	HTKTools/HSLab.c	/^   BT_PLAY_VOL, BT_SCALE, BT_MARK, BT_UNMARK, $/;"	e	enum:__anon144	file:
BT_NEWSET	HTKTools/HSLab.c	/^   BT_LABSET, BT_NEWSET,$/;"	e	enum:__anon144	file:
BT_NONE	HTKTools/HSLab.c	/^   BT_NONE, BT_LOAD, BT_SAVE, BT_SCRLL, BT_SCRLR, $/;"	e	enum:__anon144	file:
BT_PAUSE	HTKTools/HSLab.c	/^   BT_UNDO, BT_SPCL, BT_REC, BT_PAUSE, BT_STOP, BT_QUIT$/;"	e	enum:__anon144	file:
BT_PLAY	HTKTools/HSLab.c	/^   BT_ZOOM_IN, BT_ZOOM_OUT, BT_RESTORE, BT_PLAY, $/;"	e	enum:__anon144	file:
BT_PLAY_VOL	HTKTools/HSLab.c	/^   BT_PLAY_VOL, BT_SCALE, BT_MARK, BT_UNMARK, $/;"	e	enum:__anon144	file:
BT_QUIT	HTKTools/HSLab.c	/^   BT_UNDO, BT_SPCL, BT_REC, BT_PAUSE, BT_STOP, BT_QUIT$/;"	e	enum:__anon144	file:
BT_REC	HTKTools/HSLab.c	/^   BT_UNDO, BT_SPCL, BT_REC, BT_PAUSE, BT_STOP, BT_QUIT$/;"	e	enum:__anon144	file:
BT_RESTORE	HTKTools/HSLab.c	/^   BT_ZOOM_IN, BT_ZOOM_OUT, BT_RESTORE, BT_PLAY, $/;"	e	enum:__anon144	file:
BT_SAVE	HTKTools/HSLab.c	/^   BT_NONE, BT_LOAD, BT_SAVE, BT_SCRLL, BT_SCRLR, $/;"	e	enum:__anon144	file:
BT_SCALE	HTKTools/HSLab.c	/^   BT_PLAY_VOL, BT_SCALE, BT_MARK, BT_UNMARK, $/;"	e	enum:__anon144	file:
BT_SCRLL	HTKTools/HSLab.c	/^   BT_NONE, BT_LOAD, BT_SAVE, BT_SCRLL, BT_SCRLR, $/;"	e	enum:__anon144	file:
BT_SCRLR	HTKTools/HSLab.c	/^   BT_NONE, BT_LOAD, BT_SAVE, BT_SCRLL, BT_SCRLR, $/;"	e	enum:__anon144	file:
BT_SPCL	HTKTools/HSLab.c	/^   BT_UNDO, BT_SPCL, BT_REC, BT_PAUSE, BT_STOP, BT_QUIT$/;"	e	enum:__anon144	file:
BT_STOP	HTKTools/HSLab.c	/^   BT_UNDO, BT_SPCL, BT_REC, BT_PAUSE, BT_STOP, BT_QUIT$/;"	e	enum:__anon144	file:
BT_UNDO	HTKTools/HSLab.c	/^   BT_UNDO, BT_SPCL, BT_REC, BT_PAUSE, BT_STOP, BT_QUIT$/;"	e	enum:__anon144	file:
BT_UNMARK	HTKTools/HSLab.c	/^   BT_PLAY_VOL, BT_SCALE, BT_MARK, BT_UNMARK, $/;"	e	enum:__anon144	file:
BT_ZOOM_IN	HTKTools/HSLab.c	/^   BT_ZOOM_IN, BT_ZOOM_OUT, BT_RESTORE, BT_PLAY, $/;"	e	enum:__anon144	file:
BT_ZOOM_OUT	HTKTools/HSLab.c	/^   BT_ZOOM_IN, BT_ZOOM_OUT, BT_RESTORE, BT_PLAY, $/;"	e	enum:__anon144	file:
BUF_SIZE	HLMTools/LLink.c	172;"	d	file:
BUF_SIZE	HTKLib/HAudio.c	130;"	d	file:
BackOffInfo	HLMLib/LModel.h	/^} BackOffInfo;$/;"	t	typeref:struct:__anon13
BackOffLM	HLMLib/LModel.h	/^} BackOffLM;$/;"	t	typeref:struct:__anon16
BackTransitions	HTKLib/HArc.c	/^Boolean BackTransitions(ArcInfo *aInfo){ \/* a check, should never happen *\/$/;"	f
BarType	HTKTools/HSLab.c	/^} BarType;$/;"	t	typeref:struct:__anon149	file:
BaseClass	HTKLib/HModel.h	/^} BaseClass;$/;"	t	typeref:struct:__anon65
BaseClassKind	HTKLib/HModel.h	/^typedef enum _BaseClassKind BaseClassKind;$/;"	t	typeref:enum:_BaseClassKind
BaseClassKind2Str	HTKLib/HModel.c	/^char *BaseClassKind2Str(BaseClassKind bkind, char *buf)$/;"	f
BaseOf	HTKLib/HShell.c	/^char * BaseOf(char *fn, char *s)$/;"	f
BaseParmKind	HTKLib/HParm.c	/^ParmKind BaseParmKind(ParmKind kind) { return kind & BASEMASK; }$/;"	f
BiFactor	HTKLib/HMath.c	/^static void BiFactor(DMatrix A, DMatrix U, DMatrix V)$/;"	f	file:
BiSVD	HTKLib/HMath.c	/^static void BiSVD(DVector d, DVector f, DMatrix U, DMatrix V)$/;"	f	file:
BiggestCluster	HTKLib/HTrain.c	/^static int BiggestCluster(void)$/;"	f	file:
BlankString	HLMLib/LUtil.c	/^Boolean BlankString(char *s)$/;"	f
Block	HTKLib/HMem.h	/^} Block;$/;"	t	typeref:struct:_Block
BlockP	HTKLib/HMem.h	/^typedef struct _Block *BlockP;$/;"	t	typeref:struct:_Block
BlockReorder	HTKLib/HMem.c	/^static void BlockReorder(BlockP *p, int n)$/;"	f	file:
Bool	HTKLib/esignal.h	/^typedef unsigned char			Bool;$/;"	t
BoolCKind	HTKLib/HShell.h	/^   BoolCKind,           \/* Boolean: T,F,True,False *\/$/;"	e	enum:__anon85
Boolean	HTKLib/HShell.h	/^typedef enum {FALSE=0, TRUE=1} Boolean;$/;"	t	typeref:enum:__anon82
BtnId	HTKTools/HSLab.c	/^} BtnId;$/;"	t	typeref:enum:__anon144	file:
BtnLink	HTKLib/HGraf.h	/^typedef struct _HButton *BtnLink;$/;"	t	typeref:struct:_HButton
BufferInfo	HTKLib/HParm.h	/^}BufferInfo;$/;"	t	typeref:struct:__anon122
BufferStatus	HTKLib/HParm.c	/^PBStatus BufferStatus(ParmBuf pbuf)$/;"	f
BuildCVec	HTKTools/HHEd.c	/^CLink *BuildCVec(int numClust, ILink ilist)$/;"	f
BuildInfo	HLMLib/LPCalc.h	/^} BuildInfo;$/;"	t	typeref:struct:__anon2
BuildLookupTables	HLMLib/LWMap.c	/^void BuildLookupTables(WordMap *wm)$/;"	f
BuildNEntry	HTKTools/HLStats.c	/^static float BuildNEntry(NEntry *ne,Vector boff,float bent)$/;"	f	file:
BuildOutputMap	HLMTools/LGCopy.c	/^static WordMap *BuildOutputMap(MemHeap *heap,ClassMap *cmap)$/;"	f	file:
BuildOutputMap	HLMTools/LSubset.c	/^WordMap *BuildOutputMap(MemHeap *heap,ClassMap *cmap)$/;"	f
BuildRegClusters	HTKTools/HHEd.c	/^int BuildRegClusters(RegNode *rtree, int vSize, int nTerminals, $/;"	f
BuildTree	HTKTools/HHEd.c	/^void BuildTree(ILink ilist,float threshold, char *macRoot)$/;"	f
BuildType	HTKTools/HBuild.c	/^typedef enum {unknown, wordLoop, boBiGram, matBiGram, multiLat, wordPair} BuildType;$/;"	t	typeref:enum:__anon163	file:
ButtonId	HTKLib/HGraf.h	/^typedef short ButtonId;$/;"	t
Byte	HLMLib/LGBase.h	/^typedef unsigned char  Byte;$/;"	t
Byte	HLMLib/LModel.h	/^typedef unsigned char  Byte;$/;"	t
ByteP	HTKLib/HMem.h	/^typedef unsigned char * ByteP;$/;"	t
ByteSwap	HTKLib/HWave.c	/^void ByteSwap(Wave w)$/;"	f
CAPTURE_ALT	HTKLib/HGraf_WIN32.c	28;"	d	file:
CC	HTKLib/Makefile	/^CC     = gcc$/;"	m
CC	HTKTools/Makefile	/^CC      = 	gcc$/;"	m
CEPLIFTER	HTKLib/HParm.c	/^   CEPLIFTER,     \/* Cepstral liftering coefficient *\/$/;"	e	enum:__anon77	file:
CEPSCALE	HTKLib/HParm.c	/^   CEPSCALE,      \/* Scale factor to prevent arithmetic errors *\/$/;"	e	enum:__anon77	file:
CFGSIZE	HTKLib/HParm.c	/^   CFGSIZE$/;"	e	enum:__anon77	file:
CFLAGS	HTKLib/Makefile	/^CFLAGS := $(CFLAGS) -m64 -ansi -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH="x86_64"' -Wall -Wno-switch -g -O3 -I. -DPHNALG$/;"	m
CFLAGS	HTKTools/Makefile	/^CFLAGS  = 	-m64 -ansi -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH="x86_64"' -Wall -Wno-switch  -O3 -I$(inc) -DPHNALG$/;"	m
CFOpen	HLMTools/LLink.c	77;"	d	file:
CHANGE	HTKTools/HLEd.c	/^   REPLACE, CHANGE, FIND,   MERGE,  EDOP_DELETE, DEFCON, TRIST,  $/;"	e	enum:__anon141	file:
CHANGE_OP	HTKTools/HSLab.c	/^   CREATE_OP, DELETE_OP, CHANGE_OP$/;"	e	enum:__anon146	file:
CHAR	HTKLib/esignal.h	80;"	d
CHEAP	HTKLib/HMem.h	/^typedef enum{MHEAP, MSTAK, CHEAP} HeapType;$/;"	e	enum:__anon72
CHECKNUM	HTKLib/HRNLM.h	/^    int CHECKNUM;$/;"	m	struct:_RNNLM
CHR_W	HTKLib/esig_asc.c	94;"	d	file:
CKCheck	HTKLib/HVQ.c	/^static CovKind CKCheck(CovKind ck)$/;"	f	file:
CL	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon168	file:
CLASS	HTKLib/HModel.c	/^   CLASS, XFORMWGTSET, CLASSXFORM, MMFIDMASK, PARAMETERS,$/;"	e	enum:__anon40	file:
CLASSXFORM	HTKLib/HModel.c	/^   CLASS, XFORMWGTSET, CLASSXFORM, MMFIDMASK, PARAMETERS,$/;"	e	enum:__anon40	file:
CLMHASHSIZE	HLMLib/LCMap.h	41;"	d
CLR_ALL	HTKLib/HModel.h	/^typedef enum {CLR_HMMS,CLR_STATES,CLR_STREAMS,CLR_ALL} ClearDepth;$/;"	e	enum:__anon71
CLR_HMMS	HTKLib/HModel.h	/^typedef enum {CLR_HMMS,CLR_STATES,CLR_STREAMS,CLR_ALL} ClearDepth;$/;"	e	enum:__anon71
CLR_STATES	HTKLib/HModel.h	/^typedef enum {CLR_HMMS,CLR_STATES,CLR_STREAMS,CLR_ALL} ClearDepth;$/;"	e	enum:__anon71
CLR_STREAMS	HTKLib/HModel.h	/^typedef enum {CLR_HMMS,CLR_STATES,CLR_STREAMS,CLR_ALL} ClearDepth;$/;"	e	enum:__anon71
CLink	HTKTools/HHEd.c	/^typedef struct _CRec *CLink;$/;"	t	typeref:struct:_CRec	file:
CMAP_HDR	HLMLib/LUtil.h	/^   NO_HDR, WMAP_HDR, CMAP_HDR, GRAM_HDR, LFOF_HDR$/;"	e	enum:__anon22
CMEANDIR	HTKLib/HParm.c	/^   CMEANDIR,     \/* dir to find the means *\/$/;"	e	enum:__anon77	file:
CMEANMASK	HTKLib/HParm.c	/^   CMEANMASK,    \/* label mask to idenitfy mean file *\/$/;"	e	enum:__anon77	file:
CMEANPATHMASK	HTKLib/HParm.c	/^   CMEANPATHMASK,\/* label mask to idenitfy the path of mean file *\/$/;"	e	enum:__anon77	file:
CMLLR	HTKLib/HModel.h	/^enum _XFormKind {MLLRMEAN, MLLRCOV, MLLRVAR, CMLLR, SEMIT};$/;"	e	enum:_XFormKind
CNE2FE	HLMLib/LModel.c	381;"	d	file:
CNew	HTKLib/HMem.c	/^Ptr CNew (MemHeap *x, size_t size)$/;"	f
CO	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon168	file:
COMMANDKEY	HTKLib/HGraf.h	/^enum _KeyType {NORMALKEY, SHIFTKEY, COMMANDKEY, CONTROLKEY, $/;"	e	enum:_KeyType
COMMCHAR	HTKLib/HLabel.c	582;"	d	file:
COMPRESSED	HTKLib/HRNLM.h	/^enum FileTypeEnum {TEXT, BINARY, COMPRESSED};$/;"	e	enum:FileTypeEnum
COMPRESSFACT	HTKLib/HParm.c	/^   COMPRESSFACT,  \/* Compression Factor fo PLP *\/$/;"	e	enum:__anon77	file:
CONREPLACE	HTKTools/HDMan.c	/^              REPLACEP, CONREPLACE, MERGEP, SPLITP, DELETEP, DELSOURCE, $/;"	e	enum:__anon158	file:
CONTROLKEY	HTKLib/HGraf.h	/^enum _KeyType {NORMALKEY, SHIFTKEY, COMMANDKEY, CONTROLKEY, $/;"	e	enum:_KeyType
COVBASE	HTKLib/HModel.h	/^enum _BaseClassKind {MIXBASE, MEANBASE, COVBASE};$/;"	e	enum:_BaseClassKind
COV_KEY	HTKLib/HUtil.c	/^   MIX_KEY, MEAN_KEY, STREAM_KEY, COV_KEY$/;"	e	enum:__anon132	file:
COutP	HTKLib/HModel.c	/^static LogFloat COutP(Vector x, int vecSize, MixPDF *mp)$/;"	f	file:
CRCC_AT_CLOSE	HTKLib/HParm.c	3354;"	d	file:
CRCC_NONE	HTKLib/HParm.c	3353;"	d	file:
CRCC_STREAM	HTKLib/HParm.c	3355;"	d	file:
CREATEFIDX	HTKLib/HModel.c	66;"	d	file:
CREATE_OP	HTKTools/HSLab.c	/^   CREATE_OP, DELETE_OP, CHANGE_OP$/;"	e	enum:__anon146	file:
CRETURN	HTKLib/HLabel.c	584;"	d	file:
CRec	HTKTools/HHEd.c	/^}CRec;$/;"	t	typeref:struct:_CRec	file:
CTrans	HTKTools/HMMIRest.c	/^static float CTrans = 1.0;$/;"	v	file:
CUEDRNNLMAcceptWord	HTKLib/HRNLM.c	/^float CUEDRNNLMAcceptWord(RNNLM* rnnlm, int lastword, int curword)$/;"	f
CUEDRNNLMAcceptWord_v1_0	HTKLib/HRNLM.c	/^float CUEDRNNLMAcceptWord_v1_0 (RNNLM* rnnlm, int lastword, int curword)$/;"	f
CUEDRNNLMAcceptWord_v1_1	HTKLib/HRNLM.c	/^float CUEDRNNLMAcceptWord_v1_1 (RNNLM* rnnlm, int lastword, int curword)$/;"	f
CUEDRNNLMAcceptWord_v1_1_SU	HTKLib/HRNLM.c	/^float CUEDRNNLMAcceptWord_v1_1_SU (RNNLM* rnnlm, int lastword, int curword, int *succword)$/;"	f
CWeights	HTKTools/HMMIRest.c	/^static float CWeights = 1.0;$/;"	v	file:
CachingInitialised	HTKLib/HFBLat.c	/^Boolean CachingInitialised = FALSE;$/;"	v
CalNLMProb	HTKLib/HNLM.c	/^float CalNLMProb(char **in_seq, NNLM *NNlm, char *out, int Ngram)$/;"	f
CalOutputMatrix	HTKLib/HRNLM.c	/^void CalOutputMatrix (Matrix outputmatrix, struct synapse *syn, int nrows, int scol, int ecol)$/;"	f
CalcABSCoef	HLMLib/LPCalc.c	/^static double CalcABSCoef(int nSize, FoFTab *ftab) $/;"	f	file:
CalcAsError	HTKLib/HFBLat.c	/^static Boolean CalcAsError = FALSE;   \/* if TRUE, new way of calc'ing error... *\/ $/;"	v	file:
CalcBackOff	HLMLib/LPMerge.c	/^static void CalcBackOff(BackOffLM *lm, FLEntry **context,int lev) $/;"	f	file:
CalcClusterDistribution	HTKTools/HHEd.c	/^void CalcClusterDistribution(RNode *n, int vSize) $/;"	f
CalcCompress	HTKLib/HParm.c	/^static void CalcCompress(ParmBuf pbuf, PBlock *pbInit,int nCols, Boolean irefc)$/;"	f	file:
CalcCovs	HTKTools/HCompV.c	/^void CalcCovs(void)$/;"	f
CalcDiscountCoefs	HLMLib/LPCalc.c	/^static void CalcDiscountCoefs(BackOffLM *lm, FoFTab *ftab)$/;"	f	file:
CalcDistance	HTKTools/HHEd.c	/^void CalcDistance(CoList *list, RNode *ch1, RNode *ch2, int vSize)$/;"	f
CalcEnergy	HTKTools/HSLab.c	/^float CalcEnergy(int st,int en)$/;"	f
CalcGlobalFOM	HTKTools/HResults.c	/^void CalcGlobalFOM(void)$/;"	f
CalcHistsDistance	HTKLib/HRNLM.c	/^double CalcHistsDistance(Vector v1, Vector v2)$/;"	f
CalcKeyFOM	HTKTools/HResults.c	/^void CalcKeyFOM(int idx)$/;"	f
CalcMeanCov	HTKTools/HQuant.c	/^void CalcMeanCov(Sequence seq[], int s)$/;"	f
CalcNGramProbs	HLMLib/LPCalc.c	/^static int CalcNGramProbs(BackOffLM *lm, UInt *feId, int nSize, FLEntry *tgtFE, Boolean rebuild)$/;"	f	file:
CalcNodeScore	HTKTools/HHEd.c	/^float CalcNodeScore(RNode *n, int vSize) $/;"	f
CalcPerplexity	HLMTools/LPlex.c	/^static void CalcPerplexity(PStats *sent, LabId *pLab, int numPLabs, int nSize)$/;"	f	file:
CalcProbDistance	HTKLib/HRNLM.c	/^float CalcProbDistance(Vector v1, Vector v2)$/;"	f
CalcSilDetParms	HTKLib/HParm.c	/^static void CalcSilDetParms(ParmBuf pbuf, float *res, $/;"	f	file:
CalcStats	HTKLib/HLat.c	/^void CalcStats (Lattice *lat)$/;"	f
CalcTGCoefs	HLMLib/LPCalc.c	/^static void CalcTGCoefs(MemHeap *heap, BackOffInfo *boi, int nSize, FoFTab *ftab) $/;"	f	file:
CalcTMWeights	HTKTools/HHEd.c	/^Vector CalcTMWeights(int s, StreamElem *ste, double tFloor)$/;"	f
CalcUniProbs	HLMLib/LPCalc.c	/^static int CalcUniProbs(BackOffLM *lm, FLEntry *tgtFE, Boolean rebuild)$/;"	f	file:
CalcVolume	HTKLib/HAudio.c	/^static float CalcVolume(short *data, int len)$/;"	f	file:
CalcWBar	HTKTools/HSmooth.c	/^void CalcWBar(Vector wb, int dBlk, int M)$/;"	f
CalcWCd	HTKTools/HSmooth.c	/^void CalcWCd(Vector wc, int dBlk, StreamElem *ste, int M)$/;"	f
CalcWordClassProbs	HLMLib/LModel.c	/^static void CalcWordClassProbs(BackOffLM *lm)$/;"	f	file:
CalculateNGram	HLMLib/LPCalc.c	/^static int CalculateNGram(BackOffLM *lm, NGInputSet *inSet, int nSize)$/;"	f	file:
CanCompact	HTKTools/HParse.c	/^static Boolean CanCompact(Link p)$/;"	f	file:
Cell	HTKTools/HResults.c	/^} Cell;$/;"	t	typeref:struct:_Cell	file:
CellPtr	HTKTools/HResults.c	/^typedef struct _Cell *CellPtr;$/;"	t	typeref:struct:_Cell	file:
CentreX	HTKLib/HGraf.c	/^int CentreX(int x, char *str)$/;"	f
CentreX	HTKLib/HGraf.null.c	/^int CentreX(int x, char *str)$/;"	f
CentreX	HTKLib/HGraf_WIN32.c	/^int CentreX(int x, char *str)$/;"	f
CentreY	HTKLib/HGraf.c	/^int CentreY(int y, char *str)$/;"	f
CentreY	HTKLib/HGraf.null.c	/^int CentreY(int y, char *str)$/;"	f
CentreY	HTKLib/HGraf_WIN32.c	/^int CentreY(int y, char *str)$/;"	f
Cepstrum2LPC	HTKLib/HSigP.c	/^void Cepstrum2LPC (Vector c, Vector a)$/;"	f
ChWtAcc	HTKTools/HSmooth.c	/^} ChWtAcc;$/;"	t	typeref:struct:_ChWtAcc	file:
ChangeOp	HTKTools/HLEd.c	/^int ChangeOp(LabList *ll,LabId *args)$/;"	f
ChangeState	HTKLib/HAudio.c	/^static void ChangeState(AudioIn a, AudioInStatus newState)$/;"	f	file:
ChangeState	HTKLib/HParm.c	/^static void ChangeState(ParmBuf pbuf, PBStatus newState)$/;"	f	file:
ChannelInfo	HTKLib/HParm.c	/^ChannelInfo;$/;"	t	typeref:struct:channelinfo	file:
ChannelType	HTKLib/HParm.c	/^ChannelType;$/;"	t	typeref:enum:channeltype	file:
CheckAdaptOptions	HTKLib/HAdapt.c	/^static void CheckAdaptOptions()$/;"	f	file:
CheckAndFillBuffer	HTKLib/HParm.c	/^static void CheckAndFillBuffer(ParmBuf pbuf)$/;"	f	file:
CheckBaseClass	HTKLib/HModel.c	/^static ReturnStatus CheckBaseClass(HMMSet *hset, BaseClass *bclass)$/;"	f	file:
CheckBuffer	HTKLib/HParm.c	/^static void CheckBuffer(ParmBuf pbuf)$/;"	f	file:
CheckButtonList	HTKLib/HGraf.c	/^HButton *CheckButtonList(HButton *btnlst, int x, int y)$/;"	f
CheckButtonList	HTKLib/HGraf.null.c	/^HButton *CheckButtonList(HButton *btnlst, int x, int y)$/;"	f
CheckButtonList	HTKLib/HGraf_WIN32.c	/^HButton *CheckButtonList(HButton *btnlst, int x, int y)$/;"	f
CheckCorners	HTKLib/HGraf.c	/^static void CheckCorners(int *x0, int *y0, int *x1, int *y1)$/;"	f	file:
CheckCorners	HTKLib/HGraf_WIN32.c	/^static void CheckCorners(int *x0, int *y0, int *x1, int *y1)$/;"	f	file:
CheckCutoffs	HLMLib/LPCalc.c	/^static void CheckCutoffs(BackOffLM *lm)$/;"	f	file:
CheckData	HTKLib/HFB.c	/^static void CheckData(HMMSet *hset, char *fn, BufferInfo *info, $/;"	f	file:
CheckData	HTKLib/HFBLat.c	/^static void CheckData(char *fn, BufferInfo *info) $/;"	f	file:
CheckData	HTKTools/HCompV.c	/^void CheckData(char *fn, BufferInfo info) $/;"	f
CheckData	HTKTools/HInit.c	/^void CheckData(char *fn, BufferInfo info) $/;"	f
CheckData	HTKTools/HQuant.c	/^void CheckData(char *fn, BufferInfo newInfo) $/;"	f
CheckData	HTKTools/HRest.c	/^void CheckData(char *fn, BufferInfo info) $/;"	f
CheckDiscrete	HTKLib/HModel.c	/^static ReturnStatus CheckDiscrete(HMMSet *hset)$/;"	f	file:
CheckFn	HTKLib/HShell.c	/^static char *CheckFn(char *fn)$/;"	f	file:
CheckForSave	HTKTools/HSLab.c	/^void CheckForSave(void)$/;"	f
CheckHMM	HTKLib/HModel.c	/^static ReturnStatus CheckHMM(char *defName, HLink hmm)$/;"	f	file:
CheckHSet	HTKLib/HModel.c	/^static ReturnStatus CheckHSet(HMMSet *hset)$/;"	f	file:
CheckMarker	HTKLib/HTrain.c	/^static void CheckMarker(Source *src)$/;"	f	file:
CheckMix	HTKLib/HModel.c	/^static ReturnStatus CheckMix(char *defName, MixPDF *mp, int n, int s, int m, int sw)$/;"	f	file:
CheckOptions	HTKLib/HModel.c	/^static ReturnStatus CheckOptions(HMMSet *hset)$/;"	f	file:
CheckPName	HTKLib/HTrain.c	/^static void CheckPName(Source *src, char *pname)$/;"	f	file:
CheckPruning	HTKLib/HFB.c	/^static void CheckPruning(AlphaBeta *ab, int t, int skipstart, int skipend)$/;"	f	file:
CheckSemiTiedOptions	HTKLib/HAdapt.c	/^static void CheckSemiTiedOptions(AdaptXForm *xform, AccStruct *accs)$/;"	f	file:
CheckStEndNodes	HTKLib/HNet.c	/^static ReturnStatus CheckStEndNodes(Lattice *lat)$/;"	f	file:
CheckState	HTKLib/HModel.c	/^static ReturnStatus CheckState(char *defName, HLink hmm, StateInfo *si, int n)$/;"	f	file:
CheckStream	HTKLib/HModel.c	/^static ReturnStatus CheckStream(char *defName, HLink hmm, StreamElem *se, int s, int n)$/;"	f	file:
CheckStreamWidths	HTKTools/HQuant.c	/^void CheckStreamWidths(BufferInfo info)$/;"	f
CheckTMRecs	HTKLib/HModel.c	/^static ReturnStatus CheckTMRecs(HMMSet *hset)$/;"	f	file:
CheckUpdateSetUp	HTKTools/HERest.c	/^void CheckUpdateSetUp()$/;"	f
CheckVarianceKind	HTKTools/HCompV.c	/^void CheckVarianceKind(void)$/;"	f
ChkTreeObject	HTKTools/HHEd.c	/^void ChkTreeObject(ILink obj)$/;"	f
ChkType	HTKLib/HUtil.c	/^static void ChkType(char newtype, char *type)$/;"	f	file:
ChkedAlpha	HTKTools/HHEd.c	/^char *ChkedAlpha(char *what,char *buf)$/;"	f
ChkedFloat	HTKTools/HHEd.c	/^float ChkedFloat(char *what,float min,float max)$/;"	f
ChkedInt	HTKTools/HHEd.c	/^int ChkedInt(char *what,int min,int max)$/;"	f
Choleski	HTKLib/HMath.c	/^static Boolean Choleski(TriMat A, DMatrix L)$/;"	f	file:
ChopLabs	HTKTools/HCopy.c	/^void ChopLabs(Transcription *t, HTime start, HTime end)$/;"	f
ChopParm	HTKTools/HCopy.c	/^ParmBuf ChopParm(ParmBuf b, HTime start, HTime end, HTime sampRate)$/;"	f
ChopTriMat	HTKTools/HHEd.c	/^TriMat ChopTriMat(TriMat mat, int i, int j, int k)$/;"	f
ChopVector	HTKTools/HHEd.c	/^Vector ChopVector(Vector vec, int i, int j, int k)$/;"	f
ChopWave	HTKTools/HCopy.c	/^Wave ChopWave(Wave srcW, HTime start, HTime end, HTime sampRate)$/;"	f
ClampStEn	HTKTools/HCopy.c	/^void ClampStEn(HTime length, HTime *st, HTime *en)$/;"	f
ClassEntry	HLMLib/LCMap.h	/^} ClassEntry;$/;"	t	typeref:struct:clEntry
ClassMap	HLMLib/LCMap.h	/^} ClassMap;$/;"	t	typeref:struct:__anon21
ClassSize	HLMLib/LCMap.c	/^int ClassSize(ClassMap *c, int clndx)$/;"	f
ClassifyMLFPattern	HTKLib/HLabel.c	/^MLFPatType ClassifyMLFPattern(char *s)$/;"	f
ClearBoNGram	HTKLib/HLM.c	/^void ClearBoNGram(LModel *lm)$/;"	f
ClearDepth	HTKLib/HModel.h	/^typedef enum {CLR_HMMS,CLR_STATES,CLR_STREAMS,CLR_ALL} ClearDepth;$/;"	t	typeref:enum:__anon71
ClearJMat	HTKTools/HParse.c	/^static void ClearJMat(void)$/;"	f	file:
ClearLModel	HTKLib/HLM.c	/^void ClearLModel(LModel *lm)$/;"	f
ClearSeenFlags	HTKLib/HModel.c	/^void ClearSeenFlags(HMMSet *hset, ClearDepth depth)$/;"	f
ClearSet	HTKLib/HUtil.c	/^void ClearSet(IntSet s)$/;"	f
ClearStreams	HTKLib/HModel.c	/^void ClearStreams(HMMSet *hset, StreamElem *ste, ClearDepth depth)$/;"	f
ClearVocab	HTKLib/HDict.c	/^void ClearVocab(Vocab *voc)$/;"	f
ClientRect	HTKLib/HGraf_WIN32.c	/^static RECT  ClientRect;$/;"	v	file:
ClipSample	HTKTools/HSLab.c	/^short ClipSample(short sample, float sampleScale)$/;"	f
CloneCommand	HTKTools/HHEd.c	/^void CloneCommand(void)$/;"	f
CloneHMM	HTKLib/HUtil.c	/^void CloneHMM(HLink src, HLink tgt, Boolean sharing)$/;"	f
CloneInputSet	HLMLib/LPCalc.c	/^static NGInputSet *CloneInputSet(NGInputSet *src,NGInputSet *tgt)$/;"	f	file:
CloneMixPDF	HTKLib/HUtil.c	/^MixPDF *CloneMixPDF(HMMSet *hset, MixPDF *s, Boolean sharing)$/;"	f
CloneNetwork	HTKTools/HParse.c	/^HPNetwork CloneNetwork(HPNetwork prototype)$/;"	f
CloneRNNLM	HTKLib/HRNLM.c	/^void CloneRNNLM(RNNLM* src, RNNLM* tgt)$/;"	f
CloneSMatrix	HTKLib/HUtil.c	/^SMatrix CloneSMatrix(MemHeap *hmem, SMatrix s, Boolean sharing)$/;"	f
CloneSTriMat	HTKLib/HUtil.c	/^STriMat CloneSTriMat(MemHeap *hmem, STriMat s, Boolean sharing)$/;"	f
CloneSVector	HTKLib/HUtil.c	/^SVector CloneSVector(MemHeap *hmem, SVector s, Boolean sharing)$/;"	f
CloneState	HTKLib/HUtil.c	/^StateInfo *CloneState(HMMSet *hset, StateInfo *ssi, Boolean sharing)$/;"	f
CloneStream	HTKLib/HUtil.c	/^MixtureVector CloneStream(HMMSet *hset, StreamElem *ste, Boolean sharing)$/;"	f
CloseAudi	HTKLib/HAudio.c	/^static void CloseAudi(AudioIn a)$/;"	f	file:
CloseAudioInput	HTKLib/HAudio.c	/^void CloseAudioInput(AudioIn a)$/;"	f
CloseAudioOutput	HTKLib/HAudio.c	/^void CloseAudioOutput(AudioOut a)$/;"	f
CloseAudo	HTKLib/HAudio.c	/^static void CloseAudo(AudioOut a)$/;"	f	file:
CloseBuffer	HTKLib/HParm.c	/^void CloseBuffer(ParmBuf pbuf)$/;"	f
CloseInputSet	HLMLib/LGBase.c	/^void CloseInputSet(NGInputSet *inset)$/;"	f
CloseLLF	HTKLib/HLat.c	/^void CloseLLF (LLFInfo *llf)$/;"	f
CloseMLFSaveFile	HTKLib/HLabel.c	/^void CloseMLFSaveFile(void)$/;"	f
CloseNGramFile	HLMLib/LGBase.c	/^void CloseNGramFile(NGSource *ngs)$/;"	f
CloseSource	HTKLib/HShell.c	/^void CloseSource(Source *src)$/;"	f
CloseWaveInput	HTKLib/HWave.c	/^void CloseWaveInput(Wave w)$/;"	f
CloseWaveOutput	HTKLib/HWave.c	/^ReturnStatus CloseWaveOutput(Wave w, FileFormat fmt, char *fname)$/;"	f
ClosedDict	HTKLib/HNet.c	/^static Boolean ClosedDict(Vocab *voc,HMMSet *hset)$/;"	f	file:
ClrSpkrAcc	HTKTools/HCompV.c	/^void ClrSpkrAcc(SpkrAcc *sa)$/;"	f
Cluster	HTKLib/HTrain.h	/^}Cluster;$/;"	t	typeref:struct:__anon109
ClusterChildren	HTKTools/HHEd.c	/^void ClusterChildren(RNode *parent, RNode *ch1, RNode *ch2, int vSize) $/;"	f
ClusterCommand	HTKTools/HHEd.c	/^void ClusterCommand(Boolean nCluster)$/;"	f
ClusterLogL	HTKTools/HHEd.c	/^float ClusterLogL(CLink clist,AccSum *no,AccSum *yes,float *occs)$/;"	f
ClusterSet	HTKLib/HTrain.h	/^}ClusterSet;$/;"	t	typeref:struct:__anon110
ClusterVecs	HTKTools/HQuant.c	/^void ClusterVecs(Sequence *seq, int s)$/;"	f
Cluster_vc_id	HLMTools/Cluster.c	/^char *Cluster_vc_id = "$Id: Cluster.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
Cluster_version	HLMTools/Cluster.c	/^char *Cluster_version = "!HVER!Cluster:   3.4.1 [CUED 12\/03\/09]";$/;"	v
Clustering	HTKTools/HHEd.c	/^void Clustering(ILink ilist, int *numReq, float threshold,$/;"	f
CmdIndex	HTKTools/HHEd.c	/^int CmdIndex(char *s)$/;"	f
CmdIndex	HTKTools/HLEd.c	/^int CmdIndex(char *s)$/;"	f
CmpCntr	HTKTools/HLStats.c	/^int CmpCntr(const void *p1, const void *p2)$/;"	f
CmpFE	HLMLib/LModel.c	/^int CmpFE(const void *p1, const void *p2)$/;"	f
CmpListEntry	HLMLib/LWMap.c	/^static int CmpListEntry(const void *p1, const void *p2)$/;"	f	file:
CmpMapEntry	HLMLib/LWMap.c	/^static int CmpMapEntry(const void *p1, const void *p2)$/;"	f	file:
CmpNGram	HLMLib/LGBase.c	/^static int CmpNGram(WordMap *wm, int N, UInt *ng1, UInt *ng2)$/;"	f	file:
CmpOOVE	HLMTools/LPlex.c	/^static int CmpOOVE(const void *p1, const void *p2)$/;"	f	file:
CmpSE	HLMLib/LModel.c	/^int CmpSE(const void *p1, const void *p2)$/;"	f
CmpTM	HTKLib/HModel.c	/^static int CmpTM(const void *t1, const void *t2)$/;"	f	file:
CmpTxtNGram	HLMLib/LGBase.c	/^static int CmpTxtNGram(int N, LabId *ng1, LabId *ng2)$/;"	f	file:
CmpWord	HTKTools/HDMan.c	/^static int CmpWord(const void *p1, const void *p2)$/;"	f	file:
CmpWordInfo	HTKTools/HLStats.c	/^int CmpWordInfo(const void *p1, const void *p2)$/;"	f
Cntr	HTKTools/HLStats.c	/^} Cntr;$/;"	t	typeref:struct:cntr	file:
CoList	HTKTools/HHEd.c	/^} CoList;$/;"	t	typeref:struct:_CoList	file:
CodeStyle	HTKLib/HParm.c	/^typedef enum { FFTbased, LPCbased, VQbased} CodeStyle;$/;"	t	typeref:enum:__anon75	file:
CollectPaths	HTKLib/HRec.c	/^static void CollectPaths(void)$/;"	f	file:
CollectStats	HTKTools/HResults.c	/^void CollectStats(int i,int j)$/;"	f
CombineModels	HLMTools/LAdapt.c	/^BackOffLM *CombineModels(MemHeap *heap,LMInfo *lmi,int nLModel,int nSize,WordMap *wl) $/;"	f
CommandSet	HTKTools/HSLab.c	/^Boolean CommandSet(HSlabCmdType hcmd, char *s)$/;"	f
CommonChunk1	HTKLib/HWave.c	/^} CommonChunk1;$/;"	t	typeref:struct:__anon105	file:
CommonChunk2	HTKLib/HWave.c	/^} CommonChunk2;   $/;"	t	typeref:struct:__anon106	file:
CompBlockSizes	HTKLib/HAdapt.c	/^static Boolean CompBlockSizes(IntVec blocks1, IntVec blocks2)$/;"	f	file:
CompFXForm	HTKLib/HAdapt.c	/^static Vector CompFXForm(MixPDF *mp, Vector svec, AdaptXForm *xform, AInfo *ai, LogFloat *det)$/;"	f	file:
CompXForm	HTKLib/HAdapt.c	/^static void CompXForm(MixPDF *mp, AdaptXForm *xform, AInfo *ai)$/;"	f	file:
CompactCommand	HTKTools/HHEd.c	/^void CompactCommand(void)$/;"	f
CompactGlueNode	HTKTools/HParse.c	/^static void CompactGlueNode(Link p)$/;"	f	file:
CompareMInfo	HTKLib/HAdapt.c	/^static Boolean CompareMInfo(HMMSet *hset, AdaptXForm *xform)$/;"	f	file:
CompareMapNames	HLMLib/LGBase.c	/^static Boolean CompareMapNames(char *ngfMap, char *master)$/;"	f	file:
CompareXFormInfo	HTKLib/HAdapt.c	/^static Boolean CompareXFormInfo(AdaptXForm *xform1, AdaptXForm *xform2)$/;"	f	file:
CompleteRecognition	HTKLib/HRec.c	/^Lattice *CompleteRecognition(VRecInfo *vri,HTime frameDur,MemHeap *heap)$/;"	f
CompressBuffer	HLMTools/LAdapt.c	/^void CompressBuffer(NGBuffer *ngb, Boolean mustSave)$/;"	f
CompressBuffer	HLMTools/LGCopy.c	/^static void CompressBuffer(Boolean mustSave)$/;"	f	file:
CompressBuffer	HLMTools/LGPrep.c	/^void CompressBuffer(NGBuffer *ngb, Boolean mustSave)$/;"	f
CompressItemList	HTKLib/HModel.c	/^static void CompressItemList(MemHeap *x, ILink ilist, ILink *bilist)$/;"	f	file:
CompressPBlock	HTKLib/HParm.c	/^static void CompressPBlock(ParmBuf pbuf, PBlock *pb, short *sp, int nCols)$/;"	f	file:
CompressType	HTKLib/HWave.c	/^typedef enum _CompressType CompressType;$/;"	t	typeref:enum:_CompressType	file:
ComputeFoFTab	HLMLib/LPCalc.c	/^void ComputeFoFTab(FoFTab *ftab, int nSize, NGInputSet *inSet)$/;"	f
ComputeVSize	HTKTools/HSGen.c	/^void ComputeVSize(void)$/;"	f
ConcatFN	HTKLib/HModel.c	/^static char *ConcatFN(char *path, char *base, char *ext, char *fname)$/;"	f	file:
ConfKind	HTKLib/HShell.h	/^} ConfKind;$/;"	t	typeref:enum:__anon85
ConfParam	HTKLib/HShell.h	/^} ConfParam;$/;"	t	typeref:struct:__anon87
ConfVal	HTKLib/HShell.h	/^}ConfVal;$/;"	t	typeref:union:__anon86
ConfigEntry	HTKLib/HShell.c	/^}ConfigEntry;$/;"	t	typeref:struct:_ConfigEntry	file:
ConsArcList	HTKLib/HArc.c	/^ArcList *ConsArcList(MemHeap *mem, HArc *h, ArcList *t){$/;"	f
ConsumeHeader	HTKLib/HWave.c	/^static void ConsumeHeader(FILE *f, int bytesRead, int headSize)$/;"	f	file:
Context	HTKTools/HLEd.c	/^} Context;$/;"	t	typeref:struct:_Context	file:
ContextName	HTKLib/HNet.c	/^static LabId ContextName(HMMSetCxtInfo *hci,int c)$/;"	f	file:
ContextRep	HTKTools/HDMan.c	/^void ContextRep(Pronunciation *p, LabId *args, DBuffer *db)$/;"	f
ContextReplaceOp	HTKTools/HDMan.c	/^void ContextReplaceOp(WordBuf *wb, LabId *args, DBuffer *db)$/;"	f
ConvDiagC	HTKLib/HUtil.c	/^void ConvDiagC(HMMSet *hset, Boolean convData)$/;"	f
ConvExpWt	HTKLib/HUtil.c	/^void ConvExpWt(HMMSet *hset)$/;"	f
ConvLogLikeFromBase	HTKLib/HNet.c	532;"	d	file:
ConvLogLikeToBase	HTKLib/HNet.c	534;"	d	file:
ConvLogWt	HTKLib/HUtil.c	/^void ConvLogWt(HMMSet *hset)$/;"	f
ConvertCont2Tied	HTKTools/HHEd.c	/^void ConvertCont2Tied(void)$/;"	f
ConvertFrame	HTKLib/HParm.c	/^static int ConvertFrame(IOConfig cf, float *pbuf)$/;"	f	file:
ConvertHParseNetwork	HTKTools/HParse.c	/^static void ConvertHParseNetwork(HPNetwork *theNet, char *latFn, char *dictFn)$/;"	f	file:
ConvertNISTData	HTKLib/HWave.c	/^ReturnStatus ConvertNISTData(Wave w, InputAction ia)$/;"	f
ConvertSUNAU8Data	HTKLib/HWave.c	/^static ReturnStatus ConvertSUNAU8Data(Wave w)$/;"	f	file:
ConvertToLog	HLMLib/LPCalc.c	/^static void ConvertToLog(FLEntry *parent)$/;"	f	file:
ConvertWAVData	HTKLib/HWave.c	/^ReturnStatus ConvertWAVData(Wave w, InputAction *ia)$/;"	f
CopyAdaptXForm	HTKLib/HAdapt.c	/^AdaptXForm *CopyAdaptXForm(MemHeap *x, AdaptXForm *xform)$/;"	f
CopyDColumn	HTKLib/HMath.c	/^static void CopyDColumn(DMatrix M, int k, DVector v) $/;"	f	file:
CopyDMatrix	HTKLib/HMath.c	/^void CopyDMatrix(DMatrix m1, DMatrix m2)$/;"	f
CopyDRow	HTKLib/HMath.c	/^static void CopyDRow(DMatrix M, int k, DVector v) $/;"	f	file:
CopyDVector	HTKLib/HMath.c	/^void CopyDVector(DVector v1, DVector v2)$/;"	f
CopyFiles	HLMTools/LGCopy.c	/^static void CopyFiles(void)$/;"	f	file:
CopyHiddenAc	HTKLib/HRNLM.c	/^void CopyHiddenAc (Layer *self)$/;"	f
CopyIntVec	HTKLib/HMath.c	/^void CopyIntVec(IntVec v1, IntVec v2)$/;"	f
CopyLabelList	HTKLib/HLabel.c	/^LabList* CopyLabelList(MemHeap *x, LabList* ll)$/;"	f
CopyLattice	HTKLib/HNet.c	/^void CopyLattice(Lattice *lat, Lattice *newlat,$/;"	f
CopyLinXForm	HTKLib/HAdapt.c	/^LinXForm *CopyLinXForm(MemHeap *x, LinXForm *xf)$/;"	f
CopyMatrix	HTKLib/HMath.c	/^void CopyMatrix(Matrix m1, Matrix m2)$/;"	f
CopyShortVec	HTKLib/HMath.c	/^void CopyShortVec(ShortVec v1, ShortVec v2)$/;"	f
CopyString	HTKLib/HMem.c	/^char *CopyString(MemHeap *x, char *s)$/;"	f
CopyTranscription	HTKLib/HLabel.c	/^Transcription *CopyTranscription(MemHeap *x, Transcription *t)$/;"	f
CopyTriMat	HTKLib/HMath.c	/^void CopyTriMat(TriMat m1, TriMat m2)$/;"	f
CopyVector	HTKLib/HMath.c	/^void CopyVector(Vector v1, Vector v2)$/;"	f
CopyWordBuf	HTKTools/HDMan.c	/^void CopyWordBuf(DBuffer *s, DBuffer *t)$/;"	f
CopyXFormSet	HTKLib/HAdapt.c	/^XFormSet *CopyXFormSet(MemHeap *x, XFormSet *xfset)$/;"	f
CorrA	HTKLib/HArc.h	/^typedef struct _CorrA CorrA;$/;"	t	typeref:struct:_CorrA
CorrN	HTKLib/HArc.h	/^typedef struct _CorrN CorrN; \/* for exact MPE. *\/$/;"	t	typeref:struct:_CorrN
CorrectArc	HTKLib/HFBLat.c	/^} CorrectArc;$/;"	t	typeref:struct:__anon89	file:
CorrectArcList	HTKLib/HFBLat.c	/^} CorrectArcList;$/;"	t	typeref:struct:_CorrectArcList	file:
CountAuxLabs	HTKLib/HLabel.c	/^int CountAuxLabs(LabList *ll, int i)$/;"	f
CountClassTotals	HLMLib/LModel.c	/^static void CountClassTotals(BackOffLM *lm)$/;"	f	file:
CountDefunctMix	HTKTools/HHEd.c	/^int CountDefunctMix(StreamElem *ste)$/;"	f
CountEntries	HLMLib/LModel.c	/^static void CountEntries(int lev, int nSize, FLEntry *tgtFE, int *nfe, int *nse)$/;"	f	file:
CountHits	HTKTools/HResults.c	/^void CountHits(int idx, int *nh, int *nf)$/;"	f
CountLabs	HTKLib/HLabel.c	/^int CountLabs(LabList *ll)$/;"	f
CountNonNullNodes	HTKLib/HNet.c	/^static int CountNonNullNodes(Lattice *lat)$/;"	f	file:
CounterFN	HTKLib/HShell.c	/^char * CounterFN(char *prefix, char* suffix, int count, int width, char *s)$/;"	f
CovAcc	HTKTools/HCompV.c	/^} CovAcc;$/;"	t	typeref:struct:__anon151	file:
CovDet	HTKLib/HMath.c	/^LogFloat CovDet(TriMat c)$/;"	f
CovInvert	HTKLib/HMath.c	/^LogFloat CovInvert(TriMat c, Matrix invc)$/;"	f
CovKind	HTKLib/HMath.h	/^} CovKind;$/;"	t	typeref:enum:__anon43
CovKind2Str	HTKLib/HModel.c	/^char *CovKind2Str(CovKind ckind, char *buf)$/;"	f
Covariance	HTKLib/HMath.h	/^} Covariance;$/;"	t	typeref:union:__anon44
CreateAccCache	HTKLib/HAdapt.c	/^static AccCache  *CreateAccCache(IntVec size,  int b)$/;"	f	file:
CreateAccStruct	HTKLib/HAdapt.c	/^static AccStruct *CreateAccStruct(MemHeap *x, AdaptXForm *xform, $/;"	f	file:
CreateAdaptXForm	HTKLib/HAdapt.c	/^AdaptXForm *CreateAdaptXForm(HMMSet *hset, char *xformName)$/;"	f
CreateAlpha	HTKLib/HFB.c	/^static void CreateAlpha(AlphaBeta *ab, HMMSet *hset, int Q)$/;"	f	file:
CreateArc	HTKLib/HArc.c	/^HArc *CreateArc(MemHeap *mem, Lattice *lat, LArc *la, int start_time, int pos, int arcId, HArc *lastArc, float insPen, float lmScale, HMMSet *hset, ArcInfo *aInfo){ \/*Creates an arc.*\/$/;"	f
CreateBaseAdaptXForm	HTKLib/HAdapt.c	/^static AdaptXForm *CreateBaseAdaptXForm(HMMSet *hset, char *xformName)$/;"	f	file:
CreateBaseTriMat	HTKLib/HAdapt.c	/^static void CreateBaseTriMat(MemHeap *x, MixPDF *mp, AdaptXForm *xform, int class)$/;"	f	file:
CreateBeta	HTKLib/HFB.c	/^static void CreateBeta(AlphaBeta *ab, int T)$/;"	f	file:
CreateBetaQ	HTKLib/HFB.c	/^static DVector *CreateBetaQ(MemHeap *x, int qLo,int qHi,int Q)$/;"	f	file:
CreateBlockTriMat	HTKLib/HAdapt.c	/^static TriMat *CreateBlockTriMat(MemHeap *x, IntVec blockSize)$/;"	f	file:
CreateBoNGram	HTKLib/HLM.c	/^NGramLM *CreateBoNGram(LModel *lm,int vocSize, int counts[NSIZE])$/;"	f
CreateBuffer	HTKTools/HDMan.c	/^void CreateBuffer(char *dName, Boolean isInput)$/;"	f
CreateButtons	HTKTools/HSLab.c	/^void CreateButtons(void)$/;"	f
CreateCME	HTKLib/HModel.c	/^static MixtureElem *CreateCME(HMMSet *hset, int M)$/;"	f	file:
CreateChWtAcc	HTKTools/HSmooth.c	/^WALink CreateChWtAcc(MemHeap *x, int M)$/;"	f
CreateChildNodes	HTKTools/HHEd.c	/^void CreateChildNodes(CoList *list, RNode *ch1, RNode *ch2, int vSize) $/;"	f
CreateClassMap	HLMLib/LCMap.c	/^void CreateClassMap(char *fn, ClassMap *c, WordMap *w)$/;"	f
CreateClusterLink	HTKTools/HHEd.c	/^CoList *CreateClusterLink(char *s, int state, int stream, int mix, $/;"	f
CreateDME	HTKLib/HModel.c	/^static ShortVec CreateDME(HMMSet *hset, int M)$/;"	f	file:
CreateDMatrix	HTKLib/HMem.c	/^DMatrix CreateDMatrix(MemHeap *x, int nrows,int ncols)$/;"	f
CreateDVector	HTKLib/HMem.c	/^DVector CreateDVector(MemHeap *x, int size)$/;"	f
CreateFOMTab	HTKTools/HResults.c	/^void CreateFOMTab(void)$/;"	f
CreateFoFTab	HLMLib/LGBase.c	/^FoFTab *CreateFoFTab(MemHeap *mem, int size, int N)$/;"	f
CreateGrid	HTKTools/HResults.c	/^void CreateGrid(void)$/;"	f
CreateHButton	HTKLib/HGraf.c	/^HButton *CreateHButton(HButton *btnlst, ButtonId btnid, int x, int y, int w, $/;"	f
CreateHButton	HTKLib/HGraf.null.c	/^HButton *CreateHButton(HButton *btnlst, ButtonId btnid, int x, int y, int w, $/;"	f
CreateHButton	HTKLib/HGraf_WIN32.c	/^HButton *CreateHButton(HButton *btnlst, ButtonId btnid, int x, int y, int w, $/;"	f
CreateHMM	HTKLib/HModel.c	/^static ReturnStatus CreateHMM(HMMSet *hset, LabId lId, LabId pId)$/;"	f	file:
CreateHMMSet	HTKLib/HModel.c	/^void CreateHMMSet(HMMSet *hset, MemHeap *heap, Boolean allowTMods)$/;"	f
CreateHParseNetwork	HTKTools/HParse.c	/^static HPNetwork CreateHParseNetwork(char *fname)$/;"	f	file:
CreateHashTable	HLMLib/LUtil.c	/^HashTab *CreateHashTable(int hashSize, char *description)$/;"	f
CreateHeap	HTKLib/HMem.c	/^void CreateHeap(MemHeap *x, char *name, HeapType type, size_t elemSize, $/;"	f
CreateIEModels	HTKLib/HNet.c	/^void CreateIEModels(Word thisWord,PronHolder *pInst,int p,int q,$/;"	f
CreateInputSet	HLMLib/LGBase.c	/^void CreateInputSet(MemHeap *mem, WordMap *wm, NGInputSet *inset)$/;"	f
CreateInsts	HTKLib/HFB.c	/^static int CreateInsts(FBInfo *fbInfo, AlphaBeta *ab, int Q, Transcription *tr)$/;"	f	file:
CreateIntVec	HTKLib/HMem.c	/^IntVec CreateIntVec(MemHeap *x,int size)$/;"	f
CreateJMacros	HTKTools/HHEd.c	/^void CreateJMacros(LabId rootMacId)$/;"	f
CreateJMat	HTKTools/HParse.c	/^static void CreateJMat(void)$/;"	f	file:
CreateJMixSet	HTKTools/HHEd.c	/^MixtureElem * CreateJMixSet(void)$/;"	f
CreateLabObj	HTKTools/HSLab.c	/^Label *CreateLabObj(LabList *ll, LabId labid, long st, long en)$/;"	f
CreateLabel	HTKLib/HLabel.c	/^LLink CreateLabel(MemHeap *x, int maxAux)$/;"	f
CreateLabelList	HTKLib/HLabel.c	/^LabList* CreateLabelList(MemHeap *x, int maxAuxLab)$/;"	f
CreateLattice	HTKLib/HRec.c	/^static Lattice *CreateLattice(MemHeap *heap,TokenSet *res,HTime framedur)$/;"	f	file:
CreateLinXForm	HTKLib/HAdapt.c	/^static LinXForm *CreateLinXForm(MemHeap *x,int vsize,IntVec blockSize)$/;"	f	file:
CreateLinkSet	HTKTools/HParse.c	/^LinkSet *CreateLinkSet(int size)$/;"	f
CreateListorMap	HLMLib/LWMap.c	/^static void CreateListorMap(char *fn, WordMap *wm, int freeSlots, Boolean isMap)$/;"	f	file:
CreateMInfo	HTKLib/HAdapt.c	/^static MInfo *CreateMInfo(MemHeap *x, MixPDF *mp, AdaptXForm *xform)$/;"	f	file:
CreateMatBigram	HTKLib/HLM.c	/^MatBiLM *CreateMatBigram(LModel *lm,int nw)$/;"	f
CreateMatrix	HTKLib/HMem.c	/^Matrix CreateMatrix(MemHeap *x, int nrows, int ncols)$/;"	f
CreateMixes	HTKTools/HInit.c	/^IntVec *CreateMixes(MemHeap *x,int segLen)$/;"	f
CreateMonoList	HTKTools/HSmooth.c	/^void CreateMonoList(void)$/;"	f
CreateMuAcc	HTKLib/HTrain.c	/^static MuAcc *CreateMuAcc(MemHeap *x, int vSize, int nPara)$/;"	f	file:
CreateNGBuffer	HLMLib/LGBase.c	/^NGBuffer *CreateNGBuffer(MemHeap *mem, int N, int size, char *fn, WordMap *wm)$/;"	f
CreateNode	HTKTools/HParse.c	/^Link CreateNode(LabId name, Link *chain, int maxSucc, int maxPred)$/;"	f
CreateObsCache	HTKLib/HAdapt.c	/^static ObsCache *CreateObsCache(MemHeap *heap, ObsCache **headoc, int size)$/;"	f	file:
CreateOjsprob	HTKLib/HFB.c	/^static float *** CreateOjsprob(MemHeap *x, int N, int S)$/;"	f	file:
CreateOqprob	HTKLib/HFB.c	/^static float ****CreateOqprob(MemHeap *x, int qLo,int qHi)$/;"	f	file:
CreateOtprob	HTKLib/HFB.c	/^static void CreateOtprob(AlphaBeta *ab, int T)$/;"	f	file:
CreatePlotBuf	HTKTools/HSLab.c	/^void CreatePlotBuf(int size)$/;"	f
CreatePreComp	HTKLib/HTrain.c	/^static PreComp *CreatePreComp(MemHeap *x)$/;"	f	file:
CreateRNNLM	HTKLib/HRNLM.c	/^RNNLM* CreateRNNLM(MemHeap* x)$/;"	f
CreateRegAcc	HTKLib/HAdapt.c	/^static RegAcc *CreateRegAcc(MemHeap *x, MixPDF *mp, AdaptXForm *xform)$/;"	f	file:
CreateRegNode	HTKLib/HModel.c	/^static RegNode *CreateRegNode(MemHeap *m, int nodeId)$/;"	f	file:
CreateRegTreeNode	HTKTools/HHEd.c	/^RNode *CreateRegTreeNode(CoList *list, int vSize) $/;"	f
CreateReverseLookup	HLMLib/LModel.c	/^void CreateReverseLookup(FLEntry *fes)$/;"	f
CreateRuleSet	HLMTools/LGPrep.c	/^void CreateRuleSet(RuleSet *rset)$/;"	f
CreateSE	HTKLib/HModel.c	/^static StreamElem *CreateSE(HMMSet *hset, int S)$/;"	f	file:
CreateSEIndex	HTKLib/HRec.c	/^static void CreateSEIndex(PSetInfo *psi,HLink hmm)$/;"	f	file:
CreateSMatrix	HTKLib/HMem.c	/^Matrix CreateSMatrix(MemHeap *x, int nrows,int ncols)$/;"	f
CreateSTriMat	HTKLib/HMem.c	/^STriMat CreateSTriMat(MemHeap *x,int size)$/;"	f
CreateSVector	HTKLib/HMem.c	/^Vector CreateSVector(MemHeap *x, int size)$/;"	f
CreateSegStore	HTKLib/HTrain.c	/^SegStore CreateSegStore(MemHeap *x, Observation obs, int segLen)$/;"	f
CreateSeqMat	HTKTools/HInit.c	/^Sequence ** CreateSeqMat(void)$/;"	f
CreateSequence	HTKLib/HTrain.c	/^Sequence CreateSequence(MemHeap *x, int blkSize)$/;"	f
CreateSet	HTKLib/HUtil.c	/^IntSet CreateSet(int size)$/;"	f
CreateShortVec	HTKLib/HMem.c	/^ShortVec CreateShortVec(MemHeap *x,int size)$/;"	f
CreateSrcExt	HTKLib/HParm.c	/^HParmSrcDef CreateSrcExt(Ptr xInfo, ParmKind pk, int size, HTime sampPeriod, $/;"	f
CreateSubWindows	HTKTools/HSLab.c	/^void CreateSubWindows(void)$/;"	f
CreateTME	HTKLib/HModel.c	/^static Vector CreateTME(HMMSet *hset, int M)$/;"	f	file:
CreateTMRecs	HTKTools/HHEd.c	/^void CreateTMRecs(void)$/;"	f
CreateTrAcc	HTKLib/HFB.c	/^static TrAcc *CreateTrAcc(MemHeap *x, int numStates)$/;"	f	file:
CreateTrAcc	HTKLib/HTrain.c	/^static TrAcc *CreateTrAcc(MemHeap *x, int numStates, int nPara)$/;"	f	file:
CreateTraceOcc	HTKLib/HFB.c	/^static void CreateTraceOcc(AlphaBeta *ab, UttInfo *utt)$/;"	f	file:
CreateTranscription	HTKLib/HLabel.c	/^Transcription *CreateTranscription(MemHeap *x)$/;"	f
CreateTree	HTKTools/HHEd.c	/^Tree *CreateTree(ILink ilist,LabId baseId,int state)$/;"	f
CreateTreeNode	HTKTools/HHEd.c	/^Node *CreateTreeNode(CLink clist, Node *parent)$/;"	f
CreateTriMat	HTKLib/HMem.c	/^TriMat CreateTriMat(MemHeap *x,int size)$/;"	f
CreateVQNode	HTKLib/HVQ.c	/^VQNode CreateVQNode(short vqidx, short nid, short lid, short rid, $/;"	f
CreateVQTab	HTKLib/HVQ.c	/^VQTable CreateVQTab(char *tabFN, short magic, TreeType type,$/;"	f
CreateVaAcc	HTKLib/HTrain.c	/^static VaAcc *CreateVaAcc(MemHeap *x, int vSize, CovKind ck, int nPara)$/;"	f	file:
CreateVector	HTKLib/HMem.c	/^Vector CreateVector(MemHeap *x, int size)$/;"	f
CreateWIModels	HTKLib/HNet.c	/^void CreateWIModels(PronHolder *pInst,int p,int q,$/;"	f
CreateWStore	HTKTools/HSmooth.c	/^void CreateWStore(void)$/;"	f
CreateWave	HTKLib/HWave.c	/^static Wave CreateWave(MemHeap *x, FileFormat fmt)$/;"	f	file:
CreateWordList	HLMLib/LWMap.c	/^void CreateWordList(char *fn, WordMap *w, int freeSlots)$/;"	f
CreateWordMap	HLMLib/LWMap.c	/^void CreateWordMap(char *fn, WordMap *w, int freeSlots)$/;"	f
CreateWtAcc	HTKLib/HFB.c	/^static WtAcc *CreateWtAcc(MemHeap *x, int nMix)$/;"	f	file:
CreateWtAcc	HTKLib/HTrain.c	/^static WtAcc *CreateWtAcc(MemHeap *x, int nMix, int nPara)$/;"	f	file:
CreateWtStore	HTKTools/HSmooth.c	/^void CreateWtStore(MemHeap *x)$/;"	f
CreateX1Model	HTKLib/HNet.c	/^static void CreateX1Model(PronHolder *pInst,int p, int q,$/;"	f	file:
CreateXEModels	HTKLib/HNet.c	/^static void CreateXEModels(PronHolder *pInst,int p, int q,$/;"	f	file:
CreateXFormInfo	HTKLib/HAdapt.c	/^static XFormInfo *CreateXFormInfo(MemHeap *x)$/;"	f	file:
CreateXFormMacro	HTKLib/HModel.c	/^void CreateXFormMacro(HMMSet *hset,AdaptXForm *xform, char* macroname)$/;"	f
CurrentColour	HTKLib/HGraf_WIN32.c	/^static COLORREF CurrentColour = RGB(0,0,0);$/;"	v	file:
CurrentFont	HTKLib/HGraf.c	/^static XFontStruct  *DefaultFont, *CurrentFont, *FontInfo[NO_OF_FONTS];$/;"	v	file:
Cut-offs	HTKBook/hlmfund.tex	/^implemented as referring to whether or not the context is in the model.$/;"	b
D	HTKLib/HAdapt.c	/^   DVector *K, D;$/;"	m	struct:__anon92	file:
D	HTKTools/HSmooth.c	/^float D(float l, WALink wa, int M)$/;"	f
DARK_BLUE	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	e	enum:_HColour
DARK_BROWN	HTKLib/HGraf.h	/^                LIGHT_BLUE, DARK_GREEN, LIGHT_GREEN, DARK_BROWN, LIGHT_BROWN, $/;"	e	enum:_HColour
DARK_GREEN	HTKLib/HGraf.h	/^                LIGHT_BLUE, DARK_GREEN, LIGHT_GREEN, DARK_BROWN, LIGHT_BROWN, $/;"	e	enum:_HColour
DARK_GREY	HTKLib/HGraf.h	/^                LIGHT_GREY, GREY, DARK_GREY, BLACK};$/;"	e	enum:_HColour
DBLCX_FMT	HTKLib/esig_asc.c	75;"	d	file:
DBLCX_W	HTKLib/esig_asc.c	74;"	d	file:
DBLCX_WFMT	HTKLib/esig_asc.c	76;"	d	file:
DBL_FMT	HTKLib/esig_asc.c	43;"	d	file:
DBL_QUOTE	HTKLib/HShell.h	81;"	d
DBL_W	HTKLib/esig_asc.c	42;"	d	file:
DBL_WFMT	HTKLib/esig_asc.c	44;"	d	file:
DBUFLEN	HTKLib/HNet.c	898;"	d	file:
DBuffer	HTKTools/HDMan.c	/^}DBuffer;$/;"	t	typeref:struct:__anon162	file:
DCSaved	HTKLib/HGraf_WIN32.c	/^static HDC DCSaved;               \/* to store memDC when saving Metafile *\/$/;"	v	file:
DC_ABSOLUTE	HLMLib/LModel.h	/^   DC_KATZ, DC_ABSOLUTE, DC_LINEAR, DC_LAST$/;"	e	enum:__anon10
DC_KATZ	HLMLib/LModel.h	/^   DC_KATZ, DC_ABSOLUTE, DC_LINEAR, DC_LAST$/;"	e	enum:__anon10
DC_LAST	HLMLib/LModel.h	/^   DC_KATZ, DC_ABSOLUTE, DC_LINEAR, DC_LAST$/;"	e	enum:__anon10
DC_LINEAR	HLMLib/LModel.h	/^   DC_KATZ, DC_ABSOLUTE, DC_LINEAR, DC_LAST$/;"	e	enum:__anon10
DDistance	HTKTools/HHEd.c	/^float DDistance(StreamElem *s1, StreamElem *s2)$/;"	f
DEFCON	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon158	file:
DEFCON	HTKTools/HLEd.c	/^   REPLACE, CHANGE, FIND,   MERGE,  EDOP_DELETE, DEFCON, TRIST,  $/;"	e	enum:__anon141	file:
DEF_ABS_COEF	HLMLib/LPCalc.c	502;"	d	file:
DEF_CUTOFF	HLMLib/LPCalc.h	44;"	d
DEF_DCTYPE	HLMLib/LPCalc.h	48;"	d
DEF_ENDWORD	HLMLib/LModel.h	73;"	d
DEF_FONTSIZE	HTKLib/HGraf_WIN32.c	40;"	d	file:
DEF_KRANGE	HLMLib/LPCalc.h	43;"	d
DEF_LMPTYPE	HLMLib/LPCalc.h	47;"	d
DEF_NCLUST	HTKTools/HQuant.c	57;"	d	file:
DEF_SAVEFMT	HLMLib/LPCalc.h	46;"	d
DEF_SNR	HTKLib/HParm.c	2404;"	d	file:
DEF_STARTWORD	HLMLib/LModel.h	72;"	d
DEF_TG_COEF	HLMLib/LPCalc.c	519;"	d	file:
DEF_UNIFLOOR	HLMLib/LPCalc.h	45;"	d
DEF_UNKNOWNID	HLMLib/LCMap.h	44;"	d
DEF_UNKNOWNNAME	HLMLib/LCMap.h	43;"	d
DELDEF	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon158	file:
DELETEP	HTKTools/HDMan.c	/^              REPLACEP, CONREPLACE, MERGEP, SPLITP, DELETEP, DELSOURCE, $/;"	e	enum:__anon158	file:
DELETEW	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon158	file:
DELETE_OP	HTKTools/HSLab.c	/^   CREATE_OP, DELETE_OP, CHANGE_OP$/;"	e	enum:__anon146	file:
DELKEY	HTKLib/HGraf.h	/^               ENTERKEY, DELKEY, ESCKEY};$/;"	e	enum:_KeyType
DELLEV	HTKTools/HLEd.c	/^   RCTXT,   TCTXT,  SETLEV, DELLEV, SPLLEV, ISIL,$/;"	e	enum:__anon141	file:
DELSOURCE	HTKTools/HDMan.c	/^              REPLACEP, CONREPLACE, MERGEP, SPLITP, DELETEP, DELSOURCE, $/;"	e	enum:__anon158	file:
DELTAWINDOW	HTKLib/HParm.c	/^   DELTAWINDOW,   \/* Window size for 1st diffs *\/$/;"	e	enum:__anon77	file:
DFACTOR	HTKTools/HMMIRest.c	/^static float DFACTOR = 2.0;         \/* not a config, a constant used in estimating$/;"	v	file:
DIAG	HTKTools/HResults.c	/^enum _Direction{DIAG,VERT,HOR,NIL};$/;"	e	enum:_Direction	file:
DIAGC	HTKLib/HMath.h	/^   DIAGC,         \/* diagonal covariance *\/$/;"	e	enum:__anon43
DIAGCOV	HTKLib/HModel.c	/^   DIAGCOV,  FULLCOV, XFORMCOV,$/;"	e	enum:__anon40	file:
DISCRETE	HTKLib/HParm.h	/^      DISCRETE,                        \/* Discrete VQ symbols (shorts) *\/$/;"	e	enum:_BaseParmKind
DISCRETEHS	HTKLib/HModel.h	/^enum _HSetKind {PLAINHS, SHAREDHS, TIEDHS, DISCRETEHS};$/;"	e	enum:_HSetKind
DLOGSCALE	HTKLib/HModel.h	56;"	d
DLOGZERO	HTKLib/HModel.h	57;"	d
DLUDecompose	HTKLib/HMath.c	/^static Boolean DLUDecompose(DMatrix a, int *perm, int *sign)$/;"	f	file:
DLinSolve	HTKLib/HMath.c	/^static void DLinSolve(DMatrix a, int *perm, double *b)$/;"	f	file:
DMat2Mat	HTKLib/HMath.c	/^void DMat2Mat(DMatrix m1, Matrix m2)$/;"	f
DMatCofact	HTKLib/HMath.c	/^double DMatCofact(DMatrix c, int r, DVector cofact)$/;"	f
DMatDet	HTKLib/HMath.c	/^double DMatDet(DMatrix c)$/;"	f
DMatInvert	HTKLib/HMath.c	/^double DMatInvert(DMatrix c, DMatrix invc)$/;"	f
DMatrix	HTKLib/HMem.h	/^typedef double **DMatrix;  \/* double matrix[1..nrows][1..ncols] *\/$/;"	t
DMatrixElemSize	HTKLib/HMem.c	/^size_t DMatrixElemSize(int nrows,int ncols)$/;"	f
DOT	HTKLib/esignal.h	60;"	d
DOT_CHUNK	HLMLib/LPMerge.c	76;"	d	file:
DOUBLE	HTKLib/esignal.h	66;"	d
DOUBLEFFT	HTKLib/HParm.c	/^   DOUBLEFFT,     \/* Use twice the required FFT size *\/$/;"	e	enum:__anon77	file:
DOUBLE_COMPLEX	HTKLib/esignal.h	75;"	d
DOutP	HTKLib/HModel.c	/^static LogFloat DOutP(Vector x, int vecSize, MixPDF *mp)$/;"	f	file:
DP	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon168	file:
DPROB	HTKLib/HModel.c	/^   DURATION, INVDIAGCOV, TRANSP, DPROB, LLTCOV, LLTCOVAR,$/;"	e	enum:__anon40	file:
DProb2Short	HTKLib/HModel.c	/^short DProb2Short(float p)$/;"	f
DURATION	HTKLib/HModel.c	/^   DURATION, INVDIAGCOV, TRANSP, DPROB, LLTCOV, LLTCOVAR,$/;"	e	enum:__anon40	file:
DUR_KEY	HTKLib/HUtil.c	/^   TRANSP_KEY, STATE_KEY, DUR_KEY, WEIGHTS_KEY,$/;"	e	enum:__anon132	file:
DVector	HTKLib/HMem.h	/^typedef double *DVector;   \/* double vector[1..size]   *\/$/;"	t
DVectorElemSize	HTKLib/HMem.c	/^size_t DVectorElemSize(int size){ return (size+1)*sizeof(double);}$/;"	f
DVectorSize	HTKLib/HMem.c	/^int DVectorSize(DVector v)$/;"	f
Data Preparation Tools	HTKBook/htkoview.tex	/^main phases: data preparation, training, testing and analysis.$/;"	u
DeRefAlign	HTKLib/HRec.c	/^static void DeRefAlign(Align *align)$/;"	f	file:
DeRefPathPrev	HTKLib/HRec.c	/^static void DeRefPathPrev(Path *path)$/;"	f	file:
DebugMsg	HTKLib/esignal.h	298;"	d
DebugMsg	HTKLib/esignal.h	303;"	d
DebugMsgFunc	HTKLib/esignal.c	/^void    (*DebugMsgFunc)(char *msg);$/;"	v
DebugMsgLevel	HTKLib/esignal.c	/^int     DebugMsgLevel;$/;"	v
DebugPrint	HTKLib/esignal.c	/^DebugPrint(char *msg)$/;"	f
DecUse	HTKLib/HMem.c	/^void DecUse(Ptr m)$/;"	f
DecodeCommands	HTKTools/HSLab.c	/^void DecodeCommands(void)$/;"	f
DecodeIMuLaw	HTKLib/HWave.c	/^static void DecodeIMuLaw(Wave w)$/;"	f	file:
DecodeKeyPress	HTKLib/HGraf.c	/^static void DecodeKeyPress(XKeyEvent *xkev, HEventRec *hev)$/;"	f	file:
DecompressShortPack	HTKLib/HWave.c	/^void DecompressShortPack(Wave w)$/;"	f
DefaultFont	HTKLib/HGraf.c	/^static XFontStruct  *DefaultFont, *CurrentFont, *FontInfo[NO_OF_FONTS];$/;"	v	file:
DefineContext	HTKTools/HLEd.c	/^void DefineContext(LabId name, LabId *def, int nDefs)$/;"	f
DefineContexts	HTKLib/HNet.c	/^static int DefineContexts(HMMSetCxtInfo *hci)$/;"	f	file:
DefineSubNet	HTKTools/HParse.c	/^static void DefineSubNet(LabId name, Link entryNode, Link exitNode, Link chain)$/;"	f	file:
DelDefOp	HTKTools/HDMan.c	/^void DelDefOp(WordBuf *wb, LabId *args)$/;"	f
DelPron	HTKLib/HDict.c	/^void DelPron(Vocab *voc, Word word, Pron pron)$/;"	f
DelQualifiers	HTKLib/HParm.c	/^static void DelQualifiers(float *data, IOConfig cf)$/;"	f	file:
DelWord	HTKLib/HDict.c	/^void DelWord(Vocab *voc, Word word)$/;"	f
DeleteClass	HLMLib/LCMap.c	/^void DeleteClass(ClassMap *c, int clndx)$/;"	f
DeleteColumn	HTKLib/HParm.c	/^static void DeleteColumn(float *data, int nUsed, int si, int d)$/;"	f	file:
DeleteHeap	HTKLib/HMem.c	/^void DeleteHeap(MemHeap *x)$/;"	f
DeleteItem	HTKLib/HTrain.c	/^void DeleteItem(Sequence seq, int i)$/;"	f
DeleteLabObj	HTKTools/HSLab.c	/^void DeleteLabObj(LabList *ll, LLink q)$/;"	f
DeleteLabel	HTKLib/HLabel.c	/^void DeleteLabel(LLink item)$/;"	f
DeleteLevel	HTKTools/HLEd.c	/^void DeleteLevel(Transcription *ltr,int lev)$/;"	f
DeleteLink	HTKTools/HParse.c	/^static void DeleteLink(Link x, LinkSet *ls)$/;"	f	file:
DeleteMacro	HTKLib/HModel.c	/^void DeleteMacro(HMMSet *hset, MLink p)$/;"	f
DeleteMacroStruct	HTKLib/HModel.c	/^void DeleteMacroStruct(HMMSet *hset, char type, Ptr structure)$/;"	f
DeleteOp	HTKTools/HLEd.c	/^int DeleteOp(LabList *ll,LabId *args)$/;"	f
DeletePhoneOp	HTKTools/HDMan.c	/^void DeletePhoneOp(WordBuf *wb, LabId *args)$/;"	f
DeleteSourceOp	HTKTools/HDMan.c	/^int DeleteSourceOp(WordBuf *wb, LabId *args)$/;"	f
DeleteVRecInfo	HTKLib/HRec.c	/^void DeleteVRecInfo(VRecInfo *vri)$/;"	f
DeleteWordOp	HTKTools/HDMan.c	/^void DeleteWordOp(WordBuf *wb, LabId *args)$/;"	f
Depth	HTKLib/HArc.c	/^float Depth(ArcInfo *aInfo, Boolean All){$/;"	f
DetachInst	HTKLib/HRec.c	/^static void DetachInst(NetNode *node)$/;"	f	file:
DiagApplyMat2TXForm	HTKLib/HAdapt.c	/^static void DiagApplyMat2TXForm(LinXForm *linXForm, Matrix m, Vector v)$/;"	f	file:
DictEntry	HTKLib/HDict.h	/^} DictEntry;$/;"	t	typeref:struct:_DictEntry
DictFilter	HTKLib/HShell.h	/^   DictFilter,      \/* Dictionary file input via HDict *\/$/;"	e	enum:__anon83
DictOFilter	HTKLib/HShell.h	/^   DictOFilter,     \/* Dictionary file output via HDict *\/$/;"	e	enum:__anon83
Dictionary and Language Model	HTKBook/exampsys.tex	/^grammar scale factors in the range 12-15 are commonly used.$/;"	u
Direction	HTKTools/HResults.c	/^typedef enum _Direction Direction;$/;"	t	typeref:enum:_Direction	file:
DisconNode	HTKTools/HParse.c	/^static Boolean DisconNode(Link p)$/;"	f	file:
DiscountInfo	HLMLib/LModel.h	/^} DiscountInfo;$/;"	t	typeref:union:__anon12
DiscountType	HLMLib/LModel.h	/^} DiscountType;$/;"	t	typeref:enum:__anon10
DisplayNGramFile	HLMTools/LGList.c	/^void DisplayNGramFile(char *fn)$/;"	f
Dispose	HTKLib/HMem.c	/^void Dispose(MemHeap *x, void *p)$/;"	f
Distance	HTKLib/HTrain.c	/^static float Distance(Vector v1, Vector v2)$/;"	f	file:
Distance	HTKTools/HHEd.c	/^float Distance(Vector v1, Vector v2) $/;"	f
Divergence	HTKTools/HHEd.c	/^float Divergence(StreamElem *s1, StreamElem *s2)$/;"	f
Do8_16	HTKLib/HWave.c	/^               Do8_16  = 64,    \/* 8 bit PCM expansion needed *\/$/;"	e	enum:__anon99	file:
DoALAW	HTKLib/HWave.c	/^               DoALAW  = 32,    \/* 8 bit A-Law expansion needed *\/$/;"	e	enum:__anon99	file:
DoAbout	HTKTools/HSLab.c	/^void DoAbout(void)$/;"	f
DoAdjustLabel	HTKTools/HSLab.c	/^Boolean DoAdjustLabel(void)$/;"	f
DoAlignment	HTKTools/HVite.c	/^void DoAlignment(void)$/;"	f
DoAllMixUpdates	HTKLib/HFBLat.c	/^void DoAllMixUpdates(int t){$/;"	f
DoBSWAP	HTKLib/HWave.c	/^               DoBSWAP  = 2,     \/* byte swap needed *\/$/;"	e	enum:__anon99	file:
DoCMV	HTKTools/HCompV.c	/^static Boolean DoCMV = FALSE;            \/* switch from old HCompV to CMV *\/$/;"	v	file:
DoCVT	HTKLib/HWave.c	/^typedef enum { DoCVT    = 1,     \/* input conversion needed *\/$/;"	e	enum:__anon99	file:
DoChangeLabStr	HTKTools/HSLab.c	/^void DoChangeLabStr(void)$/;"	f
DoCompare	HTKTools/HResults.c	/^void DoCompare(void)$/;"	f
DoCompareNIST	HTKTools/HResults.c	/^void DoCompareNIST(void)$/;"	f
DoCorrectness	HTKLib/HExactMPE.c	/^float DoCorrectness(FBLatInfo *fbInfo, MemHeap *mem, ArcInfo *ai, float prune, $/;"	f
DoDelLab	HTKTools/HSLab.c	/^Boolean DoDelLab(void)$/;"	f
DoEdit	HTKTools/HHEd.c	/^void DoEdit(char * editFn)$/;"	f
DoEditLabel	HTKTools/HSLab.c	/^Boolean DoEditLabel(void)$/;"	f
DoExactCorrectness	HTKLib/HExactMPE.c	/^void DoExactCorrectness(FBLatInfo *fbInfo, Lattice *lat){$/;"	f
DoForwardBackward	HTKTools/HERest.c	/^void DoForwardBackward(FBInfo *fbInfo, UttInfo *utt, char * datafn, char * datafn2)$/;"	f
DoIncLabSet	HTKTools/HSLab.c	/^void DoIncLabSet(void)$/;"	f
DoIncScale	HTKTools/HSLab.c	/^void DoIncScale(void)$/;"	f
DoIncVolume	HTKTools/HSLab.c	/^void DoIncVolume(void)$/;"	f
DoLCtxt	HTKTools/HLEd.c	/^int DoLCtxt(LabList *ll,int nArgs,LabId *args)$/;"	f
DoLabel	HTKTools/HSLab.c	/^Boolean DoLabel(Boolean useLabStr)$/;"	f
DoLoad	HTKTools/HSLab.c	/^Boolean DoLoad(void)$/;"	f
DoMULAW	HTKLib/HWave.c	/^               DoMULAW  = 16,    \/* 8 bit Mu-Law expansion needed *\/$/;"	e	enum:__anon99	file:
DoMark	HTKTools/HSLab.c	/^Boolean DoMark(int *markA, int *markB)$/;"	f
DoMatch	HTKLib/HShell.c	/^Boolean DoMatch(char *s, char *p)$/;"	f
DoMixUpdate	HTKLib/HFBLat.c	/^void DoMixUpdate(MixPDF *mp, int s, float Lr, float meescale, int t){  $/;"	f
DoNewLabSet	HTKTools/HSLab.c	/^void DoNewLabSet(void)$/;"	f
DoOnlineAdaptation	HTKTools/HVite.c	/^int DoOnlineAdaptation(Lattice *lat, ParmBuf pbuf, int nFrames)$/;"	f
DoPause	HTKTools/HSLab.c	/^BtnId DoPause(void)$/;"	f
DoPlay	HTKTools/HSLab.c	/^void DoPlay(void)$/;"	f
DoPreComps	HTKLib/HTrain.c	75;"	d	file:
DoRCtxt	HTKTools/HLEd.c	/^int DoRCtxt(LabList *ll,int nArgs,LabId *args)$/;"	f
DoRecognition	HTKTools/HVite.c	/^void DoRecognition(void)$/;"	f
DoRecord	HTKTools/HSLab.c	/^void DoRecord(short *data)$/;"	f
DoRestore	HTKTools/HSLab.c	/^void DoRestore(void)$/;"	f
DoSHORT	HTKLib/HWave.c	/^               DoSHORT  = 8,     \/* SHORTEN decompression needed *\/$/;"	e	enum:__anon99	file:
DoSPACK	HTKLib/HWave.c	/^               DoSPACK  = 4,     \/* SHORT PACK decompression needed *\/$/;"	e	enum:__anon99	file:
DoSTEREO	HTKLib/HWave.c	/^               DoSTEREO = 128     \/* Convert stereo to mono*\/ $/;"	e	enum:__anon99	file:
DoSave	HTKTools/HSLab.c	/^void DoSave(void)$/;"	f
DoScrollLeft	HTKTools/HSLab.c	/^void DoScrollLeft(void)$/;"	f
DoScrollRight	HTKTools/HSLab.c	/^void DoScrollRight(void)$/;"	f
DoSelectLabel	HTKTools/HSLab.c	/^Boolean DoSelectLabel(void)$/;"	f
DoSpecial	HTKTools/HSLab.c	/^void DoSpecial(void)$/;"	f
DoTCtxt	HTKTools/HLEd.c	/^int DoTCtxt(LabList *ll,int nArgs,LabId *args)$/;"	f
DoTraceBack	HTKTools/HInit.c	/^void DoTraceBack(int segLen, IntVec states, int thisState)$/;"	f
DoUnMark	HTKTools/HSLab.c	/^void DoUnMark(int markA, int markB)$/;"	f
DoZoomIn	HTKTools/HSLab.c	/^Boolean DoZoomIn(void)$/;"	f
DoZoomOut	HTKTools/HSLab.c	/^Boolean DoZoomOut(void)$/;"	f
DoesMatch	HTKTools/HParse.c	/^static int DoesMatch(LabId s, LabId snet)$/;"	f	file:
DoingFourthAcc	HTKLib/HFBLat.c	/^static Boolean DoingFourthAcc=FALSE;    \/* Indicate currently it is doing MPE with MMI prior *\/$/;"	v	file:
DoubleComplex	HTKLib/esignal.h	/^typedef struct {double	real, imag;}	DoubleComplex;$/;"	t	typeref:struct:__anon46
DownMix	HTKTools/HHEd.c	/^void DownMix(char *hname, StreamElem *ste, int maxMix, Boolean inPlace)$/;"	f
DownMixSingle	HTKTools/HHEd.c	/^void DownMixSingle(StreamElem *ste,Boolean inPlace)$/;"	f
DownTree	HTKTools/HHEd.c	/^void DownTree(Node *node,Node **array) $/;"	f
Drag	HTKTools/HSLab.c	/^void Drag(void)$/;"	f
DrawRectWin	HTKTools/HSLab.c	/^void DrawRectWin(RectWin *win)$/;"	f
DumpAccs	HTKLib/HTrain.c	/^FILE * DumpAccs(HMMSet *hset, char *fname, UPDSet uFlags, int n){ return DumpAccsParallel(hset,fname,n,uFlags,0); }$/;"	f
DumpAccsParallel	HTKLib/HTrain.c	/^FILE * DumpAccsParallel(HMMSet *hset, char *fname, int n, UPDSet uFlags, int index)$/;"	f
DumpClusterMap	HTKLib/HTrain.c	/^static void DumpClusterMap(void)$/;"	f	file:
DumpGrid	HTKTools/HResults.c	/^void DumpGrid(void)$/;"	f
DumpMarker	HTKLib/HTrain.c	/^static void DumpMarker(FILE *f)$/;"	f	file:
DumpMuAcc	HTKLib/HTrain.c	/^static void DumpMuAcc(FILE *f, MuAcc *ma)$/;"	f	file:
DumpPName	HTKLib/HTrain.c	/^static void DumpPName(FILE *f, char *pname)$/;"	f	file:
DumpPhoneTable	HLMTools/HLMCopy.c	/^static void DumpPhoneTable(Vocab *src, Vocab *tgt) {$/;"	f	file:
DumpTrAcc	HTKLib/HTrain.c	/^static void DumpTrAcc(FILE *f, TrAcc *ta)$/;"	f	file:
DumpVaAcc	HTKLib/HTrain.c	/^static void DumpVaAcc(FILE *f, VaAcc *va, CovKind ck)$/;"	f	file:
DumpWtAcc	HTKLib/HTrain.c	/^static void DumpWtAcc(FILE *f, WtAcc *wa)$/;"	f	file:
DupHMM	HTKTools/HHEd.c	/^HMMDef *DupHMM(HMMDef *src)$/;"	f
DupMacro	HTKTools/HHEd.c	/^void DupMacro(MLink ml,LabId labid)$/;"	f
DupMixPDF	HTKTools/HHEd.c	/^MixPDF *DupMixPDF(MixPDF *s, Boolean frc)$/;"	f
DupSMatrix	HTKTools/HHEd.c	/^SMatrix DupSMatrix(SMatrix m)$/;"	f
DupSTriMat	HTKTools/HHEd.c	/^STriMat DupSTriMat(STriMat m)$/;"	f
DupSVector	HTKTools/HHEd.c	/^SVector DupSVector(SVector v)$/;"	f
DupState	HTKTools/HHEd.c	/^StateInfo *DupState(StateInfo *si, Boolean frc)$/;"	f
DupStream	HTKTools/HHEd.c	/^MixtureElem *DupStream(StreamElem *ste)$/;"	f
DuplicateCommand	HTKTools/HHEd.c	/^void DuplicateCommand(void)$/;"	f
DuplicatePron	HTKTools/HDMan.c	/^void DuplicatePron(WordBuf *wb, int i)$/;"	f
DurKind	HTKLib/HModel.h	/^typedef enum _DurKind DurKind;$/;"	t	typeref:enum:_DurKind
DurKind2Str	HTKLib/HModel.c	/^char *DurKind2Str(DurKind dkind, char *buf)$/;"	f
Durbin	HTKLib/HSigP.c	/^static float Durbin(Vector k, Vector thisA, Vector r, float E, int order)$/;"	f	file:
E	HTKTools/HMMIRest.c	/^static float E = 2.0;               \/* constant used in BW updatel *\/$/;"	v	file:
EArcId	HTKLib/HNet.h	/^typedef struct larc_e *EArcId;$/;"	t	typeref:struct:larc_e
EDOP_DELETE	HTKTools/HLEd.c	/^   REPLACE, CHANGE, FIND,   MERGE,  EDOP_DELETE, DEFCON, TRIST,  $/;"	e	enum:__anon141	file:
EDR1	HTKLib/esignal.h	103;"	d
EDR2	HTKLib/esignal.h	104;"	d
EMINARG	HLMLib/LModel.h	63;"	d
EMINARG	HTKLib/HLM.h	49;"	d
ENDHMM	HTKLib/HModel.c	/^   BEGINHMM, USEMAC, ENDHMM, NUMMIXES, $/;"	e	enum:__anon40	file:
ENORMALISE	HTKLib/HParm.c	/^   ENORMALISE,    \/* Normalise log energy *\/$/;"	e	enum:__anon77	file:
ENTERKEY	HTKLib/HGraf.h	/^               ENTERKEY, DELKEY, ESCKEY};$/;"	e	enum:_KeyType
EOFSYM	HTKLib/HModel.c	/^   MACRO, EOFSYM, NULLSYM   \/* Special Syms - not literals *\/$/;"	e	enum:__anon40	file:
EOFSYM	HTKTools/HParse.c	/^             EOFSYM};$/;"	e	enum:_Symbol	file:
EQSYM	HTKTools/HParse.c	/^             LTRISYM,RTRISYM,EQSYM, SEMISYM, BARSYM, PERCENTSYM, $/;"	e	enum:_Symbol	file:
ESCALE	HTKLib/HParm.c	/^   ESCALE,        \/* Log energy scale factor *\/$/;"	e	enum:__anon77	file:
ESCAPE	HTKTools/HParse.c	1297;"	d	file:
ESCAPE_CHAR	HTKLib/HShell.h	82;"	d
ESCKEY	HTKLib/HGraf.h	/^               ENTERKEY, DELKEY, ESCKEY};$/;"	e	enum:_KeyType
ESIG	HTKLib/HWave.h	/^	ESIG,              \/* used for both wave and parm files *\/$/;"	e	enum:__anon36
ESIGFieldList	HTKLib/HWave.c	/^static FieldList  ESIGFieldList;  $/;"	v	file:
ESPS	HTKLib/HWave.h	/^        ESPS,              \/* used for both wave and parm files *\/$/;"	e	enum:__anon36
ESPS Label Files	HTKBook/labels.tex	/^and are understood by all \\HTK\\ tools.$/;"	u
EXACTCORR_PRUNE	HTKLib/HExactMPE.c	/^static float EXACTCORR_PRUNE= -8.5 \/*0.0002*\/; $/;"	v	file:
EXITSTATUS	HTKTools/HMMIRest.c	31;"	d	file:
EXP10MINARG	HLMLib/LModel.h	51;"	d
EXP10MINARG	HTKLib/HLM-RNNLM.c	38;"	d	file:
EXPAND	HTKTools/HLEd.c	/^   SBDEF,   EXPAND, IFILL,  SORT,   WBDEF,  VBDEF,  LCTXT,  $/;"	e	enum:__anon141	file:
EXP_A	HTKLib/HRNLM.c	65;"	d	file:
EXP_C	HTKLib/HRNLM.c	66;"	d	file:
EdError	HTKLib/HUtil.c	/^static void EdError(char *s)$/;"	f	file:
EdOp	HTKTools/HDMan.c	/^              NOCMD} EdOp;$/;"	t	typeref:enum:__anon158	file:
EdOp	HTKTools/HLEd.c	/^} EdOp;$/;"	t	typeref:enum:__anon141	file:
EditAndMerge	HTKTools/HDMan.c	/^void EditAndMerge(void)$/;"	f
EditCmd	HTKTools/HDMan.c	/^}EditCmd;$/;"	t	typeref:struct:__anon159	file:
EditCmd	HTKTools/HLEd.c	/^}EditCmd;$/;"	t	typeref:struct:__anon142	file:
EditFile	HTKTools/HLEd.c	/^void EditFile(char *labfn)$/;"	f
EditTransMat	HTKTools/HHEd.c	/^void EditTransMat(Boolean adding)$/;"	f
EditWordBuf	HTKTools/HDMan.c	/^void EditWordBuf(DBuffer *db)$/;"	f
EdrRead	HTKLib/esig_edr.c	/^EdrRead(void    *data,$/;"	f	file:
EdrReadArray	HTKLib/esig_edr.c	/^EdrReadArray(Array      *data,$/;"	f	file:
EdrReadBool	HTKLib/esig_edr.c	/^EdrReadBool(Bool    *data,$/;"	f	file:
EdrReadChar	HTKLib/esig_edr.c	/^EdrReadChar(char *data,$/;"	f	file:
EdrReadDouble	HTKLib/esig_edr.c	/^EdrReadDouble(double    *data,$/;"	f	file:
EdrReadDoubleComplex	HTKLib/esig_edr.c	/^EdrReadDoubleComplex(DoubleComplex  *data,$/;"	f	file:
EdrReadFloat	HTKLib/esig_edr.c	/^EdrReadFloat(float  *data,$/;"	f	file:
EdrReadFloatComplex	HTKLib/esig_edr.c	/^EdrReadFloatComplex(FloatComplex    *data,$/;"	f	file:
EdrReadLong	HTKLib/esig_edr.c	/^EdrReadLong(long    *data,$/;"	f	file:
EdrReadLongComplex	HTKLib/esig_edr.c	/^EdrReadLongComplex(LongComplex  *data,$/;"	f	file:
EdrReadSchar	HTKLib/esig_edr.c	/^EdrReadSchar(Schar  *data,$/;"	f	file:
EdrReadScharComplex	HTKLib/esig_edr.c	/^EdrReadScharComplex(ScharComplex    *data,$/;"	f	file:
EdrReadShort	HTKLib/esig_edr.c	/^EdrReadShort(short  *data,$/;"	f	file:
EdrReadShortComplex	HTKLib/esig_edr.c	/^EdrReadShortComplex(ShortComplex    *data,$/;"	f	file:
EdrReadUchar	HTKLib/esig_edr.c	/^EdrReadUchar(Uchar  *data,$/;"	f	file:
EdrReadUlong	HTKLib/esig_edr.c	/^EdrReadUlong(Ulong *data,$/;"	f	file:
EdrReadUshort	HTKLib/esig_edr.c	/^EdrReadUshort(Ushort *data,$/;"	f	file:
EdrReadWchar	HTKLib/esig_edr.c	/^EdrReadWchar(Wchar      *data,$/;"	f	file:
EdrRecordSize	HTKLib/esig_edr.c	/^EdrRecordSize(FieldList list,$/;"	f
EdrTypeSize	HTKLib/esig_edr.c	/^EdrTypeSize(int type,           \/* numeric data-type code *\/$/;"	f
EdrWrite	HTKLib/esig_edr.c	/^EdrWrite(void   *data,$/;"	f	file:
EdrWriteArray	HTKLib/esig_edr.c	/^EdrWriteArray(Array     *data,$/;"	f	file:
EdrWriteBool	HTKLib/esig_edr.c	/^EdrWriteBool(Bool   *data,$/;"	f	file:
EdrWriteChar	HTKLib/esig_edr.c	/^EdrWriteChar(char *data,$/;"	f	file:
EdrWriteDouble	HTKLib/esig_edr.c	/^EdrWriteDouble(double   *data,$/;"	f	file:
EdrWriteDoubleComplex	HTKLib/esig_edr.c	/^EdrWriteDoubleComplex(DoubleComplex *data,$/;"	f	file:
EdrWriteFloat	HTKLib/esig_edr.c	/^EdrWriteFloat(float     *data,$/;"	f	file:
EdrWriteFloatComplex	HTKLib/esig_edr.c	/^EdrWriteFloatComplex(FloatComplex   *data,$/;"	f	file:
EdrWriteLong	HTKLib/esig_edr.c	/^EdrWriteLong(long       *data,$/;"	f	file:
EdrWriteLongComplex	HTKLib/esig_edr.c	/^EdrWriteLongComplex(LongComplex *data,$/;"	f	file:
EdrWriteSchar	HTKLib/esig_edr.c	/^EdrWriteSchar(Schar     *data,$/;"	f	file:
EdrWriteScharComplex	HTKLib/esig_edr.c	/^EdrWriteScharComplex(ScharComplex   *data,$/;"	f	file:
EdrWriteShort	HTKLib/esig_edr.c	/^EdrWriteShort(short     *data,$/;"	f	file:
EdrWriteShortComplex	HTKLib/esig_edr.c	/^EdrWriteShortComplex(ShortComplex   *data,$/;"	f	file:
EdrWriteUchar	HTKLib/esig_edr.c	/^EdrWriteUchar(Uchar     *data,$/;"	f	file:
EdrWriteUlong	HTKLib/esig_edr.c	/^EdrWriteUlong(Ulong *data,$/;"	f	file:
EdrWriteUshort	HTKLib/esig_edr.c	/^EdrWriteUshort(Ushort *data,$/;"	f	file:
EdrWriteWchar	HTKLib/esig_edr.c	/^EdrWriteWchar(Wchar     *data,$/;"	f	file:
Embedded Model Reestimation  htool  HERest	HTKBook/train.tex	/^\\]$/;"	u
EmptyBuffer	HTKLib/HParm.c	/^ParmBuf EmptyBuffer(MemHeap *x, int size, Observation o, BufferInfo info)$/;"	f
EmptyMixPDF	HTKLib/HModel.c	/^static MixPDF *EmptyMixPDF(HMMSet *hset, int vSize, int s)$/;"	f	file:
EndHMMScan	HTKLib/HUtil.c	/^void EndHMMScan(HMMScanState *hss)$/;"	f
EndOfWord	HTKLib/HArc.h	216;"	d
EndOfWord	HTKLib/HExactMPE.c	94;"	d	file:
EndOfWord	HTKLib/HFBLat.c	134;"	d	file:
EqualKind	HTKLib/HParm.c	/^static Boolean EqualKind(ParmKind a, ParmKind b)$/;"	f	file:
Equiv	HLMTools/LPlex.c	/^typedef struct _Equiv Equiv;          \/* list of equivalent labels *\/$/;"	t	typeref:struct:_Equiv	file:
Equiv	HTKTools/HResults.c	/^typedef struct _Equiv Equiv;          \/* list of equivalent labels *\/$/;"	t	typeref:struct:_Equiv	file:
EquivHMM	HTKTools/HHEd.c	/^Boolean EquivHMM(HMMDef *a, HMMDef *b)$/;"	f
EquivMix	HTKTools/HHEd.c	/^Boolean EquivMix(MixPDF *a, MixPDF *b)$/;"	f
EquivState	HTKTools/HHEd.c	/^Boolean EquivState(StateInfo *a, StateInfo *b, int S)$/;"	f
EquivStream	HTKTools/HHEd.c	/^Boolean EquivStream(StreamElem *a, StreamElem *b)$/;"	f
EstCMLLRXForm	HTKLib/HAdapt.c	/^static void EstCMLLRXForm(AccStruct *accs, LinXForm *xf)$/;"	f	file:
EstMLLRCovXForm	HTKLib/HAdapt.c	/^static void EstMLLRCovXForm(AccStruct *accs, LinXForm *xf)$/;"	f	file:
EstMLLRDiagCovXForm	HTKLib/HAdapt.c	/^static void EstMLLRDiagCovXForm(AccStruct *accs, LinXForm *xf, LinXForm *dxf)$/;"	f	file:
EstMLLRMeanXForm	HTKLib/HAdapt.c	/^static void EstMLLRMeanXForm(AccStruct *accs, LinXForm *xf)$/;"	f	file:
EstSemiTXForm	HTKLib/HAdapt.c	/^static void EstSemiTXForm(AdaptXForm *xform, AccStruct *accs, LinXForm *xf, IntVec classes)$/;"	f	file:
EstXForm	HTKLib/HAdapt.c	/^static void EstXForm(AccStruct *accs, AdaptXForm *xform, IntVec classes)$/;"	f	file:
EstimateModel	HTKTools/HInit.c	/^void EstimateModel(void)$/;"	f
ExactCorrectness	HTKLib/HFBLat.c	/^static Boolean ExactCorrectness=FALSE; \/*IMPORTANT*\/         \/* Do 'exact' version of MPE\/MWE, not using approximation.  This is slightly better for$/;"	v	file:
Exists	HLMTools/LAdapt.c	/^Boolean Exists(char *fn)$/;"	f
Exists	HLMTools/LBuild.c	/^Boolean Exists(char *fn)$/;"	f
Exists	HLMTools/LGPrep.c	/^Boolean Exists(char *fn)$/;"	f
Exit	HTKLib/HShell.c	/^void Exit(int exitcode)$/;"	f
ExpandLattice	HTKLib/HNet.c	/^static void ExpandLattice(Lattice *newlat, int nNodes, int nArcs)$/;"	f	file:
ExpandMultiLevelLattice	HTKLib/HNet.c	/^Lattice *ExpandMultiLevelLattice(MemHeap *heap, Lattice *lat, Vocab *voc)$/;"	f
ExpandOp	HTKTools/HLEd.c	/^int ExpandOp(LabList *ll)$/;"	f
ExpandSubNetDefs	HTKTools/HParse.c	/^static void ExpandSubNetDefs(Link *chain)$/;"	f	file:
ExpandWordModel	HTKTools/HParse.c	/^void ExpandWordModel(Vocab *voc, Link p, Link history)$/;"	f
ExpandWordNet	HTKLib/HNet.c	/^Network *ExpandWordNet(MemHeap *heap,Lattice *lat,Vocab *voc,HMMSet *hset)$/;"	f
ExpandedLatticeSize	HTKLib/HNet.c	/^static void ExpandedLatticeSize(Lattice *lat, int *nNodes,int *nArcs)$/;"	f	file:
ExplainObservation	HTKLib/HParm.c	/^void ExplainObservation(Observation *o, int itemsPerLine)$/;"	f
ExportNMV	HTKTools/HCompV.c	/^void ExportNMV(SpkrAccListItem *sal, char *OutDirName, char *tgtPKStr) $/;"	f
ExtFile	HTKLib/HShell.c	/^}ExtFile;$/;"	t	typeref:struct:__anon140	file:
ExtendAux	HTKLib/HLabel.c	/^static void ExtendAux(MemHeap *x, LabList *ll, int n)$/;"	f	file:
ExternTypeSize	HTKLib/esignal.c	/^ExternTypeSize(int type,$/;"	f
ExtnOf	HTKLib/HShell.c	/^char * ExtnOf(char *fn, char *s)$/;"	f
ExtractObservation	HTKLib/HParm.c	/^static void ExtractObservation(float *fp, Observation *o)$/;"	f	file:
FA	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon168	file:
FAIL	HTKLib/HShell.h	/^typedef enum {FAIL=-1, SUCCESS=0} ReturnStatus;$/;"	e	enum:__anon81
FALSE	HTKLib/HShell.h	/^typedef enum {FALSE=0, TRUE=1} Boolean;$/;"	e	enum:__anon82
FALSE	HTKLib/HShell.h	89;"	d
FALSE	HTKLib/esignal.h	49;"	d
FALSE_dup	HTKLib/HParm.h	/^   FALSE_dup=FALSE, \/*  0 *\/$/;"	e	enum:__anon119
FAST_EXP	HTKLib/HRNLM.c	67;"	d	file:
FAVec	HTKTools/HResults.c	/^typedef int FAVec[10];$/;"	t	file:
FBANK	HTKLib/HParm.h	/^      FBANK,                           \/* Log Filter Bank *\/$/;"	e	enum:_BaseParmKind
FBFile	HTKLib/HFB.c	/^Boolean FBFile(FBInfo *fbInfo, UttInfo *utt, char * datafn)$/;"	f
FBInfo	HTKLib/HFB.h	/^} FBInfo;$/;"	t	typeref:struct:__anon139
FBLatAddLattice	HTKLib/HFBLat.c	/^void FBLatAddLattice (FBLatInfo *fbInfo, Lattice *lat){  \/* add this lattice, $/;"	f
FBLatClearUp	HTKLib/HFBLat.c	/^void FBLatClearUp(FBLatInfo *fbInfo){  $/;"	f
FBLatFirstPass	HTKLib/HFBLat.c	/^void FBLatFirstPass(FBLatInfo *_fbInfo, FileFormat dff, char * datafn, char *datafn2, Lattice *MPECorrLat){$/;"	f
FBLatInfo	HTKLib/HFBLat.h	/^} FBLatInfo;$/;"	t	typeref:struct:__anon54
FBLatSecondPass	HTKLib/HFBLat.c	/^void FBLatSecondPass(FBLatInfo *_fbInfo, int num_index, int den_index){$/;"	f
FBLatSetAccScale	HTKLib/HFBLat.c	/^void FBLatSetAccScale(FBLatInfo *fbInfo, float AccScale){ \/*scale accumulators by this amount. *\/$/;"	f
FBank2ASpec	HTKLib/HSigP.c	/^void FBank2ASpec (Vector fbank, Vector as, Vector eql, float compressFact, $/;"	f
FBank2C0	HTKLib/HSigP.c	/^float FBank2C0(Vector fbank)$/;"	f
FBank2MFCC	HTKLib/HSigP.c	/^void FBank2MFCC(Vector fbank, Vector c, int n)$/;"	f
FBank2MelSpec	HTKLib/HSigP.c	/^void FBank2MelSpec(Vector fbank)$/;"	f
FBankInfo	HTKLib/HSigP.h	/^}FBankInfo;$/;"	t	typeref:struct:__anon129
FBinfo	HTKLib/HLat.h	/^} FBinfo;$/;"	t	typeref:struct:FBlnodeInfo
FBlnodeInfo	HTKLib/HLat.h	/^typedef struct FBlnodeInfo {$/;"	s
FC	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon168	file:
FClose	HTKLib/HShell.c	/^void FClose(FILE *f, Boolean isPipe)$/;"	f
FFT	HTKLib/HSigP.c	/^void FFT(Vector s, int invert)$/;"	f
FFTbased	HTKLib/HParm.c	/^typedef enum { FFTbased, LPCbased, VQbased} CodeStyle;$/;"	e	enum:__anon75	file:
FIELD_ORDER	HTKLib/esignal.h	98;"	d
FIND	HTKTools/HLEd.c	/^   REPLACE, CHANGE, FIND,   MERGE,  EDOP_DELETE, DEFCON, TRIST,  $/;"	e	enum:__anon141	file:
FINITE	HTKTools/HMMIRest.c	64;"	d	file:
FIXLABSTR	HTKTools/HSLab.c	1338;"	d	file:
FItem	HLMTools/LGList.c	/^} FItem;$/;"	t	typeref:struct:fitem	file:
FLEntry	HLMLib/LModel.h	/^} FLEntry;$/;"	t	typeref:struct:_FLEntry
FLOAT	HTKLib/esignal.h	67;"	d
FLOATARG	HTKLib/HShell.h	/^typedef enum {SWITCHARG, STRINGARG, INTARG, FLOATARG, NOARG} ArgKind;$/;"	e	enum:__anon88
FLOAT_COMPLEX	HTKLib/esignal.h	76;"	d
FLOAT_MAX	HTKTools/HHEd.c	59;"	d	file:
FLTCX_FMT	HTKLib/esig_asc.c	79;"	d	file:
FLTCX_W	HTKLib/esig_asc.c	78;"	d	file:
FLTCX_WFMT	HTKLib/esig_asc.c	80;"	d	file:
FLT_FIELD	HTKLib/HNet.c	/^typedef enum {UNK_FIELD, STR_FIELD, INT_FIELD, FLT_FIELD} LatFieldType;$/;"	e	enum:__anon55	file:
FLT_FMT	HTKLib/esig_asc.c	47;"	d	file:
FLT_TO_LOG10	HLMLib/LModel.h	57;"	d
FLT_TO_LOG10	HTKLib/HLM-RNNLM.c	43;"	d	file:
FLT_W	HTKLib/esig_asc.c	46;"	d	file:
FLT_WFMT	HTKLib/esig_asc.c	48;"	d	file:
FONT1	HTKLib/HGraf.c	153;"	d	file:
FONT2	HTKLib/HGraf.c	154;"	d	file:
FONT3	HTKLib/HGraf.c	155;"	d	file:
FONTNAME	HTKLib/HGraf_WIN32.c	/^static char *FONTNAME = "Helvetica";$/;"	v	file:
FONTS_AVAILABLE	HTKLib/HGraf.c	135;"	d	file:
FOURTHWINDOW	HTKLib/HParm.c	/^   FOURTHWINDOW,$/;"	e	enum:__anon77	file:
FOpen	HTKLib/HShell.c	/^FILE *FOpen(char *fname, IOFilter filter, Boolean *isPipe)$/;"	f
FOutP	HTKLib/HModel.c	/^static LogFloat FOutP(Vector x, int vecSize, MixPDF *mp)$/;"	f	file:
FRAMEDUR	HTKLib/HArc.c	/^static float FRAMEDUR = 0; $/;"	v	file:
FRNNLMAcceptWord	HTKLib/HRNLM.c	/^float FRNNLMAcceptWord(RNNLM* rnnlm, int lastword, int curword)$/;"	f
FRead	HLMLib/LModel.c	/^static size_t FRead(void *ptr, size_t size, size_t nitems, Source *src)$/;"	f	file:
FULLC	HTKLib/HMath.h	/^   FULLC,         \/* inverse full rank covariance *\/$/;"	e	enum:__anon43
FULLCOV	HTKLib/HModel.c	/^   DIAGCOV,  FULLCOV, XFORMCOV,$/;"	e	enum:__anon40	file:
FUNCW	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon158	file:
FV	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon168	file:
FVec2Spectrum	HTKLib/HSigP.c	/^void FVec2Spectrum (float fzero, Vector f, Vector s)$/;"	f
FWORD	HTKLib/HMem.c	41;"	d	file:
FZERO	HTKLib/HMath.c	683;"	d	file:
FZeroMean	HTKLib/HSigP.c	/^void FZeroMean(float *data, int vSize, int n, int step)$/;"	f
FieldArrayLength	HTKLib/esignal.c	/^FieldArrayLength(FieldSpec **fields)$/;"	f	file:
FieldItem	HLMTools/LGPrep.c	/^} FieldItem;$/;"	t	typeref:union:__anon25	file:
FieldLength	HTKLib/esignal.c	/^FieldLength(FieldSpec *field)$/;"	f
FieldList	HTKLib/esignal.h	/^typedef FieldSpec	    **FieldList;$/;"	t
FieldListLength	HTKLib/esignal.c	/^FieldListLength(FieldList list)$/;"	f
FieldOp	HLMTools/LGPrep.c	/^} FieldOp;$/;"	t	typeref:enum:__anon24	file:
FieldOrder	HTKLib/esignal.c	/^FieldOrder(FieldList list)$/;"	f
FieldSpec	HTKLib/esignal.h	/^struct FieldSpec {$/;"	s
FieldSpec	HTKLib/esignal.h	/^typedef struct FieldSpec    FieldSpec;$/;"	t	typeref:struct:FieldSpec
FieldVec	HLMTools/LGPrep.c	/^} FieldVec;$/;"	t	typeref:struct:__anon27	file:
FileBytes	HTKLib/HWave.c	/^static long FileBytes(FILE *f, Wave w)$/;"	f	file:
FileExists	HTKTools/HSLab.c	/^Boolean FileExists(char *fn, char *fmode)$/;"	f
FileFormat	HTKLib/HWave.h	/^} FileFormat;$/;"	t	typeref:enum:__anon36
FileTypeEnum	HTKLib/HRNLM.h	/^enum FileTypeEnum {TEXT, BINARY, COMPRESSED};$/;"	g
FillBufFromChannel	HTKLib/HParm.c	/^static void FillBufFromChannel(ParmBuf pbuf,int minRows)$/;"	f	file:
FillBufferFromAudio	HTKLib/HAudio.c	/^static void FillBufferFromAudio(AudioIn a,int min)$/;"	f	file:
FillInputs	HTKTools/HDMan.c	/^Boolean FillInputs(Boolean *valid)$/;"	f
FillPredJM	HTKTools/HParse.c	/^static void FillPredJM(int numElements, SplitName *trilist)$/;"	f	file:
FillSuccJM	HTKTools/HParse.c	/^static void FillSuccJM(int numElements, SplitName *trilist)$/;"	f	file:
FilterLevel	HTKLib/HLabel.c	/^static void FilterLevel(Transcription *t, int lev)$/;"	f	file:
FilterNGram	HLMLib/LPCalc.c	/^Boolean FilterNGram(NGInputSet *inSet, UInt *gram, float *count, int nSize)$/;"	f
FilterSet	HTKLib/HShell.c	/^static Boolean FilterSet(IOFilter filter, char *s)$/;"	f	file:
FindAcc	HTKTools/HLEd.c	/^} FindAcc;$/;"	t	typeref:struct:_FindAcc	file:
FindAddSubLNode	HTKLib/HLat.c	/^static SubLNode *FindAddSubLNode (MemHeap *heap, LNode *ln, LMState lmstate, LMState *lmstate_mix, int *nsln, LogFloat score, int ngramaprox)$/;"	f	file:
FindBaseModel	HTKTools/HHEd.c	/^HLink FindBaseModel(HMMSet *hset,LabId id,baseType type)$/;"	f
FindBestMixes	HTKTools/HInit.c	/^void FindBestMixes(int segNum, int segLen, IntVec states, IntVec *mixes)$/;"	f
FindBestSplit	HTKTools/HHEd.c	/^Node *FindBestSplit(Node *first, float threshold)$/;"	f
FindBestTerminal	HTKTools/HHEd.c	/^RegNode *FindBestTerminal(RegNode *t, float *score, int vSize, RegNode *best) $/;"	f
FindButton	HTKLib/HGraf.c	/^HButton *FindButton(HButton *btnlst, ButtonId key)$/;"	f
FindButton	HTKLib/HGraf.null.c	/^HButton *FindButton(HButton *btnlst, ButtonId key)$/;"	f
FindButton	HTKLib/HGraf_WIN32.c	/^HButton *FindButton(HButton *btnlst, ButtonId key)$/;"	f
FindCentres	HTKLib/HTrain.c	/^static void FindCentres(int a, int b)$/;"	f	file:
FindConfEntry	HTKLib/HShell.c	/^static ConfigEntry *FindConfEntry(char *user, char *name)$/;"	f	file:
FindConfParm	HTKLib/HShell.c	/^static int FindConfParm(ConfParam **list,int size,char *name,ConfKind kind)$/;"	f	file:
FindCovariance	HTKLib/HTrain.c	/^static void FindCovariance(int n)$/;"	f	file:
FindFE	HLMLib/LModel.c	/^FLEntry *FindFE(FLEntry *fptr, int lo, int hi, LM_Id key)$/;"	f
FindField	HTKLib/esignal.c	/^FindField(FieldList list,       \/* field list *\/$/;"	f
FindInHashTable	HTKLib/HRNLM.c	/^void* FindInHashTable(HashTable* t, char* key)$/;"	f
FindItemBlock	HTKLib/HTrain.c	/^static IBLink FindItemBlock(Sequence seq, int i, int *j)$/;"	f	file:
FindLContext	HTKLib/HNet.c	/^static int FindLContext(HMMSetCxtInfo *hci,PronHolder *p,int pos,int lc)$/;"	f	file:
FindLatEnd	HTKLib/HNet.c	/^NodeId FindLatEnd(Lattice *lat)$/;"	f
FindLatStart	HTKLib/HNet.c	/^NodeId FindLatStart(Lattice *lat)$/;"	f
FindLoopBegin	HTKTools/HParse.c	/^Link FindLoopBegin(Link *hd)$/;"	f
FindLoopEnd	HTKTools/HParse.c	/^Link FindLoopEnd(Link *tl)$/;"	f
FindMLFStr	HTKLib/HLabel.c	/^static Boolean FindMLFStr(char *s, char **st, char **en)$/;"	f	file:
FindMLFType	HTKLib/HLabel.c	/^static MLFDefType FindMLFType(char *s, char **en)$/;"	f	file:
FindMMF	HTKLib/HModel.c	/^static MILink FindMMF(HMMSet *hset, char *fname, Boolean ignorePath)$/;"	f	file:
FindMacroName	HTKLib/HModel.c	/^MLink FindMacroName(HMMSet *hset, char type, LabId id)$/;"	f
FindMacroStruct	HTKLib/HModel.c	/^MLink FindMacroStruct(HMMSet *hset, char type, Ptr structure)$/;"	f
FindModel	HTKLib/HNet.c	/^static HLink FindModel(HMMSetCxtInfo *hci,int lc,LabId name,int rc)$/;"	f	file:
FindNode	HTKLib/HModel.c	/^static RegNode *FindNode(RegNode *n, RegNode *r, int id)$/;"	f	file:
FindNodeTypes	HTKTools/HParse.c	/^void FindNodeTypes(HPNetwork *theNet)$/;"	f
FindOp	HTKTools/HLEd.c	/^void FindOp(LabList *ll,LabId *args)$/;"	f
FindProtoModel	HTKTools/HHEd.c	/^HLink FindProtoModel(LabId model)$/;"	f
FindRContext	HTKLib/HNet.c	/^static int FindRContext(HMMSetCxtInfo *hci,PronHolder *p,int pos,int rc)$/;"	f	file:
FindSE	HLMLib/LModel.c	/^SMEntry *FindSE(SMEntry *sptr, int lo, int hi, LM_Id key)$/;"	f
FindSE1	HLMLib/LModel.c	/^static SMEntry *FindSE1(SMEntry *sptr, int lo, int hi, LM_Id key, int *fcen)$/;"	f	file:
FindSEntry	HTKLib/HLM.c	/^static SEntry *FindSEntry (SEntry *se, lmId pronId, int l, int h)$/;"	f	file:
FindSpans	HTKLib/HParm.c	/^static void FindSpans(short span[12], ParmKind k, int size)$/;"	f	file:
FindStateOrder	HTKLib/HFB.c	/^void FindStateOrder(HLink hmm,IntVec so,int s,int *d)$/;"	f
FindVQNode	HTKLib/HVQ.c	/^static VQNode FindVQNode(VQNode *list, short nid)$/;"	f	file:
FindVQTable	HTKLib/HVQ.c	/^static VQTable FindVQTable(char * tabFN, short magic)$/;"	f	file:
FindWordNode	HTKLib/HNet.c	/^static NetNode *FindWordNode(MemHeap *heap,Pron pron,$/;"	f	file:
FirstComponent	HTKLib/esignal.c	/^FirstComponent(char *name)$/;"	f	file:
FixAllGConsts	HTKLib/HModel.c	/^void FixAllGConsts(HMMSet *hset)$/;"	f
FixBadLat	HTKLib/HLat.c	/^void FixBadLat (Lattice *lat)$/;"	f
FixDefunctMix	HTKTools/HHEd.c	/^void FixDefunctMix(char *hname,StreamElem *ste, int n)$/;"	f
FixDet	HTKLib/HAdapt.c	/^static void FixDet(LinXForm *xf)$/;"	f	file:
FixDiagGConst	HTKLib/HModel.c	/^void FixDiagGConst(MixPDF *mp)$/;"	f
FixFullGConst	HTKLib/HModel.c	/^void FixFullGConst(MixPDF *mp, LogFloat ldet)$/;"	f
FixGConsts	HTKLib/HModel.c	/^void FixGConsts(HLink hmm)$/;"	f
FixHMMForICrit	HTKTools/HMMIRest.c	/^static void FixHMMForICrit(){$/;"	f	file:
FixInvDiagGConst	HTKLib/HModel.c	/^void FixInvDiagGConst(MixPDF *mp)$/;"	f
FixLLTGConst	HTKLib/HModel.c	/^void FixLLTGConst(MixPDF *mp)$/;"	f
FixLabIdxs	HTKTools/HCopy.c	/^void FixLabIdxs(int nlabs)$/;"	f
FixLatTimes	HTKLib/HArc.c	/^void FixLatTimes(Lattice *lat){ \/*Makes it so that the sum of phone lengths equals the length of each word.*\/$/;"	f
FixOptions	HTKTools/HCopy.c	/^void FixOptions(void)$/;"	f
FixOrphanMacros	HTKLib/HModel.c	/^void FixOrphanMacros(HMMSet *hset)$/;"	f
FixPronProbs	HTKLib/HLat.c	/^void FixPronProbs (Lattice *lat, Vocab *voc)$/;"	f
FixSVD	HTKLib/HMath.c	/^static void FixSVD(DVector d, DMatrix U, DMatrix V)$/;"	f	file:
FixSemiTiedStats	HTKLib/HAdapt.c	/^static void FixSemiTiedStats(HMMSet *hset)$/;"	f	file:
FixTLoopEnds	HTKTools/HParse.c	/^static void FixTLoopEnds(int numElements, Link *hd, Link *tl, Link a, Link b)                 $/;"	f	file:
FixTiedGConsts	HTKLib/HModel.c	/^void FixTiedGConsts(HMMSet *hset)$/;"	f
FixTransForICrit	HTKTools/HMMIRest.c	/^static void FixTransForICrit(float Tau, Boolean THREEACCS){$/;"	f	file:
FixWeights	HTKTools/HHEd.c	/^void FixWeights(MixtureElem *me, HMMDef *owner, StreamElem *ste)$/;"	f
FixWeightsForICrit	HTKTools/HMMIRest.c	/^static void FixWeightsForICrit(float Tau, Boolean THREEACCS){$/;"	f	file:
FlatCluster	HTKLib/HTrain.c	/^ClusterSet *FlatCluster(MemHeap *x, Sequence vpool, int nc, $/;"	f
FloatComplex	HTKLib/esignal.h	/^typedef struct {float	real, imag;}	FloatComplex;$/;"	t	typeref:struct:__anon47
FloorAverageCommand	HTKTools/HHEd.c	/^void FloorAverageCommand(void)$/;"	f
FloorDProbs	HTKLib/HMap.c	/^static void FloorDProbs(ShortVec mixes, int M, float floor)$/;"	f	file:
FloorDProbs	HTKTools/HERest.c	/^void FloorDProbs(ShortVec mixes, int M, float floor)$/;"	f
FloorDProbs	HTKTools/HMMIRest.c	/^void FloorDProbs(ShortVec mixes, int M, float floor)$/;"	f
FloorDProbs	HTKTools/HRest.c	/^void FloorDProbs(ShortVec mixes, int M, float floor)$/;"	f
FloorDProbs	HTKTools/HSmooth.c	/^void FloorDProbs(ShortVec mixes, int M, float floor)$/;"	f
FloorMixes	HTKLib/HMap.c	/^static void FloorMixes(MixtureElem *mixes, int M, float floor)$/;"	f	file:
FloorMixes	HTKTools/HERest.c	/^void FloorMixes(HMMSet *hset, MixtureElem *mixes, int M, float floor)$/;"	f
FloorMixes	HTKTools/HMMIRest.c	/^void FloorMixes(MixtureElem *mixes, int M, float floor)$/;"	f
FloorMixes	HTKTools/HRest.c	/^void FloorMixes(MixtureElem *mixes, int M, float floor)$/;"	f
FloorMixtures	HTKLib/HMap.c	/^static void FloorMixtures(HSetKind hskind, StreamElem *ste, int M, float floor)$/;"	f	file:
FloorTMMixes	HTKLib/HMap.c	/^static void FloorTMMixes(Vector mixes, int M, float floor)$/;"	f	file:
FloorTMMixes	HTKTools/HERest.c	/^void FloorTMMixes(Vector mixes, int M, float floor)$/;"	f
FloorTMMixes	HTKTools/HMMIRest.c	/^void FloorTMMixes(Vector mixes, int M, float floor)$/;"	f
FloorTMMixes	HTKTools/HRest.c	/^void FloorTMMixes(Vector mixes, int M, float floor)$/;"	f
FloorTMMixes	HTKTools/HSmooth.c	/^void FloorTMMixes(Vector mixes, int M,float floor)$/;"	f
FloorVars	HTKTools/HERest.c	/^void FloorVars(HMMSet *hset1, int s){$/;"	f
FloorVars	HTKTools/HMMIRest.c	/^void FloorVars(HMMSet *hset1, int s){$/;"	f
FloorVectorCommand	HTKTools/HHEd.c	/^void FloorVectorCommand(void)$/;"	f
FltCKind	HTKLib/HShell.h	/^   FltCKind,            \/* float value *\/$/;"	e	enum:__anon85
FoFTab	HLMLib/LGBase.h	/^} FoFTab;$/;"	t	typeref:struct:__anon7
FontInfo	HTKLib/HGraf.c	/^static XFontStruct  *DefaultFont, *CurrentFont, *FontInfo[NO_OF_FONTS];$/;"	v	file:
FontNm	HTKLib/HGraf.c	/^static char *FontNm[NO_OF_FONTS] = {$/;"	v	file:
FontSize	HTKLib/HGraf.c	/^static int FontSize[NO_OF_FONTS] = {8, 9, 10, 12, 14, 15, 16, 19, 20, 24};$/;"	v	file:
ForceDiagC	HTKLib/HUtil.c	/^void ForceDiagC(HMMSet *hset)$/;"	f
ForcePKind	HTKLib/HParm.c	/^static ParmKind ForcePKind = ANON; \/* force to output a customized parm kind to make older versions$/;"	v	file:
FormChunk	HTKLib/HWave.c	/^} FormChunk;$/;"	t	typeref:struct:__anon104	file:
Format2Str	HTKLib/HWave.c	/^char *Format2Str(FileFormat format)$/;"	f
FormatTranscription	HTKLib/HRec.c	/^void FormatTranscription(Transcription *trans,HTime frameDur,$/;"	f
FramesInAudio	HTKLib/HAudio.c	/^int FramesInAudio(AudioIn a)$/;"	f
FramesInChannel	HTKLib/HParm.c	/^static int FramesInChannel(ParmBuf pbuf,int chType)$/;"	f	file:
FramesInParm	HTKLib/HParm.c	/^static int FramesInParm(ParmBuf pbuf)$/;"	f	file:
FramesInWave	HTKLib/HWave.c	/^int FramesInWave(Wave w)$/;"	f
FreeAxisNames	HTKLib/esignal.c	/^FreeAxisNames(char  **axis_names,$/;"	f
FreeClusterSet	HTKLib/HTrain.c	/^void FreeClusterSet(ClusterSet *cs)$/;"	f
FreeDMatrix	HTKLib/HMem.c	/^void FreeDMatrix(MemHeap *x, DMatrix m)$/;"	f
FreeDVector	HTKLib/HMem.c	/^void FreeDVector(MemHeap *x, DVector v)$/;"	f
FreeFieldList	HTKLib/esignal.c	/^FreeFieldList(FieldList list)$/;"	f
FreeFieldSpec	HTKLib/esignal.c	/^FreeFieldSpec(FieldSpec *spec)$/;"	f
FreeGrid	HTKTools/HResults.c	/^void FreeGrid(void)$/;"	f
FreeIntVec	HTKLib/HMem.c	/^void FreeIntVec(MemHeap *x,IntVec v)$/;"	f
FreeItems	HTKLib/HUtil.c	/^void FreeItems(ILink *list)$/;"	f
FreeJMat	HTKTools/HParse.c	/^static void FreeJMat(void)$/;"	f	file:
FreeLattice	HTKLib/HNet.c	/^void FreeLattice(Lattice *lat)$/;"	f
FreeLinkSet	HTKTools/HParse.c	/^static void FreeLinkSet(LinkSet *p)$/;"	f	file:
FreeMap	HTKLib/HNLM.c	/^void FreeMap(String2IndexMap *map, int num_word)$/;"	f
FreeMatrix	HTKLib/HMem.c	/^void FreeMatrix(MemHeap *x, Matrix m)$/;"	f
FreeMeanVariance	HTKLib/HRNLM.c	/^void FreeMeanVariance ()$/;"	f
FreeNLMwgt	HTKLib/HNLM.c	/^void FreeNLMwgt(NNLM *NNlm)$/;"	f
FreeNetwork	HTKTools/HParse.c	/^void FreeNetwork(HPNetwork *network)$/;"	f
FreeNode	HTKTools/HParse.c	/^static void FreeNode(Link p)$/;"	f	file:
FreePSetInfo	HTKLib/HRec.c	/^void FreePSetInfo(PSetInfo *psi)$/;"	f
FreeSMatrix	HTKLib/HMem.c	/^void FreeSMatrix(MemHeap *x, Matrix m)$/;"	f
FreeSTriMat	HTKLib/HMem.c	/^void FreeSTriMat(MemHeap *x,STriMat m)$/;"	f
FreeSVector	HTKLib/HMem.c	/^void FreeSVector(MemHeap *x, Vector v)$/;"	f
FreeSet	HTKLib/HUtil.c	/^void FreeSet(IntSet s)$/;"	f
FreeShortVec	HTKLib/HMem.c	/^void FreeShortVec(MemHeap *x,ShortVec v)$/;"	f
FreeSubNetDefs	HTKTools/HParse.c	/^static void FreeSubNetDefs(void)$/;"	f	file:
FreeTriMat	HTKLib/HMem.c	/^void FreeTriMat(MemHeap *x,TriMat m)$/;"	f
FreeVector	HTKLib/HMem.c	/^void FreeVector(MemHeap *x, Vector v)$/;"	f
FreezeOptions	HTKLib/HModel.c	/^static ReturnStatus FreezeOptions(HMMSet *hset)$/;"	f	file:
FullCovarCommand	HTKTools/HHEd.c	/^void FullCovarCommand(void)$/;"	f
FullInvGConst	HTKLib/HVQ.c	/^static float FullInvGConst(TriMat ic)$/;"	f	file:
FullestCluster	HTKLib/HTrain.c	/^static int FullestCluster(void)$/;"	f	file:
Function	HTKBook/HTKRef/HCopy.tex	/^\\mysect{HCopy}{HCopy}$/;"	u
Function	HTKBook/HTKRef/HHEd.tex	/^\\mysect{HHEd}{HHEd}$/;"	u
FunctionWordOp	HTKTools/HDMan.c	/^void FunctionWordOp(WordBuf *wb, LabId *args)$/;"	f
G	HTKLib/HAdapt.c	/^   DMatrix *G;$/;"	m	struct:__anon92	file:
GAMMAD	HTKLib/HModel.h	/^enum _DurKind {NULLD, POISSOND, GAMMAD, RELD, GEND};$/;"	e	enum:_DurKind
GB	HTKLib/HParm.c	/^Boolean GB(char *s){Boolean b; GetConfBool(cParm,nParm,s,&b); return b;}$/;"	f
GCONST	HTKLib/HModel.c	/^   MEAN, VARIANCE, INVCOVAR, XFORM, GCONST,$/;"	e	enum:__anon40	file:
GCOPY	HTKLib/HGraf.h	/^enum _XferMode {GCOPY, GOR, GXOR, GINVERT};$/;"	e	enum:_XferMode
GDUR	HTKLib/HModel.c	/^   NDUR, PDUR, GDUR, RELDUR, GENDUR,$/;"	e	enum:__anon40	file:
GDistance	HTKTools/HHEd.c	/^float GDistance(int s, StreamElem *s1, StreamElem *s2)$/;"	f
GEND	HTKLib/HModel.h	/^enum _DurKind {NULLD, POISSOND, GAMMAD, RELD, GEND};$/;"	e	enum:_DurKind
GENDUR	HTKLib/HModel.c	/^   NDUR, PDUR, GDUR, RELDUR, GENDUR,$/;"	e	enum:__anon40	file:
GF	HTKLib/HParm.c	/^double  GF(char *s){double d;  GetConfFlt(cParm,nParm,s,&d); return d;}$/;"	f
GFLink	HLMLib/LGBase.h	/^typedef struct gramfile *GFLink;$/;"	t	typeref:struct:gramfile
GHOST_ARC	HTKLib/HArc.h	126;"	d
GI	HTKLib/HParm.c	/^int     GI(char *s){int i;     GetConfInt(cParm,nParm,s,&i); return i;}$/;"	f
GINVERT	HTKLib/HGraf.h	/^enum _XferMode {GCOPY, GOR, GXOR, GINVERT};$/;"	e	enum:_XferMode
GLOBAL	HTKLib/esignal.h	89;"	d
GOR	HTKLib/HGraf.h	/^enum _XferMode {GCOPY, GOR, GXOR, GINVERT};$/;"	e	enum:_XferMode
GQ	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon168	file:
GRAM2TEXT	HLMLib/LPCalc.c	390;"	d	file:
GRAM_HDR	HLMLib/LUtil.h	/^   NO_HDR, WMAP_HDR, CMAP_HDR, GRAM_HDR, LFOF_HDR$/;"	e	enum:__anon22
GREY	HTKLib/HGraf.h	/^                LIGHT_GREY, GREY, DARK_GREY, BLACK};$/;"	e	enum:_HColour
GS	HTKLib/HParm.c	/^char *GS(char *s){static char b[MAXFNAMELEN]; GetConfStr(cParm,nParm,s,b); return b;}$/;"	f
GSIZE	HLMLib/LGBase.h	42;"	d
GSTP	HTKLib/HGraf.c	305;"	d	file:
GSTP	HTKLib/HGraf_WIN32.c	264;"	d	file:
GXOR	HTKLib/HGraf.h	/^enum _XferMode {GCOPY, GOR, GXOR, GINVERT};$/;"	e	enum:_XferMode
GatherStats	HTKTools/HLStats.c	/^void GatherStats(Transcription *t)$/;"	f
GaussDeviate	HTKLib/HMath.c	/^float GaussDeviate(float mu, float sigma)$/;"	f
GenAdaptXForm	HTKLib/HAdapt.c	/^Boolean GenAdaptXForm(HMMSet *hset, AdaptXForm* xform)$/;"	f
GenCepWin	HTKLib/HSigP.c	/^static void GenCepWin (int cepLiftering, int count)$/;"	f	file:
GenClassXForm	HTKLib/HAdapt.c	/^static Boolean GenClassXForm(BaseClass *bclass, AdaptXForm *xform)$/;"	f	file:
GenHamWindow	HTKLib/HSigP.c	/^static void GenHamWindow (int frameSize)$/;"	f	file:
GenInMap	HTKLib/HRNLM.c	/^static void GenInMap(char* fname, HashTable* t, int num_word)$/;"	f	file:
GenMap	HTKLib/HNLM.c	/^void GenMap(FILE *fp_map, String2IndexMap *map, int num_word)$/;"	f
GenOutMap	HTKLib/HRNLM.c	/^static void GenOutMap(char* fname, HashTable* t, int num_word, struct vocab_word *vocab)$/;"	f	file:
GenSent	HTKTools/HSGen.c	/^int GenSent(int snum)$/;"	f
GenSentences	HTKTools/HSGen.c	/^void  GenSentences(char * latfn, char * dicfn)$/;"	f
GenXForm	HTKLib/HAdapt.c	/^void GenXForm(RegNode *node, AdaptXForm *xform, IntVec classes)$/;"	f
General Principles of MLFs	HTKBook/labels.tex	/^\\mysect{Master Label Files}{mlfs}$/;"	u
GenerateDict	HTKTools/HParse.c	/^void GenerateDict(HPNetwork *theNet,Vocab *voc) $/;"	f
GenerateLattice	HTKTools/HParse.c	/^static Lattice* GenerateLattice(HPNetwork *theNet, Vocab *voc)$/;"	f	file:
GenerateModel	HLMLib/LPCalc.c	/^BackOffLM *GenerateModel(MemHeap *heap, BuildInfo *bi)$/;"	f
GetAEntry	HTKTools/HLStats.c	/^AEntry *GetAEntry(int in[ASIZE],Boolean create)$/;"	f
GetAIFFHeaderInfo	HTKLib/HWave.c	/^static long GetAIFFHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetAIStatus	HTKLib/HAudio.c	/^AudioInStatus GetAIStatus(AudioIn a)$/;"	f
GetAInfo	HTKLib/HAdapt.c	/^static AInfo *GetAInfo(MixPDF *mp)$/;"	f	file:
GetALIENHeaderInfo	HTKLib/HWave.c	/^static long GetALIENHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetAdaptKind	HTKLib/HAdapt.c	/^static AdaptKind GetAdaptKind(AdaptXForm *xform)$/;"	f	file:
GetAdaptXForm	HTKLib/HModel.c	/^static AdaptXForm* GetAdaptXForm(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetAlpha	HTKLib/HAdapt.c	/^static double GetAlpha(DMatrix invgmat,DVector kmat,double occ, DVector cofact)$/;"	f	file:
GetAlpha	HTKLib/HUtil.c	/^static char *GetAlpha(char *s)$/;"	f	file:
GetAlphaLike	HTKLib/HAdapt.c	/^static double GetAlphaLike(double a, double b, double c, double alpha)$/;"	f	file:
GetAudio	HTKLib/HAudio.c	/^void GetAudio(AudioIn a, int nFrames, float *buf)$/;"	f
GetAuxCase	HTKLib/HLabel.c	/^LLink GetAuxCase(LabList *ll, LabId id, int n, int i)$/;"	f
GetAuxLabN	HTKLib/HLabel.c	/^LLink GetAuxLabN(LabList *ll, int n, int i)$/;"	f
GetBaseClass	HTKLib/HAdapt.c	/^static BaseClass* GetBaseClass(HMMSet *hset,AdaptXForm *xform)$/;"	f	file:
GetBaseClass	HTKLib/HModel.c	/^static BaseClass* GetBaseClass(HMMSet *hset,Source *src, Token *tok)$/;"	f	file:
GetBestCorrectness	HTKLib/HExactMPE.c	/^Boolean GetBestCorrectness \/*step correctness by 1 phone.*\/$/;"	f
GetBias	HTKLib/HModel.c	/^static SVector GetBias(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetBlockSize	HTKLib/HAdapt.c	/^static IntVec GetBlockSize(AdaptXForm *xform, int class)$/;"	f	file:
GetBufferInfo	HTKLib/HParm.c	/^void GetBufferInfo(ParmBuf pbuf, BufferInfo *info)$/;"	f
GetCRCCFrame	HTKLib/HParm.c	/^static Boolean GetCRCCFrame(ParmBuf pbuf,void *data,int n,int s,Boolean bSwap)$/;"	f	file:
GetCase	HTKLib/HLabel.c	/^LLink GetCase(LabList *ll, LabId id, int n)$/;"	f
GetCh	HTKLib/HShell.c	/^int GetCh(Source *src)$/;"	f
GetChkedFlt	HTKLib/HShell.c	/^float GetChkedFlt(float min, float max, char * swtname)$/;"	f
GetChkedInt	HTKLib/HShell.c	/^int GetChkedInt(int min, int max, char * swtname)$/;"	f
GetChkedLong	HTKLib/HShell.c	/^long GetChkedLong(long min, long max, char * swtname)$/;"	f
GetClassEntry	HLMLib/LCMap.c	/^ClassEntry *GetClassEntry(ClassMap *c, int clndx)$/;"	f
GetClassMembers	HLMLib/LCMap.c	/^void GetClassMembers(ClassMap *c, int clndx, int *words)$/;"	f
GetConfBool	HTKLib/HShell.c	/^Boolean GetConfBool(ConfParam **list,int size,char *name, Boolean *b)$/;"	f
GetConfFlt	HTKLib/HShell.c	/^Boolean GetConfFlt(ConfParam **list,int size,char *name, double *fval)$/;"	f
GetConfInt	HTKLib/HShell.c	/^Boolean GetConfInt(ConfParam **list,int size,char *name, int *ival)$/;"	f
GetConfStr	HTKLib/HShell.c	/^Boolean GetConfStr(ConfParam **list,int size,char *name,char *str)$/;"	f
GetConfig	HTKLib/HShell.c	/^int GetConfig(char *user, Boolean incGlob, ConfParam **list, int max)$/;"	f
GetContext	HTKTools/HLEd.c	/^LabId *GetContext(LabId name)$/;"	f
GetContextList	HTKTools/HDMan.c	/^LabId *GetContextList(LabId id, DBuffer *db)$/;"	f
GetCovar	HTKLib/HModel.c	/^static STriMat GetCovar(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetCurrentVol	HTKLib/HAudio.c	/^float GetCurrentVol(AudioIn a)$/;"	f
GetDiscreteWeights	HTKLib/HModel.c	/^ReturnStatus GetDiscreteWeights(Source *src, Token *tok, int M, ShortVec dpdf)$/;"	f
GetDumpFile	HTKLib/HTrain.c	/^static FILE * GetDumpFile(char *name, int n)$/;"	f	file:
GetDuration	HTKLib/HModel.c	/^static SVector GetDuration(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetEQLab	HLMTools/LPlex.c	/^static LabId GetEQLab(LabId id)$/;"	f	file:
GetESIGHeaderInfo	HTKLib/HWave.c	/^static long GetESIGHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetElem	HTKLib/HMem.c	/^static void *GetElem(BlockP p, size_t elemSize, HeapType type)$/;"	f	file:
GetFOM	HTKTools/HResults.c	/^float GetFOM(int idx)$/;"	f
GetField	HTKLib/esignal.c	/^GetField(FieldList  list,       \/* field list *\/$/;"	f	file:
GetFieldOrdering	HTKLib/esignal.c	/^GetFieldOrdering(FieldList  list,$/;"	f
GetFieldValue	HTKLib/HNet.c	/^static LatFieldType GetFieldValue(char *buf, Source *src, int buflen)$/;"	f	file:
GetFileNameExt	HTKLib/HShell.c	/^Boolean GetFileNameExt(char *logfn, char *actfn, long *st, long *en)$/;"	f
GetFinalError	HTKLib/HFBLat.c	/^float GetFinalError(float curr_total, float curr_corr, Boolean hyp_is_sil){  \/* re the "CALCASERROR" option, other version of approx MPE. *\/$/;"	f
GetFindAccumulator	HTKTools/HLEd.c	/^int *GetFindAccumulator(LabId *pat)$/;"	f
GetFloat	HTKLib/HLM.c	/^static float GetFloat(Boolean bin)$/;"	f	file:
GetFltArg	HTKLib/HShell.c	/^float GetFltArg(void)$/;"	f
GetFltField	HTKLib/HNet.c	/^static double GetFltField(char ntype,char del,char *vbuf,Source *src)$/;"	f	file:
GetFrameFromChannel	HTKLib/HParm.c	/^static int GetFrameFromChannel(ParmBuf pbuf,int chType,void *vp)$/;"	f	file:
GetHCIContext	HTKLib/HNet.c	/^int GetHCIContext(HMMSetCxtInfo *hci,LabId labid)$/;"	f
GetHCIModel	HTKLib/HNet.c	/^HLink GetHCIModel(HMMSetCxtInfo *hci,int lc,LabId name,int rc)$/;"	f
GetHMMDef	HTKLib/HModel.c	/^static ReturnStatus GetHMMDef(HMMSet *hset, Source *src, Token *tok,$/;"	f	file:
GetHMMSetCxtInfo	HTKLib/HNet.c	/^HMMSetCxtInfo *GetHMMSetCxtInfo(HMMSet *hset, Boolean frcCxtInd)$/;"	f
GetHTKHeaderInfo	HTKLib/HWave.c	/^static long GetHTKHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetHashCounts	HTKLib/HModel.c	/^static void GetHashCounts(MLink * mtab,int size, int *min, int *max,$/;"	f	file:
GetHeaderStr	HLMLib/LUtil.c	/^static void GetHeaderStr(char *s, char *buf)$/;"	f	file:
GetHiddenAc	HTKLib/HRNLM.c	/^void GetHiddenAc (Layer *self, Vector v)$/;"	f
GetHiddenSize	HTKLib/HRNLM.c	/^int GetHiddenSize (Layer *self)$/;"	f
GetHitRate	HTKTools/HResults.c	/^float GetHitRate(int idx, int FAperHour)$/;"	f
GetHook	HTKLib/HMem.c	/^Ptr GetHook(Ptr m)$/;"	f
GetInLine	HLMLib/LModel.c	/^static char *GetInLine(Source *src,char *buf)$/;"	f	file:
GetInLine	HTKLib/HLM.c	/^static char *GetInLine(char *buf)$/;"	f	file:
GetInputObs	HTKLib/HFB.c	/^void GetInputObs( UttInfo *utt, int t, HSetKind hsKind )$/;"	f
GetInputXForm	HTKLib/HModel.c	/^InputXForm* GetInputXForm(HMMSet *hset, Source *src, Token *tok)$/;"	f
GetInsetGram	HLMLib/LGBase.c	/^static void GetInsetGram(NGInputSet *inset, NGram ng, float *wt)$/;"	f	file:
GetInt	HTKLib/HLM.c	/^static int GetInt(void)$/;"	f	file:
GetInt	HTKLib/HUtil.c	/^static int GetInt(int lo, int hi)$/;"	f	file:
GetIntArg	HTKLib/HShell.c	/^int GetIntArg(void)$/;"	f
GetIntEnvVar	HTKLib/HShell.c	/^Boolean GetIntEnvVar(char *envVar, int *value)$/;"	f
GetIntField	HTKLib/HNet.c	/^static int GetIntField(char ntype,char del,char *vbuf,Source *src)$/;"	f	file:
GetIntpltLMProb	HTKLib/HLM.c	/^float GetIntpltLMProb(LModel *lm, LabId prid[NSIZE], LabId wdid, LabId succwdid)$/;"	f
GetItem	HTKLib/HTrain.c	/^Ptr GetItem(Sequence seq, int i)$/;"	f
GetKey	HTKLib/HUtil.c	/^static Keyword GetKey(void)$/;"	f	file:
GetLMHdrInt	HLMLib/LUtil.c	/^Boolean GetLMHdrInt(char *name, int *value, LMFileHdr hdr)$/;"	f
GetLMHdrStr	HLMLib/LUtil.c	/^char * GetLMHdrStr(char *name, LMFileHdr hdr, Boolean ucase)$/;"	f
GetLMProb	HTKLib/HLM.c	/^float GetLMProb(LModel *lm, LabId prid[NSIZE], LabId wdid, LabId succwdid)$/;"	f
GetLabDistance	HTKTools/HSLab.c	/^LLink GetLabDistance(LabList *ll, long t, long st, long en, Boolean *isStart)$/;"	f
GetLabId	HTKLib/HLabel.c	/^LabId GetLabId(char *name, Boolean insert)$/;"	f
GetLabN	HTKLib/HLabel.c	/^LLink GetLabN(LabList *ll, int n)$/;"	f
GetLabT	HTKTools/HSLab.c	/^LLink GetLabT(LabList *ll, long t)$/;"	f
GetLabelList	HTKLib/HLabel.c	/^LabList* GetLabelList(Transcription *t, int n)$/;"	f
GetLattice	HTKLib/HLat.c	/^Lattice *GetLattice (char *fn, char *path, char *ext,$/;"	f
GetLinXForm	HTKLib/HModel.c	/^static LinXForm* GetLinXForm(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetLine	HTKLib/esignal.c	/^GetLine(char    *buf,$/;"	f	file:
GetLong	HTKLib/esignal.c	/^GetLong(long    *val,$/;"	f	file:
GetLongArg	HTKLib/HShell.c	/^long GetLongArg(void)$/;"	f
GetLowestNegError	HTKLib/HFBLat.c	/^float GetLowestNegError(int tStart, int tEnd, int tCurr, float curr_corr, float curr_total,  CorrectArcList **correctArc, int iphone, int *compute_count, Boolean hyp_is_sil){$/;"	f
GetMEIndex	HLMLib/LWMap.c	/^int GetMEIndex(WordMap *wm, int ndx)$/;"	f
GetMInfo	HTKLib/HAdapt.c	/^static MInfo *GetMInfo(MixPDF *mp)$/;"	f	file:
GetMLFFile	HTKLib/HLabel.c	/^FILE *GetMLFFile(int fidx)$/;"	f
GetMLFTable	HTKLib/HLabel.c	/^MLFEntry *GetMLFTable(void)$/;"	f
GetMLLRDiagCov	HTKLib/HAdapt.c	/^AdaptXForm *GetMLLRDiagCov(AdaptXForm *xform)$/;"	f
GetMLPLMProb	HTKLib/HLM.c	/^float GetMLPLMProb(LModel *lm, LabId prid[NSIZE], LabId wdid)$/;"	f
GetMMIAccMix	HTKTools/HMMIRest.c	/^static void GetMMIAccMix(int stream, MixPDF *mp)$/;"	f	file:
GetMacroHook	HTKLib/HUtil.c	/^Ptr GetMacroHook(MLink ml)$/;"	f
GetMacroUse	HTKLib/HUtil.c	/^int GetMacroUse(MLink ml)$/;"	f
GetMean	HTKLib/HModel.c	/^static SVector GetMean(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetMean	HTKLib/HRNLM.c	/^float GetMean (int i)$/;"	f
GetMixPDF	HTKLib/HModel.c	/^static MixPDF *GetMixPDF(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetMixPDFInfo	HTKLib/HModel.c	/^static void GetMixPDFInfo(HMMSet *hset, HMMDef *hmm, MixtureElem *tme, int *state, int *stream, int *comp)$/;"	f	file:
GetMixture	HTKLib/HModel.c	/^static ReturnStatus GetMixture(HMMSet *hset,Source *src,Token *tok,int M,MixtureElem *spdf)$/;"	f	file:
GetNEntry	HTKLib/HLM.c	/^NEntry *GetNEntry(NGramLM *nglm,lmId ndx[NSIZE],Boolean create)$/;"	f
GetNEntry2	HTKLib/HLM.c	/^NEntry *GetNEntry2(NGramLM *nglm,lmId ndx[NSIZE],Boolean create, int ngsize)$/;"	f
GetNEntry2_RNNLM	HTKLib/HLM.c	/^NEntry *GetNEntry2_RNNLM(NGramLM *nglm,lmId ndx[NSIZE], lmId fndx[NSIZE], Boolean use_prob_table, Boolean create, int ngsize, Vector v, Vector fv)$/;"	f
GetNEntry2_RNNLM_HVDist	HTKLib/HLM.c	/^NEntry *GetNEntry2_RNNLM_HVDist(NGramLM *nglm,lmId ndx[NSIZE],Boolean create, int ngsize, Vector v, Vector fv)$/;"	f
GetNEntry2_RNNLM_Lmstate	HTKLib/HLM.c	/^NEntry *GetNEntry2_RNNLM_Lmstate(NGramLM *nglm,lmId ndx[NSIZE],Boolean create, int ngsize, Vector v, Vector fv)$/;"	f
GetNEntry2_RNNLM_ProbCache	HTKLib/HLM.c	/^NEntry *GetNEntry2_RNNLM_ProbCache(NGramLM *nglm,lmId ndx[NSIZE],Boolean create, int ngsize, Vector v, Vector fv)$/;"	f
GetNGramAddress	HLMLib/LModel.c	/^void *GetNGramAddress(BackOffLM *lm, NameId *words, int nSize)$/;"	f
GetNGramProb	HLMLib/LModel.c	/^float GetNGramProb(BackOffLM *lm, NameId *words, int nSize)$/;"	f
GetNGramProbVecSE	HLMLib/LModel.c	/^float *GetNGramProbVecSE(BackOffLM *lm, int *nId, int nSize, FLEntry *parent)$/;"	f
GetNGramProbs	HLMLib/LModel.c	/^void GetNGramProbs(BackOffLM *lm, UInt *nId, int nSize, SMEntry *seBuf, int seBufSize)$/;"	f
GetNISTHeaderInfo	HTKLib/HWave.c	/^static long GetNISTHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetNISTIVal	HTKLib/HWave.c	/^static int GetNISTIVal(FILE *f)$/;"	f	file:
GetNISTSVal	HTKLib/HWave.c	/^static void GetNISTSVal(FILE *f, char *s)$/;"	f	file:
GetNISTToken	HTKLib/HWave.c	/^static char * GetNISTToken(FILE *f,char *buf)$/;"	f	file:
GetNOHEADHeaderInfo	HTKLib/HWave.c	/^static long GetNOHEADHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetNameId	HLMLib/LUtil.c	/^NameId GetNameId(HashTab *htab, char *name, Boolean insert)$/;"	f
GetNextArg	HTKLib/HShell.c	/^static char * GetNextArg(Boolean step)$/;"	f	file:
GetNextFieldName	HTKLib/HNet.c	/^static char *GetNextFieldName(char *buf, char *del, Source *src)$/;"	f	file:
GetNextNGram	HLMLib/LGBase.c	/^Boolean GetNextNGram(NGInputSet *inset, NGram ng, float *count, int N)$/;"	f
GetNoContextPhone	HTKLib/HFBLat.c	/^int GetNoContextPhone(LabId phone, int *nStates_quinphone\/*actually,number of HMMs per phone*\/, int *state_quinphone, HArc *a, int *frame_end){ $/;"	f
GetNode	HTKLib/HVQ.c	/^static VQNode GetNode(Source *src, CovKind ck, short width)$/;"	f	file:
GetNode	HTKTools/HHEd.c	/^static Node *GetNode(Node *node,int n)$/;"	f	file:
GetNonSpace	HTKLib/esig_asc.c	/^GetNonSpace(FILE *file)$/;"	f	file:
GetNumPhones	HTKLib/HExactMPE.c	/^int GetNumPhones(LArc *larc){ \/*returns num phones in a word...*\/$/;"	f
GetOGIHeaderInfo	HTKLib/HWave.c	/^static long GetOGIHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetObsCache	HTKLib/HAdapt.c	/^static ObsCache *GetObsCache(MixPDF *mp)$/;"	f	file:
GetOption	HTKLib/HModel.c	/^static ReturnStatus GetOption(HMMSet *hset, Source *src, Token *tok, int *nState)$/;"	f	file:
GetOptions	HTKLib/HModel.c	/^static ReturnStatus GetOptions(HMMSet *hset, Source *src, Token *tok, int *nState)$/;"	f	file:
GetPAAccCache	HTKLib/HAdapt.c	/^static AccCache *GetPAAccCache(MixPDF *mp)$/;"	f	file:
GetPAInfo	HTKLib/HAdapt.c	/^static AInfo *GetPAInfo(MixPDF *mp)$/;"	f	file:
GetPAObsCache	HTKLib/HAdapt.c	/^static ObsCache *GetPAObsCache(MixPDF *mp)$/;"	f	file:
GetParm	HTKLib/HParm.c	/^static int GetParm(ParmBuf pbuf,int nFrame,void *data)$/;"	f	file:
GetPart	HTKTools/HLEd.c	/^LabId GetPart(LabId id, int n)$/;"	f
GetProb	HLMTools/LPlex.c	/^static double GetProb(LabId *wlab, int nSize)$/;"	f	file:
GetRNNLMHiddenVector	HTKLib/HRNLM.c	/^void GetRNNLMHiddenVector(RNNLM* lm, Vector v)$/;"	f
GetRNNLMHiddenVectorSize	HTKLib/HRNLM.c	/^int GetRNNLMHiddenVectorSize(RNNLM* lm)$/;"	f
GetRNNLMHiddenVector_v1_0	HTKLib/HRNLM.c	/^void GetRNNLMHiddenVector_v1_0 (RNNLM *lm, Vector v)$/;"	f
GetRNNLMHistory	HTKLib/HRNLM.c	/^void GetRNNLMHistory(RNNLM* lm, IntVec v)$/;"	f
GetRNNLMHistorySize	HTKLib/HRNLM.c	/^int GetRNNLMHistorySize(RNNLM* lm)     \/*  history is used in RNNLM for direct connection *\/$/;"	f
GetRNNLMOutputVector	HTKLib/HRNLM.c	/^void GetRNNLMOutputVector (RNNLM* lm, Vector v)$/;"	f
GetRNNLMProb	HTKLib/HLM-RNNLM.c	/^float GetRNNLMProb(LModel* lm , LabId prid[NSIZE], LabId wdid, LabId *succwordId)$/;"	f
GetRNode	HTKTools/HHEd.c	/^static RNode *GetRNode(RegNode *n) $/;"	f	file:
GetRawAudio	HTKLib/HAudio.c	/^void GetRawAudio(AudioIn a, int nSamples, short *buf)$/;"	f
GetRegAcc	HTKLib/HAdapt.c	/^static RegAcc *GetRegAcc(MixPDF *mp)$/;"	f	file:
GetRegTree	HTKLib/HAdapt.c	/^static RegTree* GetRegTree(HMMSet *hset, AdaptXForm *xform)$/;"	f	file:
GetRegTree	HTKLib/HModel.c	/^static RegTree *GetRegTree(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetRegionAB	HTKTools/HSLab.c	/^Boolean GetRegionAB(int *pa, int *pb)$/;"	f
GetReplayBuf	HTKLib/HAudio.c	/^int GetReplayBuf(AudioIn a, int nSamples, short *buf)$/;"	f
GetRowLike	HTKLib/HAdapt.c	/^static double GetRowLike(DMatrix gmat,DVector kmat, DVector cofact, double occ, DVector w)$/;"	f	file:
GetSCRIBEHeaderInfo	HTKLib/HWave.c	/^static long GetSCRIBEHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetSDES1HeaderInfo	HTKLib/HWave.c	/^static long GetSDES1HeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetSUNAU8HeaderInfo	HTKLib/HWave.c	/^static long GetSUNAU8HeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetSWeights	HTKLib/HModel.c	/^static SVector GetSWeights(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetSampleFromBuffer	HTKLib/HAudio.c	/^static short GetSampleFromBuffer(AudioIn a)$/;"	f	file:
GetScribeLab	HTKLib/HLabel.c	/^static ScribeLab GetScribeLab(Source *src)$/;"	f	file:
GetSegObs	HTKLib/HTrain.c	/^Observation GetSegObs(SegStore ss, int i, int j)$/;"	f
GetSemiTiedLike	HTKLib/HAdapt.c	/^static double GetSemiTiedLike(AccStruct *accs, LinXForm *xf)$/;"	f	file:
GetSemiTiedTotCov	HTKLib/HAdapt.c	/^static void GetSemiTiedTotCov(AdaptXForm *xform, IntVec classes, TriMat totCov, Vector totMean)$/;"	f	file:
GetShortPackBlock	HTKLib/HWave.c	/^static int GetShortPackBlock(char **inData, short **outData)$/;"	f	file:
GetSpeaker	HTKTools/HResults.c	/^Spkr *GetSpeaker(void)$/;"	f
GetSplitThresh	HTKLib/HAdapt.c	/^static float GetSplitThresh(AdaptXForm *xform)$/;"	f	file:
GetSrcString	HLMLib/LWMap.c	/^Boolean GetSrcString(Source *src, char *s, Boolean htkEsc)$/;"	f
GetStateInfo	HTKLib/HModel.c	/^static StateInfo *GetStateInfo(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetStrArg	HTKLib/HShell.c	/^char * GetStrArg(void)$/;"	f
GetStream	HTKLib/HModel.c	/^static ReturnStatus GetStream(HMMSet *hset, Source *src, Token *tok,$/;"	f	file:
GetString	HTKTools/HSLab.c	/^Boolean GetString(RectWin *win, char *str, short minlen, short maxlen)$/;"	f
GetStructure	HTKLib/HModel.c	/^static Ptr GetStructure(HMMSet *hset, Source *src, char type)$/;"	f	file:
GetSubLat	HTKLib/HNet.c	/^static Lattice *GetSubLat(LabId subLatId,Lattice *subLat)$/;"	f	file:
GetSwtArg	HTKLib/HShell.c	/^char * GetSwtArg(void)$/;"	f
GetTIMITHeaderInfo	HTKLib/HWave.c	/^static long GetTIMITHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetTiedMixtures	HTKLib/HModel.c	/^ReturnStatus GetTiedMixtures(HMMSet *hset, Source *src, Token *tok, $/;"	f
GetTiedWeights	HTKLib/HModel.c	/^ReturnStatus GetTiedWeights(Source *src, Token *tok, int M, Vector tpdf)$/;"	f
GetTimes	HTKLib/HFBLat.c	/^void GetTimes(LArc *larc, int i, int *start, int *end){ \/* get start & end times for a lattice arc.  Frame$/;"	f
GetToken	HTKLib/HModel.c	/^static ReturnStatus GetToken(Source *src, Token *tok)$/;"	f	file:
GetTrSym	HTKLib/HLabel.c	/^static void GetTrSym(Source *src, Boolean htk)$/;"	f	file:
GetTransMat	HTKLib/HModel.c	/^static SMatrix GetTransMat(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetTransform	HTKLib/HModel.c	/^static SMatrix GetTransform(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetTreeVector	HTKTools/HHEd.c	/^static void GetTreeVector(RegNode **nVec, RegNode *t) $/;"	f	file:
GetUse	HTKLib/HMem.c	/^int  GetUse(Ptr m)$/;"	f
GetVQ	HTKLib/HVQ.c	/^void GetVQ(VQTable vqTab, int numS, Vector *fv, short *vq)$/;"	f
GetVal	HTKLib/HVQ.c	/^static short GetVal(Source *src, short lo, short hi, char *item)$/;"	f	file:
GetVariance	HTKLib/HModel.c	/^static SVector GetVariance(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetVariance	HTKLib/HRNLM.c	/^float GetVariance(int i)$/;"	f
GetVecSizeClass	HTKLib/HAdapt.c	/^static int GetVecSizeClass(BaseClass *bclass, int class)$/;"	f	file:
GetWAVHeaderInfo	HTKLib/HWave.c	/^static long GetWAVHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetWave	HTKLib/HWave.c	/^void GetWave(Wave w, int nFrames, float *buf)$/;"	f
GetWaveDirect	HTKLib/HWave.c	/^short *GetWaveDirect(Wave w, long *nSamples)$/;"	f
GetWavePtrPos	HTKTools/HSLab.c	/^Boolean GetWavePtrPos(void)$/;"	f
GetWdBeginNum	HTKTools/HParse.c	/^int GetWdBeginNum(Link p)$/;"	f
GetWinKind	HTKTools/HSLab.c	/^WinKind GetWinKind(HEventRec hev)$/;"	f
GetWord	HTKLib/HDict.c	/^Word GetWord(Vocab *voc, LabId wordName, Boolean insert)$/;"	f
GetWordClassEntry	HLMLib/LCMap.c	/^ClassEntry *GetWordClassEntry(ClassMap *c, int wdndx)$/;"	f
GetXFormMacros	HTKLib/HModel.c	/^static ReturnStatus GetXFormMacros(HMMSet *hset, Source *src, Token *tok, int fidx)$/;"	f	file:
GetXFormSet	HTKLib/HModel.c	/^static XFormSet* GetXFormSet(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetXFormStream	HTKLib/HAdapt.c	/^static int GetXFormStream(AdaptXForm *xform, IntVec classes, IntVec streams)$/;"	f	file:
GiveDimMixD	HTKTools/HMMIRest.c	/^float GiveDimMixD(MixPDF *mp, int k, int priortype){$/;"	f
GiveMixD	HTKTools/HMMIRest.c	/^float GiveMixD(MixPDF *mp, int stream, int priortype){$/;"	f
Givens	HTKLib/HMath.c	/^static void Givens(double x, double y, double *c, double *s)$/;"	f	file:
GoNextHMM	HTKLib/HUtil.c	/^Boolean GoNextHMM(HMMScanState *hss)$/;"	f
GoNextMix	HTKLib/HUtil.c	/^Boolean GoNextMix(HMMScanState *hss, Boolean noSkip)$/;"	f
GoNextState	HTKLib/HUtil.c	/^Boolean GoNextState(HMMScanState *hss, Boolean noSkip)$/;"	f
GoNextStream	HTKLib/HUtil.c	/^Boolean GoNextStream(HMMScanState *hss, Boolean noSkip)$/;"	f
GramEntry	HTKTools/HBuild.c	/^}GramEntry;$/;"	t	typeref:struct:_GramEntry	file:
GramFile	HLMLib/LGBase.h	/^}GramFile;$/;"	t	typeref:struct:gramfile
GwGw	HLMTools/Cluster.c	/^static int         GwGw, gGw, Gwg, gg;      \/* Special-case class counts *\/$/;"	v	file:
Gwg	HLMTools/Cluster.c	/^static int         GwGw, gGw, Gwg, gg;      \/* Special-case class counts *\/$/;"	v	file:
HASACCS	HTKLib/HParm.h	61;"	d
HASCOMPX	HTKLib/HParm.h	62;"	d
HASCRCC	HTKLib/HParm.h	64;"	d
HASDELTA	HTKLib/HParm.h	60;"	d
HASENERGY	HTKLib/HParm.h	58;"	d
HASHSIZE	HTKLib/HLabel.c	135;"	d	file:
HASHTABLESIZE	HTKLib/HRNLM.c	51;"	d	file:
HASNULLE	HTKLib/HParm.h	59;"	d
HASTHIRD	HTKLib/HParm.h	67;"	d
HASVQ	HTKLib/HParm.h	66;"	d
HASZEROC	HTKLib/HParm.h	65;"	d
HASZEROM	HTKLib/HParm.h	63;"	d
HAS_BOWT	HLMLib/LModel.h	66;"	d
HAUDIO	HTKLib/HWave.h	/^        HAUDIO,            \/* Direct Audio Input *\/$/;"	e	enum:__anon36
HA_IN_LINE	HTKLib/HAudio.h	42;"	d
HA_IN_MIC	HTKLib/HAudio.h	41;"	d
HA_IN_NONE	HTKLib/HAudio.h	40;"	d
HA_OUT_LINE	HTKLib/HAudio.h	37;"	d
HA_OUT_NONE	HTKLib/HAudio.h	34;"	d
HA_OUT_PHONES	HTKLib/HAudio.h	36;"	d
HA_OUT_SPEAKER	HTKLib/HAudio.h	35;"	d
HArc	HTKLib/HArc.h	/^typedef struct _Arc HArc;$/;"	t	typeref:struct:_Arc
HButton	HTKLib/HGraf.h	/^} HButton;$/;"	t	typeref:struct:_HButton
HCI_CXT_BLOCKSIZE	HTKLib/HNet.c	1750;"	d	file:
HColour	HTKLib/HGraf.h	/^typedef enum _HColour HColour;  \/* implementations may map these onto grey *\/$/;"	t	typeref:enum:_HColour
HCopyArea	HTKLib/HGraf.c	/^void HCopyArea(int srcx, int srcy, int width, int height, int destx, int desty)$/;"	f
HCopyArea	HTKLib/HGraf.null.c	/^void HCopyArea(int srcx, int srcy, int width, int height, int destx, int desty)$/;"	f
HCopyArea	HTKLib/HGraf_WIN32.c	/^void HCopyArea(int srcx, int srcy, int width, int height, int destx, int desty)$/;"	f
HDrawArc	HTKLib/HGraf.c	/^void HDrawArc(int x0, int y0, int x1, int y1, int stAngle, int arcAngle)$/;"	f
HDrawArc	HTKLib/HGraf.null.c	/^void HDrawArc(int x0, int y0, int x1, int y1, int stAngle, int arcAngle)$/;"	f
HDrawArc	HTKLib/HGraf_WIN32.c	/^void HDrawArc(int x0, int y0, int x1, int y1, int stAngle, int arcAngle)$/;"	f
HDrawImage	HTKLib/HGraf.c	/^void HDrawImage(unsigned char *p, int x, int y, int width, int height)$/;"	f
HDrawImage	HTKLib/HGraf.null.c	/^void HDrawImage(unsigned char *p, int x, int y, int width, int height)$/;"	f
HDrawImage	HTKLib/HGraf_WIN32.c	/^void HDrawImage(unsigned char *p, int x, int y, int width, int height)$/;"	f
HDrawLine	HTKLib/HGraf.c	/^void HDrawLine(int x0, int y0, int x1, int y1)$/;"	f
HDrawLine	HTKLib/HGraf.null.c	/^void HDrawLine(int x0, int y0, int x1, int y1)$/;"	f
HDrawLine	HTKLib/HGraf_WIN32.c	/^void HDrawLine(int x0, int y0, int x1, int y1)$/;"	f
HDrawLines	HTKLib/HGraf.c	/^void HDrawLines(HPoint *points, int n)$/;"	f
HDrawLines	HTKLib/HGraf.null.c	/^void HDrawLines(HPoint *points, int n)$/;"	f
HDrawLines	HTKLib/HGraf_WIN32.c	/^void HDrawLines(HPoint *points, int n)$/;"	f
HDrawRectangle	HTKLib/HGraf.c	/^void HDrawRectangle(int x0, int y0, int x1, int y1)$/;"	f
HDrawRectangle	HTKLib/HGraf.null.c	/^void HDrawRectangle(int x0, int y0, int x1, int y1)$/;"	f
HDrawRectangle	HTKLib/HGraf_WIN32.c	/^void HDrawRectangle(int x0, int y0, int x1, int y1)$/;"	f
HDumpGraf	HTKLib/HGraf.c	/^void HDumpGraf(char *fname)$/;"	f
HDumpGraf	HTKLib/HGraf.null.c	/^void HDumpGraf(char *fname)$/;"	f
HDumpGraf	HTKLib/HGraf_WIN32.c	/^void HDumpGraf(char *fname)$/;"	f
HEIGHT	HTKTools/HSLab.c	79;"	d	file:
HEndSpoolGraf	HTKLib/HGraf_WIN32.c	/^void HEndSpoolGraf()$/;"	f
HError	HTKLib/HShell.c	/^void HError(int errcode, char *message, ...)$/;"	f
HEvent	HTKLib/HGraf.h	/^typedef enum _HEvent HEvent;$/;"	t	typeref:enum:_HEvent
HEventRec	HTKLib/HGraf.h	/^} HEventRec;$/;"	t	typeref:struct:__anon96
HEventsPending	HTKLib/HGraf.c	/^int HEventsPending(void)$/;"	f
HEventsPending	HTKLib/HGraf.null.c	/^int HEventsPending(void)$/;"	f
HEventsPending	HTKLib/HGraf_WIN32.c	/^int HEventsPending(void)$/;"	f
HFieldList	HTKLib/HWave.h	/^typedef struct FieldSpec **HFieldList;$/;"	t	typeref:struct:FieldSpec
HFillArc	HTKLib/HGraf.c	/^void HFillArc(int x0,int y0,int x1,int y1,int stAngle,int arcAngle)$/;"	f
HFillArc	HTKLib/HGraf.null.c	/^void HFillArc(int x0,int y0,int x1,int y1,int stAngle,int arcAngle)$/;"	f
HFillArc	HTKLib/HGraf_WIN32.c	/^void HFillArc(int x0,int y0,int x1,int y1,int stAngle,int arcAngle)$/;"	f
HFillPolygon	HTKLib/HGraf.c	/^void HFillPolygon(HPoint *points, int n)$/;"	f
HFillPolygon	HTKLib/HGraf.null.c	/^void HFillPolygon(HPoint *points, int n)$/;"	f
HFillPolygon	HTKLib/HGraf_WIN32.c	/^void HFillPolygon(HPoint *points, int n)$/;"	f
HFillRectangle	HTKLib/HGraf.c	/^void HFillRectangle(int x0, int y0, int x1, int y1)$/;"	f
HFillRectangle	HTKLib/HGraf.null.c	/^void HFillRectangle(int x0, int y0, int x1, int y1)$/;"	f
HFillRectangle	HTKLib/HGraf_WIN32.c	/^void HFillRectangle(int x0, int y0, int x1, int y1)$/;"	f
HFlush	HTKLib/HGraf.c	/^void HFlush(void)$/;"	f
HFlush	HTKLib/HGraf.null.c	/^void HFlush(void)$/;"	f
HFlush	HTKLib/HGraf_WIN32.c	/^void HFlush(void)$/;"	f
HGWinFunc	HTKLib/HGraf_WIN32.c	/^LRESULT CALLBACK HGWinFunc(HWND WindowHandle, unsigned int msg, WPARAM wParam, LPARAM lParam)$/;"	f
HGetEvent	HTKLib/HGraf.c	/^HEventRec HGetEvent(Boolean anyEvent, void (*action)(void))$/;"	f
HGetEvent	HTKLib/HGraf.null.c	/^HEventRec HGetEvent(Boolean anyEvent, void (*action)(void))$/;"	f
HGetEvent	HTKLib/HGraf_WIN32.c	/^HEventRec HGetEvent(Boolean anyEvent, void (*action)(void))$/;"	f
HGetKeyType	HTKLib/HGraf_WIN32.c	/^KeyType HGetKeyType(char c)$/;"	f
HIFREQ	HTKLib/HParm.c	/^   HIFREQ,        \/* Hi Fbank frequency *\/$/;"	e	enum:__anon77	file:
HK	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon168	file:
HKEYPRESS	HTKLib/HGraf.h	/^              HKEYPRESS,   \/* key pressed *\/$/;"	e	enum:_HEvent
HKEYRELEASE	HTKLib/HGraf.h	/^              HKEYRELEASE, \/* key released *\/$/;"	e	enum:_HEvent
HLAT_ACLIKE	HTKLib/HNet.h	81;"	d
HLAT_ALABS	HTKLib/HNet.h	77;"	d
HLAT_ALDUR	HTKLib/HNet.h	84;"	d
HLAT_ALIGN	HTKLib/HNet.h	83;"	d
HLAT_ALLIKE	HTKLib/HNet.h	85;"	d
HLAT_DEFAULT	HTKLib/HNet.h	94;"	d
HLAT_LBIN	HTKLib/HNet.h	78;"	d
HLAT_LMLIKE	HTKLib/HNet.h	82;"	d
HLAT_NOSORT	HTKLib/HNet.h	89;"	d
HLAT_NOSUBS	HTKLib/HNet.h	90;"	d
HLAT_PRLIKE	HTKLib/HNet.h	86;"	d
HLAT_PRON	HTKLib/HNet.h	80;"	d
HLAT_SHARC	HTKLib/HNet.h	92;"	d
HLAT_TAGS	HTKLib/HNet.h	87;"	d
HLAT_TIMES	HTKLib/HNet.h	79;"	d
HLIBS	HTKLib/Makefile	/^HLIBS = ${exec_prefix}\/lib\/HTKLib.a$/;"	m
HLink	HTKLib/HModel.h	/^typedef HMMDef * HLink;$/;"	t
HMError	HTKLib/HModel.c	/^static void HMError(Source *src, char *message)$/;"	f	file:
HMMDef	HTKLib/HModel.h	/^} HMMDef;$/;"	t	typeref:struct:__anon64
HMMDefFilter	HTKLib/HShell.h	/^   HMMDefFilter,    \/* HMM definition files input via HModel *\/$/;"	e	enum:__anon83
HMMDefOFilter	HTKLib/HShell.h	/^   HMMDefOFilter,   \/* HMM definition files output via HModel *\/$/;"	e	enum:__anon83
HMMListFilter	HTKLib/HShell.h	/^   HMMListFilter,   \/* HMM lists input via HModel *\/$/;"	e	enum:__anon83
HMMListOFilter	HTKLib/HShell.h	/^   HMMListOFilter,  \/* HMM lists output via HModel *\/$/;"	e	enum:__anon83
HMMPhysName	HTKLib/HUtil.c	/^char *HMMPhysName(HMMSet *hset,HLink hmm)$/;"	f
HMMSETID	HTKLib/HModel.c	/^   HMMSETID=119,$/;"	e	enum:__anon40	file:
HMMScanState	HTKLib/HUtil.h	/^}HMMScanState;$/;"	t	typeref:struct:__anon38
HMMSet	HTKLib/HModel.h	/^} HMMSet;$/;"	t	typeref:struct:_HMMSet
HMMSetCxtInfo	HTKLib/HNet.h	/^HMMSetCxtInfo;$/;"	t	typeref:struct:hmmsetcxtinfo
HMOUSEDOWN	HTKLib/HGraf.h	/^enum _HEvent {HMOUSEDOWN,  \/* (left) mouse button pressed *\/$/;"	e	enum:_HEvent
HMOUSEMOVE	HTKLib/HGraf.h	/^              HMOUSEMOVE,  \/* mouse has moved *\/$/;"	e	enum:_HEvent
HMOUSEUP	HTKLib/HGraf.h	/^              HMOUSEUP,    \/* (left) mouse button released *\/$/;"	e	enum:_HEvent
HMousePos	HTKLib/HGraf.c	/^Boolean HMousePos(int *x, int *y)$/;"	f
HMousePos	HTKLib/HGraf.null.c	/^Boolean HMousePos(int *x, int *y)$/;"	f
HMousePos	HTKLib/HGraf_WIN32.c	/^Boolean HMousePos(int *x, int *y)$/;"	f
HOR	HTKTools/HResults.c	/^enum _Direction{DIAG,VERT,HOR,NIL};$/;"	e	enum:_Direction	file:
HPNetwork	HTKTools/HParse.c	/^} HPNetwork;$/;"	t	typeref:struct:__anon155	file:
HParmSrcDef	HTKLib/HParm.h	/^typedef struct hparmsrcdef *HParmSrcDef;$/;"	t	typeref:struct:hparmsrcdef
HParmSrcDefRec	HTKLib/HParm.c	/^} HParmSrcDefRec;$/;"	t	typeref:struct:hparmsrcdef	file:
HPlotVector	HTKLib/HGraf.c	/^void HPlotVector(int x0, int y0, int x1, int y1, Vector v, int st, int en, float ymax, float ymin)$/;"	f
HPlotVector	HTKLib/HGraf.null.c	/^void HPlotVector(int x0, int y0, int x1, int y1, Vector v, int st, int en, float ymax, float ymin)$/;"	f
HPlotVector	HTKLib/HGraf_WIN32.c	/^void HPlotVector(int x0, int y0, int x1, int y1, Vector v, int st, int en, float ymax, float ymin)$/;"	f
HPoint	HTKLib/HGraf.h	/^} HPoint;$/;"	t	typeref:struct:__anon97
HPrintf	HTKLib/HGraf.c	/^void HPrintf(int x, int y, char *format, ...)$/;"	f
HPrintf	HTKLib/HGraf.null.c	/^void HPrintf(int x, int y, char *format, ...)$/;"	f
HPrintf	HTKLib/HGraf_WIN32.c	/^void HPrintf(int x, int y, char *format, ...)$/;"	f
HREDRAW	HTKLib/HGraf.h	/^              HREDRAW      \/* window damaged *\/$/;"	e	enum:_HEvent
HRError	HTKLib/HShell.c	/^void HRError(int errcode, char *message, ...)$/;"	f
HSLAB_INFO	HTKTools/HSLab.c	71;"	d	file:
HSLabCmd	HTKTools/HSLab.c	/^   HSLabCmd, HSLabRun$/;"	e	enum:__anon150	file:
HSLabRun	HTKTools/HSLab.c	/^   HSLabCmd, HSLabRun$/;"	e	enum:__anon150	file:
HSetColour	HTKLib/HGraf.c	/^void HSetColour(HColour c)$/;"	f
HSetColour	HTKLib/HGraf.null.c	/^void HSetColour(HColour c)$/;"	f
HSetColour	HTKLib/HGraf_WIN32.c	/^void HSetColour(HColour c)$/;"	f
HSetFontSize	HTKLib/HGraf.c	/^void HSetFontSize(int size)$/;"	f
HSetFontSize	HTKLib/HGraf.null.c	/^void HSetFontSize(int size)$/;"	f
HSetFontSize	HTKLib/HGraf_WIN32.c	/^void HSetFontSize(int size)$/;"	f
HSetGrey	HTKLib/HGraf.c	/^void HSetGrey(int g)$/;"	f
HSetGrey	HTKLib/HGraf.null.c	/^void HSetGrey(int g)$/;"	f
HSetGrey	HTKLib/HGraf_WIN32.c	/^void HSetGrey(int g)$/;"	f
HSetKind	HTKLib/HModel.h	/^typedef enum _HSetKind HSetKind;$/;"	t	typeref:enum:_HSetKind
HSetLineWidth	HTKLib/HGraf.c	/^void HSetLineWidth(int w)$/;"	f
HSetLineWidth	HTKLib/HGraf.null.c	/^void HSetLineWidth(int w)$/;"	f
HSetLineWidth	HTKLib/HGraf_WIN32.c	/^void HSetLineWidth(int w)$/;"	f
HSetXMode	HTKLib/HGraf.c	/^void HSetXMode(XferMode m)$/;"	f
HSetXMode	HTKLib/HGraf.null.c	/^void HSetXMode(XferMode m)$/;"	f
HSetXMode	HTKLib/HGraf_WIN32.c	/^void HSetXMode(XferMode m)$/;"	f
HSlabCmdType	HTKTools/HSLab.c	/^} HSlabCmdType;$/;"	t	typeref:enum:__anon150	file:
HSpoolGraf	HTKLib/HGraf.c	/^void HSpoolGraf(char *fname)$/;"	f
HSpoolGraf	HTKLib/HGraf.null.c	/^void HSpoolGraf(char *fname)$/;"	f
HSpoolGraf	HTKLib/HGraf_WIN32.c	/^void HSpoolGraf(char *fname)$/;"	f
HTK	HTKLib/HWave.h	/^        HTK,               \/* used for both wave and parm files *\/$/;"	e	enum:__anon36
HTK Label Files	HTKBook/labels.tex	/^setting of \\texttt{SOURCELABEL}\\index{labels!external formats}$/;"	u
HTK in Depth	HTKBook/htkbook-pdf.tex	/^\\include{exampsys}$/;"	p
HTK in Depth	HTKBook/htkbook.tex	/^\\include{exampsys}$/;"	p
HTKLIB	HTKTools/Makefile	/^HTKLIB = $(inc)\/HTKLib.a $/;"	m
HTKRef  Cluster	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/tools}$/;"	i
HTKRef  Cluster	HTKBook/htkbook.tex	/^\\include{HTKRef\/tools}$/;"	i
HTKRef  HBuild	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/Cluster}$/;"	i
HTKRef  HBuild	HTKBook/htkbook.tex	/^\\include{HTKRef\/Cluster}$/;"	i
HTKRef  HCompV	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HBuild}$/;"	i
HTKRef  HCompV	HTKBook/htkbook.tex	/^\\include{HTKRef\/HBuild}$/;"	i
HTKRef  HCopy	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HCompV}$/;"	i
HTKRef  HCopy	HTKBook/htkbook.tex	/^\\include{HTKRef\/HCompV}$/;"	i
HTKRef  HDMan	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HCopy}$/;"	i
HTKRef  HDMan	HTKBook/htkbook.tex	/^\\include{HTKRef\/HCopy}$/;"	i
HTKRef  HDecode	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HDMan}$/;"	i
HTKRef  HDecode	HTKBook/htkbook.tex	/^\\include{HTKRef\/HDMan}$/;"	i
HTKRef  HERest	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HDecode}$/;"	i
HTKRef  HERest	HTKBook/htkbook.tex	/^\\include{HTKRef\/HDecode}$/;"	i
HTKRef  HHEd	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HERest}$/;"	i
HTKRef  HHEd	HTKBook/htkbook.tex	/^\\include{HTKRef\/HERest}$/;"	i
HTKRef  HInit	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HHEd}$/;"	i
HTKRef  HInit	HTKBook/htkbook.tex	/^\\include{HTKRef\/HHEd}$/;"	i
HTKRef  HLEd	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HInit}$/;"	i
HTKRef  HLEd	HTKBook/htkbook.tex	/^\\include{HTKRef\/HInit}$/;"	i
HTKRef  HLMCopy	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HList}$/;"	i
HTKRef  HLMCopy	HTKBook/htkbook.tex	/^\\include{HTKRef\/HList}$/;"	i
HTKRef  HLRescore	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HLMCopy}$/;"	i
HTKRef  HLRescore	HTKBook/htkbook.tex	/^\\include{HTKRef\/HLMCopy}$/;"	i
HTKRef  HLStats	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HLRescore}$/;"	i
HTKRef  HLStats	HTKBook/htkbook.tex	/^\\include{HTKRef\/HLRescore}$/;"	i
HTKRef  HList	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HLEd}$/;"	i
HTKRef  HList	HTKBook/htkbook.tex	/^\\include{HTKRef\/HLEd}$/;"	i
HTKRef  HMMIRest	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HLStats}$/;"	i
HTKRef  HMMIRest	HTKBook/htkbook.tex	/^\\include{HTKRef\/HLStats}$/;"	i
HTKRef  HParse	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HMMIRest}$/;"	i
HTKRef  HParse	HTKBook/htkbook.tex	/^\\include{HTKRef\/HMMIRest}$/;"	i
HTKRef  HQuant	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HParse}$/;"	i
HTKRef  HQuant	HTKBook/htkbook.tex	/^\\include{HTKRef\/HParse}$/;"	i
HTKRef  HRest	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HQuant}$/;"	i
HTKRef  HRest	HTKBook/htkbook.tex	/^\\include{HTKRef\/HQuant}$/;"	i
HTKRef  HResults	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HRest}$/;"	i
HTKRef  HResults	HTKBook/htkbook.tex	/^\\include{HTKRef\/HRest}$/;"	i
HTKRef  HSGen	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HResults}$/;"	i
HTKRef  HSGen	HTKBook/htkbook.tex	/^\\include{HTKRef\/HResults}$/;"	i
HTKRef  HSLab	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HSGen}$/;"	i
HTKRef  HSLab	HTKBook/htkbook.tex	/^\\include{HTKRef\/HSGen}$/;"	i
HTKRef  HSmooth	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HSLab}$/;"	i
HTKRef  HSmooth	HTKBook/htkbook.tex	/^\\include{HTKRef\/HSLab}$/;"	i
HTKRef  HVite	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HSmooth}$/;"	i
HTKRef  HVite	HTKBook/htkbook.tex	/^\\include{HTKRef\/HSmooth}$/;"	i
HTKRef  LAdapt	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/HVite}$/;"	i
HTKRef  LAdapt	HTKBook/htkbook.tex	/^\\include{HTKRef\/HVite}$/;"	i
HTKRef  LBuild	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/LAdapt}$/;"	i
HTKRef  LBuild	HTKBook/htkbook.tex	/^\\include{HTKRef\/LAdapt}$/;"	i
HTKRef  LFoF	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/LBuild}$/;"	i
HTKRef  LFoF	HTKBook/htkbook.tex	/^\\include{HTKRef\/LBuild}$/;"	i
HTKRef  LGCopy	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/LFoF}$/;"	i
HTKRef  LGCopy	HTKBook/htkbook.tex	/^\\include{HTKRef\/LFoF}$/;"	i
HTKRef  LGList	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/LGCopy}$/;"	i
HTKRef  LGList	HTKBook/htkbook.tex	/^\\include{HTKRef\/LGCopy}$/;"	i
HTKRef  LGPrep	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/LGList}$/;"	i
HTKRef  LGPrep	HTKBook/htkbook.tex	/^\\include{HTKRef\/LGList}$/;"	i
HTKRef  LLink	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/LGPrep}$/;"	i
HTKRef  LLink	HTKBook/htkbook.tex	/^\\include{HTKRef\/LGPrep}$/;"	i
HTKRef  LMerge	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/LLink}$/;"	i
HTKRef  LMerge	HTKBook/htkbook.tex	/^\\include{HTKRef\/LLink}$/;"	i
HTKRef  LNewMap	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/LMerge}$/;"	i
HTKRef  LNewMap	HTKBook/htkbook.tex	/^\\include{HTKRef\/LMerge}$/;"	i
HTKRef  LNorm	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/LNewMap}$/;"	i
HTKRef  LNorm	HTKBook/htkbook.tex	/^\\include{HTKRef\/LNewMap}$/;"	i
HTKRef  LPlex	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/LNorm}$/;"	i
HTKRef  LPlex	HTKBook/htkbook.tex	/^\\include{HTKRef\/LNorm}$/;"	i
HTKRef  LSubset	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/LPlex}$/;"	i
HTKRef  LSubset	HTKBook/htkbook.tex	/^\\include{HTKRef\/LPlex}$/;"	i
HTKRef  tools	HTKBook/htkbook-pdf.tex	/^\\mychap{The HTK Tools}{toolref}$/;"	i
HTKRef  tools	HTKBook/htkbook.tex	/^\\mychap{The HTK Tools}{toolref}$/;"	i
HTKhdr	HTKLib/HWave.c	/^} HTKhdr;$/;"	t	typeref:struct:__anon107	file:
HTextHeight	HTKLib/HGraf.c	/^int HTextHeight(char *str)$/;"	f
HTextHeight	HTKLib/HGraf.null.c	/^int HTextHeight(char *str)$/;"	f
HTextHeight	HTKLib/HGraf_WIN32.c	/^int HTextHeight(char *str)$/;"	f
HTextWidth	HTKLib/HGraf.c	/^int HTextWidth(char *str)$/;"	f
HTextWidth	HTKLib/HGraf.null.c	/^int HTextWidth(char *str)$/;"	f
HTextWidth	HTKLib/HGraf_WIN32.c	/^int HTextWidth(char *str)$/;"	f
HTime	HTKLib/HShell.h	/^typedef double HTime;      \/* time in 100ns units *\/$/;"	t
H_EOF	HTKTools/HParse.c	1299;"	d	file:
Ham	HTKLib/HSigP.c	/^void Ham (Vector s)$/;"	f
HardAssign	HTKLib/HAdapt.c	/^Boolean HardAssign(AdaptXForm *xform)$/;"	f
HasAccs	HTKLib/HParm.c	/^Boolean HasAccs(ParmKind kind)  {return (kind & HASACCS) != 0;}$/;"	f
HasCompx	HTKLib/HParm.c	/^Boolean HasCompx(ParmKind kind) {return (kind & HASCOMPX) != 0;}$/;"	f
HasConfParm	HTKLib/HShell.c	/^Boolean HasConfParm(ConfParam **list, int size, char *name)$/;"	f
HasCrcc	HTKLib/HParm.c	/^Boolean HasCrcc(ParmKind kind)  {return (kind & HASCRCC) != 0;}$/;"	f
HasDelta	HTKLib/HParm.c	/^Boolean HasDelta(ParmKind kind) {return (kind & HASDELTA) != 0;}$/;"	f
HasDuplicate	HTKTools/HDMan.c	/^Boolean HasDuplicate(DBuffer *db, int pronNum)$/;"	f
HasEnergy	HTKLib/HParm.c	/^Boolean HasEnergy(ParmKind kind){return (kind & HASENERGY) != 0;}$/;"	f
HasMacros	HTKLib/HModel.c	/^Boolean HasMacros(HMMSet *hset, char * types)$/;"	f
HasNulle	HTKLib/HParm.c	/^Boolean HasNulle(ParmKind kind) {return (kind & HASNULLE) != 0;}$/;"	f
HasThird	HTKLib/HParm.c	/^Boolean HasThird(ParmKind kind) {return (kind & HASTHIRD) != 0;}$/;"	f
HasVQ	HTKLib/HParm.c	/^Boolean HasVQ(ParmKind kind)    {return (kind & HASVQ) != 0;}$/;"	f
HasZeroc	HTKLib/HParm.c	/^Boolean HasZeroc(ParmKind kind) {return (kind & HASZEROC) != 0;}$/;"	f
HasZerom	HTKLib/HParm.c	/^Boolean HasZerom(ParmKind kind) {return (kind & HASZEROM) != 0;}$/;"	f
Hash	HLMLib/LUtil.c	/^static unsigned Hash(char *name, int hashSize)$/;"	f	file:
Hash	HTKLib/HLabel.c	/^static unsigned Hash(char *name)$/;"	f	file:
Hash	HTKLib/HModel.c	/^static unsigned Hash(char *name)$/;"	f	file:
HashSlot	HTKLib/HRNLM.h	/^} HashSlot;$/;"	t	typeref:struct:_HashSlot
HashTab	HLMLib/LUtil.h	/^} HashTab;$/;"	t	typeref:struct:__anon23
HashTable	HTKLib/HRNLM.h	/^} HashTable;$/;"	t	typeref:struct:__anon91
HashValue	HTKLib/HRNLM.c	/^static unsigned int HashValue(HashTable* t, char* name)$/;"	f	file:
HdrField	HLMLib/LUtil.c	/^} HdrField;$/;"	t	typeref:struct:hdrField	file:
HeadInfo	HTKTools/HList.c	/^}HeadInfo;$/;"	t	typeref:struct:__anon153	file:
HeadMerge	HTKTools/HParse.c	/^void HeadMerge(Link a, Link b)$/;"	f
HeaderKind	HLMLib/LUtil.c	/^static LMHdrKind HeaderKind(char *s,int l)$/;"	f	file:
HeapType	HTKLib/HMem.h	/^typedef enum{MHEAP, MSTAK, CHEAP} HeapType;$/;"	t	typeref:enum:__anon72
HeaviestMix	HTKTools/HHEd.c	/^int HeaviestMix(char *hname, MixtureElem *me, int M)$/;"	f
HholdTrCols	HTKLib/HMath.c	/^static void HholdTrCols(DMatrix M, int i0, int j0, $/;"	f	file:
HholdTrRows	HTKLib/HMath.c	/^static void HholdTrRows(DMatrix M, int i0, int j0, DVector hh, double beta)$/;"	f	file:
HholdVec	HTKLib/HMath.c	/^static void HholdVec(DVector tmp, int i0, int size,$/;"	f	file:
HighestInput	HTKTools/HDMan.c	/^LabId HighestInput(void)$/;"	f
IBLink	HTKLib/HTrain.h	/^typedef struct _ItemBlock *IBLink;$/;"	t	typeref:struct:_ItemBlock
IDOutP	HTKLib/HModel.c	/^LogFloat IDOutP(Vector x, int vecSize, MixPDF *mp)$/;"	f
IFILL	HTKTools/HLEd.c	/^   SBDEF,   EXPAND, IFILL,  SORT,   WBDEF,  VBDEF,  LCTXT,  $/;"	e	enum:__anon141	file:
IFillOp	HTKTools/HLEd.c	/^int IFillOp(LabList *ll,LabId *args)$/;"	f
ILink	HTKLib/HModel.h	/^typedef struct _ItemRec *ILink;$/;"	t	typeref:struct:_ItemRec
IMULAW	HTKLib/HWave.c	/^   IMULAW       \/* Interleaved 8 bit u-law *\/$/;"	e	enum:_CompressType	file:
INCLUDED	HTKLib/esignal.h	93;"	d
INIT_CNE	HLMLib/LModel.c	390;"	d	file:
INIT_XPOS	HTKTools/HSLab.c	76;"	d	file:
INIT_YPOS	HTKTools/HSLab.c	77;"	d	file:
INPUTXFORM	HTKLib/HModel.c	/^   NUMCLASSES, ADAPTKIND, PREQUAL, INPUTXFORM,$/;"	e	enum:__anon40	file:
INSTALL	HTKLib/Makefile	/^INSTALL= \/usr\/bin\/install -c$/;"	m
INSTALL	HTKTools/Makefile	/^INSTALL = 	\/usr\/bin\/install -c$/;"	m
INTARG	HTKLib/HShell.h	/^typedef enum {SWITCHARG, STRINGARG, INTARG, FLOATARG, NOARG} ArgKind;$/;"	e	enum:__anon88
INT_FIELD	HTKLib/HNet.c	/^typedef enum {UNK_FIELD, STR_FIELD, INT_FIELD, FLT_FIELD} LatFieldType;$/;"	e	enum:__anon55	file:
INT_LMID	HLMLib/LModel.h	67;"	d
INVALID_INT	HTKLib/HRNLM.h	44;"	d
INVCOVAR	HTKLib/HModel.c	/^   MEAN, VARIANCE, INVCOVAR, XFORM, GCONST,$/;"	e	enum:__anon40	file:
INVDIAGC	HTKLib/HMath.h	/^   INVDIAGC,      \/* inverse diagonal covariance *\/$/;"	e	enum:__anon43
INVDIAGCOV	HTKLib/HModel.c	/^   DURATION, INVDIAGCOV, TRANSP, DPROB, LLTCOV, LLTCOVAR,$/;"	e	enum:__anon40	file:
IOConfParm	HTKLib/HParm.c	/^}IOConfParm;$/;"	t	typeref:enum:__anon77	file:
IOConfig	HTKLib/HParm.c	/^typedef IOConfigRec *IOConfig;$/;"	t	file:
IOConfigRec	HTKLib/HParm.c	/^}IOConfigRec;$/;"	t	typeref:struct:__anon76	file:
IOFilter	HTKLib/HShell.h	/^}IOFilter;$/;"	t	typeref:enum:__anon83
IO_WIN	HTKTools/HSLab.c	/^   WAVE_WIN, LAB_WIN, IO_WIN, NO_WIN $/;"	e	enum:__anon143	file:
IPat	HTKTools/HHEd.c	/^}IPat;$/;"	t	typeref:struct:_IPat	file:
IREFC	HTKLib/HParm.h	/^      IREFC,                           \/* Ref Coef in 16 bit form *\/$/;"	e	enum:_BaseParmKind
ISIL	HTKTools/HLEd.c	/^   RCTXT,   TCTXT,  SETLEV, DELLEV, SPLLEV, ISIL,$/;"	e	enum:__anon141	file:
IS_SEN	HLMTools/LPlex.c	610;"	d	file:
IS_SST	HLMTools/LPlex.c	609;"	d	file:
IS_UNK	HLMTools/LPlex.c	608;"	d	file:
ISilOp	HTKTools/HLEd.c	/^int ISilOp(LabList *ll,LabId *args)$/;"	f
ISmoothTau	HTKTools/HMMIRest.c	/^static float ISmoothTau = 0.0;        \/* I-smoothing: a h-crit-like thing.  Set to 100 for MMI or 50 for MPE, or 25 for MWE. *\/$/;"	v	file:
ISmoothTauTrans	HTKTools/HMMIRest.c	/^static float ISmoothTauTrans = 0.0;$/;"	v	file:
ISmoothTauTransSet	HTKTools/HMMIRest.c	/^static Boolean ISmoothTauTransSet=FALSE;$/;"	v	file:
ISmoothTauWeights	HTKTools/HMMIRest.c	/^static float ISmoothTauWeights = 0.0;$/;"	v	file:
ISmoothTauWeightsSet	HTKTools/HMMIRest.c	/^static Boolean ISmoothTauWeightsSet=FALSE;$/;"	v	file:
Ident	HTKTools/HParse.c	/^typedef char Ident[MAXIDENT+1];$/;"	t	file:
ImmDef	HTKLib/HLabel.h	/^}ImmDef;$/;"	t	typeref:struct:__anon117
InContext	HTKTools/HLEd.c	/^Boolean InContext(LLink l, LabId *lc, LabId *rc, LabId item)$/;"	f
InSamples	HTKLib/HAudio.c	/^static int InSamples(AudioIn a)$/;"	f	file:
InSet	HLMTools/LGPrep.c	/^Boolean InSet(SetDef *wset, LabId wdid)$/;"	f
InUse	HTKLib/HFBLat.h	/^  Boolean InUse; \/* FALSE if stacks are cleared and lattices empty. *\/$/;"	m	struct:__anon54
IncLabStr	HTKTools/HSLab.c	/^void IncLabStr(void)$/;"	f
IncSumSqr	HTKTools/HHEd.c	/^void IncSumSqr(StateInfo *si, Boolean ans, AccSum *no, AccSum *yes, int l)$/;"	f
IncUse	HTKLib/HMem.c	/^void IncUse(Ptr m)$/;"	f
Index	HTKTools/HResults.c	/^int Index(LabId labid)$/;"	f
InfoPrinted	HTKLib/HShell.c	/^Boolean InfoPrinted(void)$/;"	f
Init	HTKLib/HRNLM.c	/^void Init(RNNLM *rnnlmodel, Layer *self, char *str, int nr, int nc)$/;"	f
InitAdapt	HTKLib/HAdapt.c	/^void InitAdapt (XFInfo *xfinfo) $/;"	f
InitAlpha	HTKLib/HFB.c	/^static void InitAlpha(AlphaBeta *ab, int *start, int *end, $/;"	f	file:
InitArc	HTKLib/HArc.c	/^void InitArc(void)$/;"	f
InitAudi	HTKLib/HAudio.c	/^static void InitAudi(AudioIn a, HTime *sampPeriod)$/;"	f	file:
InitAudio	HTKLib/HAudio.c	/^void InitAudio(void)$/;"	f
InitAudo	HTKLib/HAudio.c	/^static void InitAudo(AudioOut a, HTime *sampPeriod)$/;"	f	file:
InitBar	HTKTools/HSLab.c	/^static void InitBar(BarType *bar, int x_ofs, HColour fg, int range, char *str)$/;"	f	file:
InitBuildInfo	HLMLib/LPCalc.c	/^void InitBuildInfo(BuildInfo *bi)$/;"	f
InitCMLLRXForm	HTKLib/HAdapt.c	/^static void InitCMLLRXForm(AccStruct *accs, DVector W, DVector bias)$/;"	f	file:
InitCMap	HLMLib/LCMap.c	/^void InitCMap(void)$/;"	f
InitClustering	HTKLib/HTrain.c	/^static void InitClustering(MemHeap *x, Sequence vpool, int nc,$/;"	f	file:
InitConMat	HTKTools/HResults.c	/^void InitConMat(void)$/;"	f
InitDict	HTKLib/HDict.c	/^void InitDict(void)$/;"	f
InitExactMPE	HTKLib/HExactMPE.c	/^void InitExactMPE(void)$/;"	f
InitFB	HTKLib/HFB.c	/^void InitFB(void)$/;"	f
InitFBLat	HTKLib/HFBLat.c	/^void InitFBLat(void)$/;"	f
InitFBank	HTKLib/HSigP.c	/^FBankInfo InitFBank(MemHeap *x, int frameSize, long sampPeriod, int numChans,$/;"	f
InitGBase	HLMLib/LGBase.c	/^void InitGBase(void)$/;"	f
InitGCs	HTKLib/HGraf.c	/^static void InitGCs(void)$/;"	f	file:
InitGlobals	HTKLib/HGraf.c	/^static void InitGlobals(void)$/;"	f	file:
InitGlobals	HTKLib/HGraf_WIN32.c	/^static void InitGlobals(void)$/;"	f	file:
InitGraf	HTKLib/HGraf.c	/^void InitGraf(void)$/;"	f
InitGraf	HTKLib/HGraf.null.c	/^void InitGraf(void)$/;"	f
InitGraf	HTKLib/HGraf_WIN32.c	/^void InitGraf(void)$/;"	f
InitHMMSet	HTKLib/HModel.c	/^static ReturnStatus InitHMMSet(HMMSet *hset, char *fname, Boolean isSingle)$/;"	f	file:
InitIdentity	HTKLib/HMath.c	/^static void InitIdentity(DMatrix A) $/;"	f	file:
InitLM	HTKLib/HLM.c	/^void InitLM(void)$/;"	f
InitLModel	HLMLib/LModel.c	/^void InitLModel(void)$/;"	f
InitLUtil	HLMLib/LUtil.c	/^void InitLUtil(void)$/;"	f
InitLabel	HTKLib/HLabel.c	/^void InitLabel(void)$/;"	f
InitLat	HTKLib/HLat.c	/^void InitLat(void)$/;"	f
InitMap	HTKLib/HMap.c	/^void InitMap(void)$/;"	f
InitMath	HTKLib/HMath.c	/^void InitMath(void)$/;"	f
InitMeanVariance	HTKLib/HRNLM.c	/^void InitMeanVariance (int ndim)$/;"	f
InitMem	HTKLib/HMem.c	/^void InitMem(void)$/;"	f
InitModel	HTKLib/HModel.c	/^void InitModel(void)$/;"	f
InitNLM	HTKLib/HNLM.c	/^void InitNLM(void)$/;"	f
InitNet	HTKLib/HNet.c	/^void InitNet(void)$/;"	f
InitPCalc	HLMLib/LPCalc.c	/^void InitPCalc(void)$/;"	f
InitPLP	HTKLib/HSigP.c	/^void InitPLP (FBankInfo info, int lpcOrder, Vector eql, DMatrix cm)$/;"	f
InitPMerge	HLMLib/LPMerge.c	/^void InitPMerge(void)$/;"	f
InitPSetInfo	HTKLib/HRec.c	/^PSetInfo *InitPSetInfo(HMMSet *hset)$/;"	f
InitParm	HTKLib/HParm.c	/^ReturnStatus InitParm(void)$/;"	f
InitPronHolders	HTKLib/HNet.c	/^static int InitPronHolders(Network *net,Lattice *lat,HMMSetCxtInfo *hci,$/;"	f	file:
InitPruneStats	HTKLib/HFB.c	/^static void InitPruneStats(AlphaBeta *ab)$/;"	f	file:
InitRNLM	HTKLib/HRNLM.c	/^void InitRNLM(void)$/;"	f
InitRec	HTKLib/HRec.c	/^void InitRec(void)$/;"	f
InitRectWin	HTKTools/HSLab.c	/^void InitRectWin(RectWin *win, float x, float y, float w, float h, $/;"	f
InitRegTree	HTKTools/HHEd.c	/^RegTree *InitRegTree(HMMSet *hset, int *vSize, ILink ilist) $/;"	f
InitScan	HTKTools/HParse.c	/^static void InitScan(char *fname)$/;"	f	file:
InitScanner	HTKLib/HModel.c	/^ReturnStatus InitScanner(char *fname, Source *src, Token *tok, HMMSet *hset)$/;"	f
InitSegStore	HTKTools/HInit.c	/^void InitSegStore(BufferInfo *info)$/;"	f
InitSegStore	HTKTools/HRest.c	/^void InitSegStore(BufferInfo *info)$/;"	f
InitSemiTiedDet	HTKLib/HAdapt.c	/^static double InitSemiTiedDet(BaseClass *bclass, IntVec classes)$/;"	f	file:
InitSemiTiedFR	HTKLib/HAdapt.c	/^static void InitSemiTiedFR(AdaptXForm *xform, LinXForm *xf, IntVec classes, TriMat totCov)$/;"	f	file:
InitSemiTiedVars	HTKLib/HAdapt.c	/^static void InitSemiTiedVars(AdaptXForm *xform, IntVec classes, TriMat totCov)$/;"	f	file:
InitShell	HTKLib/HShell.c	/^ReturnStatus InitShell(int argc, char *argv[], char *ver, char *sccs)$/;"	f
InitShiftReg	HLMTools/LGPrep.c	/^void InitShiftReg(ShiftReg *sr, int size, char *fn)$/;"	f
InitSigP	HTKLib/HSigP.c	/^void InitSigP(void)$/;"	f
InitSource	HTKLib/HShell.c	/^ReturnStatus InitSource(char *fname, Source *src,  IOFilter filter)$/;"	f
InitSpkrAcc	HTKTools/HCompV.c	/^SpkrAcc *InitSpkrAcc(void)$/;"	f
InitSpotLists	HTKTools/HResults.c	/^void InitSpotLists(void)$/;"	f
InitStats	HTKTools/HLStats.c	/^void InitStats(char *listFn)$/;"	f
InitStreamVars	HTKTools/HQuant.c	/^void InitStreamVars(void)$/;"	f
InitSubNetDefs	HTKTools/HParse.c	/^static void InitSubNetDefs(void)$/;"	f	file:
InitSymNames	HTKLib/HModel.c	/^void InitSymNames(void)$/;"	f
InitTMixRecs	HTKLib/HModel.c	/^void InitTMixRecs(HMMSet *hset, int s, int M)$/;"	f
InitTargetModel	HLMLib/LPCalc.c	/^static BackOffLM *InitTargetModel(MemHeap *heap, BuildInfo *bi)$/;"	f	file:
InitTargetModel	HLMLib/LPMerge.c	/^static BackOffLM *InitTargetModel(MemHeap *heap, int nSize, WordMap *wList)$/;"	f	file:
InitTrScan	HTKLib/HLabel.c	/^static void InitTrScan(void)$/;"	f	file:
InitTrain	HTKLib/HTrain.c	/^void InitTrain(void)$/;"	f
InitTreeAccs	HTKTools/HHEd.c	/^void InitTreeAccs(StateElem *se, int l)$/;"	f
InitUtil	HTKLib/HUtil.c	/^void InitUtil(void)$/;"	f
InitUttInfo	HTKLib/HFB.c	/^void InitUttInfo( UttInfo *utt, Boolean twoFiles )$/;"	f
InitUttObservations	HTKLib/HFB.c	/^void InitUttObservations(UttInfo *utt, HMMSet *al_hset, $/;"	f
InitVQ	HTKLib/HVQ.c	/^void InitVQ(void)$/;"	f
InitVRecInfo	HTKLib/HRec.c	/^VRecInfo *InitVRecInfo(PSetInfo *psi,int nToks,Boolean models,Boolean states)$/;"	f
InitVocab	HTKLib/HDict.c	/^void InitVocab(Vocab *voc)$/;"	f
InitWMap	HLMLib/LWMap.c	/^void InitWMap(void)$/;"	f
InitWave	HTKLib/HWave.c	/^void InitWave(void)$/;"	f
InitWordInfo	HTKTools/HLStats.c	/^void InitWordInfo(WordInfo *w, LabId id, Cntr *pCntr)$/;"	f
InitWordMap	HLMTools/LGPrep.c	/^void InitWordMap(void)$/;"	f
InitXFormScanner	HTKLib/HModel.c	/^static char *InitXFormScanner(HMMSet *hset, char *macroname, char *fname,$/;"	f	file:
InitalHashTable	HTKLib/HRNLM.c	/^void InitalHashTable(unsigned int tablesize, unsigned int objsize, HashTable* t)$/;"	f
Initialise	HLMTools/LAdapt.c	/^void Initialise(void)$/;"	f
Initialise	HLMTools/LBuild.c	/^void Initialise(BuildInfo *bi)$/;"	f
Initialise	HLMTools/LFoF.c	/^void Initialise(void)$/;"	f
Initialise	HLMTools/LGCopy.c	/^static void Initialise(void)$/;"	f	file:
Initialise	HLMTools/LGPrep.c	/^void Initialise(void)$/;"	f
Initialise	HLMTools/LMerge.c	/^void Initialise(void) $/;"	f
Initialise	HLMTools/LPlex.c	/^static void Initialise(void)$/;"	f	file:
Initialise	HTKTools/HCompV.c	/^void Initialise(void)$/;"	f
Initialise	HTKTools/HDMan.c	/^void Initialise(void)$/;"	f
Initialise	HTKTools/HERest.c	/^void Initialise(FBInfo *fbInfo, MemHeap *x, HMMSet *hset, char *hmmListFn)$/;"	f
Initialise	HTKTools/HHEd.c	/^void Initialise(char *hmmListFn)$/;"	f
Initialise	HTKTools/HInit.c	/^void Initialise(void)$/;"	f
Initialise	HTKTools/HLEd.c	/^void Initialise(void)$/;"	f
Initialise	HTKTools/HMMIRest.c	/^void Initialise(char *hmmListFn)$/;"	f
Initialise	HTKTools/HQuant.c	/^void Initialise(char *datafn)$/;"	f
Initialise	HTKTools/HResults.c	/^void Initialise(char * listfn)$/;"	f
Initialise	HTKTools/HSLab.c	/^void Initialise(void)$/;"	f
Initialise	HTKTools/HSmooth.c	/^void Initialise(char *hmmListFn)$/;"	f
Initialise	HTKTools/HVite.c	/^void Initialise(void)$/;"	f
Initialise1	HTKTools/HRest.c	/^void Initialise1(void)$/;"	f
Initialise2	HTKTools/HRest.c	/^void Initialise2(void)$/;"	f
InitialiseFBInfo	HTKLib/HFBLat.c	/^void InitialiseFBInfo(FBLatInfo *fbInfo,$/;"	f
InitialiseForBack	HTKLib/HFB.c	/^void InitialiseForBack(FBInfo *fbInfo, MemHeap *x, HMMSet *hset, UPDSet uset, $/;"	f
InitialiseMerge	HLMLib/LPMerge.c	/^static void InitialiseMerge(MemHeap *heap, MergeInfo *mi)$/;"	f	file:
InputAction	HTKLib/HWave.c	/^}InputAction;$/;"	t	typeref:enum:__anon99	file:
InputXForm	HTKLib/HModel.h	/^} InputXForm;$/;"	t	typeref:struct:__anon70
InputXFormCommand	HTKTools/HHEd.c	/^void InputXFormCommand()$/;"	f
InsCorrectness	HTKLib/HExactMPE.c	/^static float InsCorrectness = -1;   \/* repeat of config also used in HFBLat.c *\/$/;"	v	file:
InsCorrectness	HTKLib/HFBLat.c	/^static float InsCorrectness = -1;                            \/* Correctness of an inserted phone.  Can be tuned, it affects recognition insertion rate.$/;"	v	file:
InsertToHashTable	HTKLib/HRNLM.c	/^void InsertToHashTable(HashTable* t, char* key, void* obj)$/;"	f
InstallColours	HTKLib/HGraf.c	/^static void InstallColours(void)$/;"	f	file:
InstallColours	HTKLib/HGraf_WIN32.c	/^static void InstallColours(void)$/;"	f	file:
InstallFonts	HTKLib/HGraf.c	/^static void InstallFonts(void)$/;"	f	file:
IntCKind	HTKLib/HShell.h	/^   IntCKind,            \/* integer value - coercable to float *\/$/;"	e	enum:__anon85
IntSet	HTKLib/HUtil.h	/^}IntSet;$/;"	t	typeref:struct:__anon39
IntVec	HTKLib/HMem.h	/^typedef int   *IntVec;     \/* int vector[1..size] *\/$/;"	t
IntVecElemSize	HTKLib/HMem.c	/^size_t IntVecElemSize(int size) { return (size+1)*sizeof(int); }$/;"	f
IntVecSize	HTKLib/HMem.c	/^int IntVecSize(IntVec v)$/;"	f
InternTypeSize	HTKLib/esignal.c	/^InternTypeSize(int type         \/* numeric data_type code *\/ )$/;"	f
InternalDict	HTKLib/HNet.c	/^static Boolean InternalDict(Vocab *voc,HMMSetCxtInfo *hci)$/;"	f	file:
Interpolate	HTKTools/HSmooth.c	/^void Interpolate(void)$/;"	f
Intersect	HTKTools/HSLab.c	/^Boolean Intersect(long a, long b, long a1, long b1)$/;"	f
IntpltLM	HTKLib/HLM.h	/^} IntpltLM;$/;"	t	typeref:struct:intpltlm
InvDiagGConst	HTKLib/HVQ.c	/^static float InvDiagGConst(Vector iv)$/;"	f	file:
InvSVD	HTKLib/HMath.c	/^void InvSVD(DMatrix A, DMatrix U, DVector W, DMatrix V, DMatrix Result)$/;"	f
InvertRegion	HTKTools/HSLab.c	/^void InvertRegion(RectWin *win, int a, int b)$/;"	f
IsAnInClass	HLMLib/LCMap.c	/^Boolean IsAnInClass(ClassMap *c, int clndx)$/;"	f
IsClassMember	HLMLib/LCMap.c	/^Boolean IsClassMember(ClassMap *c, int clndx, int wdndx)$/;"	f
IsCommentChar	HTKTools/HDMan.c	/^Boolean IsCommentChar(int c)$/;"	f
IsDotLine	HTKLib/HLabel.c	/^static Boolean IsDotLine(char *s)$/;"	f	file:
IsFullSet	HTKLib/HUtil.c	/^Boolean IsFullSet(IntSet s)$/;"	f
IsHCIContextInd	HTKLib/HNet.c	/^Boolean IsHCIContextInd(HMMSetCxtInfo *hci,LabId labid)$/;"	f
IsHit	HTKTools/HResults.c	/^Boolean IsHit(LLink t)$/;"	f
IsInIdList	HTKTools/HDMan.c	/^Boolean IsInIdList(LabId id, LabId *idlist)$/;"	f
IsInIdList	HTKTools/HLEd.c	/^Boolean IsInIdList(LabId id, LabId *idlist)$/;"	f
IsInRect	HTKLib/HGraf.c	/^Boolean IsInRect(int x, int y, int x0, int y0, int x1, int y1)$/;"	f
IsInRect	HTKLib/HGraf.null.c	/^Boolean IsInRect(int x, int y, int x0, int y0, int x1, int y1)$/;"	f
IsInRect	HTKLib/HGraf_WIN32.c	/^Boolean IsInRect(int x, int y, int x0, int y0, int x1, int y1)$/;"	f
IsInRectWin	HTKTools/HSLab.c	/^Boolean IsInRectWin(RectWin *w, int x, int y)$/;"	f
IsInWin	HTKTools/HSLab.c	/^Boolean IsInWin(RectWin *w, int x, int y)$/;"	f
IsJoined	HTKTools/HParse.c	/^static Boolean IsJoined(int a, int b)$/;"	f	file:
IsLMScale	HTKLib/HArc.c	/^static Boolean IsLMScale = FALSE;$/;"	v	file:
IsMLFFile	HTKLib/HLabel.c	/^Boolean IsMLFFile(char *fn)$/;"	f
IsMember	HTKLib/HUtil.c	/^Boolean IsMember(IntSet s, int x)$/;"	f
IsNonSilArc	HTKLib/HExactMPE.c	/^Boolean IsNonSilArc(LArc *larc){ \/*returns TRUE if this word is non SENT_START etc. *\/$/;"	f
IsNumeric	HTKLib/HLabel.c	/^Boolean IsNumeric(char *s)$/;"	f
IsRContextInd	HTKLib/HNet.c	/^static Boolean IsRContextInd(HMMSetCxtInfo *hci,PronHolder *p,int pos,int xlc)$/;"	f	file:
IsSame	HTKTools/HLEd.c	/^Boolean IsSame(LabId a, LabId b)$/;"	f
IsSeen	HTKLib/HModel.c	/^Boolean IsSeen(int flag)$/;"	f
IsSeenV	HTKLib/HMem.c	/^Boolean IsSeenV(Ptr m)$/;"	f
IsShared	HTKLib/HModel.c	/^static Boolean IsShared(HMMSet *hset)$/;"	f	file:
IsSilence	HTKLib/HArc.h	/^  Boolean IsSilence; \/* Probably just start & end. *\/$/;"	m	struct:_CorrN
IsSilence	HTKLib/HExactMPE.c	96;"	d	file:
IsSilence	HTKLib/HExactMPE.c	99;"	d	file:
IsSilence	HTKLib/HFBLat.c	136;"	d	file:
IsSilence	HTKLib/HFBLat.c	139;"	d	file:
IsStartOrEnd	HTKLib/HExactMPE.c	101;"	d	file:
IsStartOrEnd	HTKLib/HFBLat.c	141;"	d	file:
IsTriMat	HTKLib/HMem.c	/^Boolean IsTriMat(Matrix m)$/;"	f
IsVAXOrder	HTKLib/HAudio.c	/^static Boolean IsVAXOrder(void)$/;"	f	file:
IsVAXOrder	HTKLib/HShell.c	/^static Boolean IsVAXOrder(void)$/;"	f	file:
IsVBnd	HTKTools/HLEd.c	/^Boolean IsVBnd(LabId id)$/;"	f
IsWBnd	HTKTools/HLEd.c	/^Boolean IsWBnd(LabId id)$/;"	f
IsWave	HTKTools/HCopy.c	/^Boolean IsWave(char *srcFile)$/;"	f
IsWave	HTKTools/HList.c	/^Boolean IsWave(char *srcFile)$/;"	f
IsWd0Link	HTKLib/HNet.c	/^static Boolean IsWd0Link(NetLink *link)$/;"	f	file:
IsWdPen	HTKLib/HArc.c	/^static Boolean IsWdPen = FALSE;$/;"	v	file:
ItemBlock	HTKLib/HTrain.h	/^}ItemBlock;$/;"	t	typeref:struct:_ItemBlock
ItemRec	HTKLib/HModel.h	/^}ItemRec;$/;"	t	typeref:struct:_ItemRec
JO	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon168	file:
JoinMatrix	HTKTools/HParse.c	/^typedef unsigned char **JoinMatrix; $/;"	t	file:
JoinNodes	HTKTools/HParse.c	/^void JoinNodes(Link a, Link b)$/;"	f
JoinSizeCommand	HTKTools/HHEd.c	/^void JoinSizeCommand(void)$/;"	f
K	HTKLib/HAdapt.c	/^   DVector *K, D;$/;"	m	struct:__anon92	file:
KeyPressed	HTKLib/HShell.c	/^Boolean KeyPressed(int tWait)$/;"	f
KeyType	HTKLib/HGraf.h	/^typedef enum _KeyType KeyType;$/;"	t	typeref:enum:_KeyType
Keyword	HTKLib/HUtil.c	/^} Keyword;$/;"	t	typeref:enum:__anon132	file:
KillTimes	HTKTools/HLEd.c	/^void KillTimes(LabList *ll)$/;"	f
L	HTKTools/HMMIRest.c	/^static int L;                        \/* number of logical HMM's *\/$/;"	v	file:
L10MINARG	HLMLib/LModel.h	50;"	d
L10MINARG	HTKLib/HLM-RNNLM.c	37;"	d	file:
L10ZERO	HLMLib/LModel.h	49;"	d
L10ZERO	HTKLib/HLM-RNNLM.c	36;"	d	file:
L2F	HTKLib/HMath.c	/^double   L2F(LogDouble x)$/;"	f
LAB_BUF_LEN	HTKTools/HSLab.c	82;"	d	file:
LAB_WIN	HTKTools/HSLab.c	/^   WAVE_WIN, LAB_WIN, IO_WIN, NO_WIN $/;"	e	enum:__anon143	file:
LANGSYM	HTKTools/HParse.c	/^             RBRACESYM, LANGSYM, RANGSYM, LBRAKSYM, RBRAKSYM, $/;"	e	enum:_Symbol	file:
LASTCMD	HTKTools/HLEd.c	/^   LASTCMD$/;"	e	enum:__anon141	file:
LASTN	HLMLib/LGBase.c	583;"	d	file:
LATFB_MAX	HTKLib/HLat.h	/^typedef enum {LATFB_SUM, LATFB_MAX} LatFBType;$/;"	e	enum:__anon134
LATFB_SUM	HTKLib/HLat.h	/^typedef enum {LATFB_SUM, LATFB_MAX} LatFBType;$/;"	e	enum:__anon134
LAdd	HTKLib/HMath.c	/^LogDouble LAdd(LogDouble x, LogDouble y)$/;"	f
LAlign	HTKLib/HNet.h	/^LAlign;$/;"	t	typeref:struct:lalign
LArc	HTKLib/HNet.h	/^LArc;$/;"	t	typeref:struct:larc
LArcNumb	HTKLib/HNet.h	245;"	d
LArcTotLMLike	HTKLib/HNet.h	252;"	d
LArcTotLike	HTKLib/HNet.h	257;"	d
LArc_E	HTKLib/HNet.h	/^LArc_E;$/;"	t	typeref:struct:larc_e
LArc_S	HTKLib/HNet.h	/^LArc_S;$/;"	t	typeref:struct:larc_s
LBRACESYM	HTKTools/HParse.c	/^enum _Symbol{NAMESYM, VARSYM, VARATSYM, LPARSYM, RPARSYM, LBRACESYM, $/;"	e	enum:_Symbol	file:
LBRAKSYM	HTKTools/HParse.c	/^             RBRACESYM, LANGSYM, RANGSYM, LBRAKSYM, RBRAKSYM, $/;"	e	enum:_Symbol	file:
LBUF_SIZE	HLMTools/LPlex.c	66;"	d	file:
LCMapFilter	HTKLib/HShell.h	/^   LCMapFilter,     \/* LM Class Map Input *\/$/;"	e	enum:__anon83
LCMapOFilter	HTKLib/HShell.h	/^   LCMapOFilter,    \/* LM Class Map Output *\/$/;"	e	enum:__anon83
LCPHONE	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon158	file:
LCPhoneOp	HTKTools/HDMan.c	/^void LCPhoneOp(WordBuf *wb)$/;"	f
LCTXT	HTKTools/HDMan.c	/^              LCTXT, RCTXT,$/;"	e	enum:__anon158	file:
LCTXT	HTKTools/HLEd.c	/^   SBDEF,   EXPAND, IFILL,  SORT,   WBDEF,  VBDEF,  LCTXT,  $/;"	e	enum:__anon141	file:
LCWORD	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon158	file:
LCase	HTKTools/HDMan.c	/^LabId LCase(LabId id)$/;"	f
LCtxtOp	HTKTools/HDMan.c	/^void LCtxtOp(WordBuf *wb, int nArgs,LabId *args)$/;"	f
LDFLAGS	HTKTools/Makefile	/^LDFLAGS = 	-L\/usr\/X11R6\/lib  -lm$/;"	m
LEVELSEP	HTKLib/HLabel.c	580;"	d	file:
LFEED	HTKLib/HLabel.c	583;"	d	file:
LFOF_HDR	HLMLib/LUtil.h	/^   NO_HDR, WMAP_HDR, CMAP_HDR, GRAM_HDR, LFOF_HDR$/;"	e	enum:__anon22
LGramFilter	HTKLib/HShell.h	/^   LGramFilter,     \/* NGram Input via LGBase *\/$/;"	e	enum:__anon83
LGramOFilter	HTKLib/HShell.h	/^   LGramOFilter,    \/* NGram Output via LGBase *\/$/;"	e	enum:__anon83
LIGHT_BLUE	HTKLib/HGraf.h	/^                LIGHT_BLUE, DARK_GREEN, LIGHT_GREEN, DARK_BROWN, LIGHT_BROWN, $/;"	e	enum:_HColour
LIGHT_BROWN	HTKLib/HGraf.h	/^                LIGHT_BLUE, DARK_GREEN, LIGHT_GREEN, DARK_BROWN, LIGHT_BROWN, $/;"	e	enum:_HColour
LIGHT_GREEN	HTKLib/HGraf.h	/^                LIGHT_BLUE, DARK_GREEN, LIGHT_GREEN, DARK_BROWN, LIGHT_BROWN, $/;"	e	enum:_HColour
LIGHT_GREY	HTKLib/HGraf.h	/^                LIGHT_GREY, GREY, DARK_GREY, BLACK};$/;"	e	enum:_HColour
LINKCHUNKSIZE	HTKTools/HParse.c	274;"	d	file:
LINKEXTENTFACTOR	HTKTools/HParse.c	275;"	d	file:
LINXFORM	HTKLib/HModel.c	/^   LINXFORM, OFFSET, BIAS, LOGDET, BLOCKINFO, BLOCK, BASECLASS, $/;"	e	enum:__anon40	file:
LLFInfo	HTKLib/HLat.c	/^typedef struct _LLFInfo LLFInfo;$/;"	t	typeref:struct:_LLFInfo	file:
LLTC	HTKLib/HMath.h	/^   LLTC,          \/* L' part of Choleski decomposition *\/$/;"	e	enum:__anon43
LLTCOV	HTKLib/HModel.c	/^   DURATION, INVDIAGCOV, TRANSP, DPROB, LLTCOV, LLTCOVAR,$/;"	e	enum:__anon40	file:
LLTCOVAR	HTKLib/HModel.c	/^   DURATION, INVDIAGCOV, TRANSP, DPROB, LLTCOV, LLTCOVAR,$/;"	e	enum:__anon40	file:
LLink	HTKLib/HLabel.h	/^typedef struct _Label *LLink;$/;"	t	typeref:struct:_Label
LMF_BINARY	HLMLib/LModel.h	/^  LMF_TEXT, LMF_BINARY, LMF_ULTRA, LMF_OTHER$/;"	e	enum:__anon8
LMF_OTHER	HLMLib/LModel.h	/^  LMF_TEXT, LMF_BINARY, LMF_ULTRA, LMF_OTHER$/;"	e	enum:__anon8
LMF_TEXT	HLMLib/LModel.h	/^  LMF_TEXT, LMF_BINARY, LMF_ULTRA, LMF_OTHER$/;"	e	enum:__anon8
LMF_ULTRA	HLMLib/LModel.h	/^  LMF_TEXT, LMF_BINARY, LMF_ULTRA, LMF_OTHER$/;"	e	enum:__anon8
LMFileFmt	HLMLib/LModel.h	/^} LMFileFmt;$/;"	t	typeref:enum:__anon8
LMFileHdr	HLMLib/LUtil.h	/^typedef struct lmFileHdrRec * LMFileHdr;     \/* Abstract type *\/       $/;"	t	typeref:struct:lmFileHdrRec
LMFileHdrRec	HLMLib/LUtil.c	/^}LMFileHdrRec;$/;"	t	typeref:struct:lmFileHdrRec	file:
LMHdrKind	HLMLib/LUtil.h	/^} LMHdrKind;$/;"	t	typeref:enum:__anon22
LMINMIX	HTKLib/HModel.h	53;"	d
LMInfo	HLMLib/LPMerge.h	/^} LMInfo;$/;"	t	typeref:struct:__anon17
LMNDX	HLMLib/LPCalc.c	116;"	d	file:
LMPPlexAcc	HTKLib/HLM.h	/^} LMPPlexAcc;$/;"	t	typeref:struct:lmpplexacc
LMP_COUNT	HLMLib/LModel.h	/^  LMP_COUNT = 004,$/;"	e	enum:__anon9
LMP_FLOAT	HLMLib/LModel.h	/^  LMP_FLOAT = 002,$/;"	e	enum:__anon9
LMP_LOG	HLMLib/LModel.h	/^  LMP_LOG   = 001,$/;"	e	enum:__anon9
LMP_OTHER	HLMLib/LModel.h	/^  LMP_OTHER = 010$/;"	e	enum:__anon9
LMProbType	HLMLib/LModel.h	/^} LMProbType;$/;"	t	typeref:enum:__anon9
LMSCALE	HTKLib/HArc.c	/^static float LMSCALE = 0;$/;"	v	file:
LMState	HTKLib/HLM.h	/^typedef Ptr LMState;$/;"	t
LMTextFilter	HTKLib/HShell.h	/^   LMTextFilter,    \/* LM source text input via LGPrep *\/$/;"	e	enum:__anon83
LMTrans	HTKLib/HLM.c	/^LogFloat LMTrans (LModel *lm, LMState src, LabId wdid, LMState *dest, LMState *src_mix, LMState *dest_mix, LabId *succwordId, LogFloat lmlike)$/;"	f
LMTrans2	HLMLib/LModel.c	/^LogFloat LMTrans2(LModel *LM, LMState src, LabId word, LMState *dest)$/;"	f
LMTrans_IntpltLM	HTKLib/HLM.c	/^LogFloat LMTrans_IntpltLM (LModel *lm, LMState src, LabId wdid, LMState *dest, LMState *src_mix, LMState *dest_mix, LabId *succwordId, LogFloat lmlike)$/;"	f
LMTrans_MLPLM	HTKLib/HLM.c	/^LogFloat LMTrans_MLPLM (LModel *lm, LMState src, LabId wdid, LMState *dest)$/;"	f
LMTrans_NGram	HTKLib/HLM.c	/^LogFloat LMTrans_NGram (LModel *lm, LMState src, LabId wdid, LMState *dest)$/;"	f
LMTrans_RNNLM	HTKLib/HLM-RNNLM.c	/^LogFloat LMTrans_RNNLM (LModel *lm, LMState src, LabId wdid, LMState *dest, LabId *succwordId)$/;"	f
LMType	HTKLib/HLM.h	/^typedef enum { boNGram=1, matBigram, mlpLM, intpltLM, rnnLM, hlmModel } LMType;$/;"	t	typeref:enum:__anon123
LM_INDEX	HLMLib/LModel.h	70;"	d
LM_Id	HLMLib/LModel.h	/^typedef UInt   LM_Id;       \/* 4-byte ID for large models *\/$/;"	t
LM_Id	HLMLib/LModel.h	/^typedef UShort LM_Id;       \/* 2-byte ID for normal models *\/$/;"	t
LM_NSIZE	HLMLib/LModel.h	47;"	d
LM_Prob	HLMLib/LModel.h	/^typedef UShort LM_Prob;     \/* 2-byte compressed probability *\/$/;"	t
LM_Prob	HLMLib/LModel.h	/^typedef float  LM_Prob;     \/* 4-byte probability\/count *\/$/;"	t
LM_TXT_BINARY	HLMLib/LModel.h	82;"	d
LM_TXT_OTHER	HLMLib/LModel.h	84;"	d
LM_TXT_TEXT	HLMLib/LModel.h	81;"	d
LM_TXT_ULTRA	HLMLib/LModel.h	83;"	d
LM_TYPES_DEFINED	HLMLib/LGBase.h	50;"	d
LM_TYPES_DEFINED	HLMLib/LModel.h	97;"	d
LModel	HTKLib/HLM.h	/^} LModel;$/;"	t	typeref:struct:lmodel
LN10	HLMLib/LModel.h	52;"	d
LN10	HTKLib/HLM.c	55;"	d	file:
LN10	HTKLib/HNLM.c	90;"	d	file:
LNGCX_FMT	HTKLib/esig_asc.c	83;"	d	file:
LNGCX_W	HTKLib/esig_asc.c	82;"	d	file:
LNGCX_WFMT	HTKLib/esig_asc.c	84;"	d	file:
LNG_FMT	HTKLib/esig_asc.c	51;"	d	file:
LNG_W	HTKLib/esig_asc.c	50;"	d	file:
LNG_WFMT	HTKLib/esig_asc.c	52;"	d	file:
LNode	HTKLib/HNet.h	/^LNode;$/;"	t	typeref:struct:lnode
LNodeBw	HTKLib/HLat.h	57;"	d
LNodeFw	HTKLib/HLat.h	56;"	d
LNodeStats	HTKLib/HLat.c	886;"	d	file:
LOADFIDX	HTKLib/HModel.c	67;"	d	file:
LOFREQ	HTKLib/HParm.c	/^   LOFREQ,        \/* Lo Fbank frequency *\/$/;"	e	enum:__anon77	file:
LOG10_TO_FLT	HLMLib/LModel.h	54;"	d
LOG10_TO_FLT	HTKLib/HLM-RNNLM.c	40;"	d	file:
LOGDET	HTKLib/HModel.c	/^   LINXFORM, OFFSET, BIAS, LOGDET, BLOCKINFO, BLOCK, BASECLASS, $/;"	e	enum:__anon40	file:
LOG_NATURAL	HLMLib/LModel.h	61;"	d
LOG_NATURAL	HTKLib/HLM.h	47;"	d
LONG	HTKLib/esignal.h	68;"	d
LONG_COMPLEX	HTKLib/esignal.h	77;"	d
LOpen	HTKLib/HLabel.c	/^Transcription *LOpen(MemHeap *x, char * fname, FileFormat fmt)$/;"	f
LPARSYM	HTKTools/HParse.c	/^enum _Symbol{NAMESYM, VARSYM, VARATSYM, LPARSYM, RPARSYM, LBRACESYM, $/;"	e	enum:_Symbol	file:
LPC	HTKLib/HParm.h	/^      LPC,LPREFC,LPCEPSTRA,LPDELCEP,   \/* LP-based Coefficients *\/$/;"	e	enum:_BaseParmKind
LPC2Cepstrum	HTKLib/HSigP.c	/^void LPC2Cepstrum (Vector a, Vector c)$/;"	f
LPC2RefC	HTKLib/HSigP.c	/^void LPC2RefC(Vector a, Vector k)$/;"	f
LPCEPSTRA	HTKLib/HParm.h	/^      LPC,LPREFC,LPCEPSTRA,LPDELCEP,   \/* LP-based Coefficients *\/$/;"	e	enum:_BaseParmKind
LPCORDER	HTKLib/HParm.c	/^   LPCORDER,      \/* LPC order *\/      $/;"	e	enum:__anon77	file:
LPCbased	HTKLib/HParm.c	/^typedef enum { FFTbased, LPCbased, VQbased} CodeStyle;$/;"	e	enum:__anon75	file:
LPDELCEP	HTKLib/HParm.h	/^      LPC,LPREFC,LPCEPSTRA,LPDELCEP,   \/* LP-based Coefficients *\/$/;"	e	enum:_BaseParmKind
LPREFC	HTKLib/HParm.h	/^      LPC,LPREFC,LPCEPSTRA,LPDELCEP,   \/* LP-based Coefficients *\/$/;"	e	enum:_BaseParmKind
LS	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon168	file:
LSBLOCK	HTKTools/HParse.c	280;"	d	file:
LSMALL	HTKLib/HMath.h	43;"	d
LSave	HTKLib/HLabel.c	/^ReturnStatus LSave(char *fname, Transcription *t, FileFormat fmt)$/;"	f
LSub	HTKLib/HMath.c	/^LogDouble LSub(LogDouble x, LogDouble y)$/;"	f
LT	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon168	file:
LTBNDX	HLMLib/LWMap.c	143;"	d	file:
LTRISYM	HTKTools/HParse.c	/^             LTRISYM,RTRISYM,EQSYM, SEMISYM, BARSYM, PERCENTSYM, $/;"	e	enum:_Symbol	file:
LTriStrip	HTKLib/HLabel.c	/^void LTriStrip(Boolean enab)$/;"	f
LUDecompose	HTKLib/HMath.c	/^static Boolean LUDecompose(Matrix a, int *perm, int *sign)$/;"	f	file:
LWMapFilter	HTKLib/HShell.h	/^   LWMapFilter,     \/* LM Word Map Input via LWMap *\/$/;"	e	enum:__anon83
LWMapOFilter	HTKLib/HShell.h	/^   LWMapOFilter,    \/* LM Word Map Output via LWMap *\/$/;"	e	enum:__anon83
LZERO	HTKLib/HMath.h	42;"	d
L_VERSION	HTKLib/HNet.h	73;"	d
LabId	HTKLib/HLabel.h	/^typedef NameCell *LabId;   \/* Internal representation of names *\/$/;"	t
LabList	HTKLib/HLabel.h	/^}LabList;$/;"	t	typeref:struct:_LabList
Label	HTKLib/HLabel.h	/^}Label; \/* NB: head and tail of every list are dummy sentinels *\/$/;"	t	typeref:struct:_Label
LabelInternal	HTKTools/HParse.c	/^void LabelInternal(Link p)$/;"	f
LabelsFilter	HTKLib/HShell.h	/^   LabelsFilter,    \/* Label files input via HLabel *\/$/;"	e	enum:__anon83
LabelsOFilter	HTKLib/HShell.h	/^   LabelsOFilter,   \/* Label files output via HLabel *\/$/;"	e	enum:__anon83
LambdaOpt	HTKTools/HSmooth.c	/^float LambdaOpt(StreamElem *ste, int M)$/;"	f
LangModFilter	HTKLib/HShell.h	/^   LangModFilter,   \/* language model files input via HLM *\/$/;"	e	enum:__anon83
LangModOFilter	HTKLib/HShell.h	/^   LangModOFilter,  \/* language model files output via HLM *\/$/;"	e	enum:__anon83
Language Modelling	HTKBook/htkbook-pdf.tex	/^\\include{decode}$/;"	p
Language Modelling	HTKBook/htkbook.tex	/^\\include{decode}$/;"	p
LatAttachInfo	HTKLib/HLat.c	/^void LatAttachInfo (MemHeap *heap, size_t size, Lattice *lat)$/;"	f
LatCheck	HTKLib/HLat.c	/^void LatCheck (Lattice *lat)$/;"	f
LatDetachInfo	HTKLib/HLat.c	/^void LatDetachInfo (MemHeap *heap, Lattice *lat)$/;"	f
LatEndNode	HTKLib/HLat.c	/^LNode *LatEndNode (Lattice *lat)$/;"	f
LatExpand	HTKLib/HLat.c	/^Lattice *LatExpand (MemHeap *heap, Lattice *lat, LModel *lm, int ngramaprox)$/;"	f
LatFBType	HTKLib/HLat.h	/^typedef enum {LATFB_SUM, LATFB_MAX} LatFBType;$/;"	t	typeref:enum:__anon134
LatFieldType	HTKLib/HNet.c	/^typedef enum {UNK_FIELD, STR_FIELD, INT_FIELD, FLT_FIELD} LatFieldType;$/;"	t	typeref:enum:__anon55	file:
LatFindBest	HTKLib/HLat.c	/^Transcription *LatFindBest (MemHeap *heap, Lattice *lat, int N)$/;"	f
LatFormat	HTKLib/HNet.h	/^typedef int LatFormat;      \/* Format of lattice. Formed by oring flags *\/$/;"	t
LatForwBackw	HTKLib/HLat.c	/^LogDouble LatForwBackw (Lattice *lat, LatFBType type)$/;"	f
LatFromPaths	HTKLib/HRec.c	/^static void LatFromPaths(Path *path,int *ln,Lattice *lat)$/;"	f	file:
LatInLat	HTKLib/HArc.c	/^Boolean LatInLat(Lattice *numLat, Lattice *denLat){$/;"	f
LatInLatRec	HTKLib/HArc.c	/^Boolean LatInLatRec(LNode *n1, LNode *n2){$/;"	f
LatLMTrans	HTKLib/HLat.c	/^static LogFloat  LatLMTrans (LModel *lm, LMState src, LabId wordId, LMState *dest, LMState *src_mix, LMState *dest_mix, LabId *succwordId, LogFloat lmlike)$/;"	f	file:
LatMask_Denominator	HTKTools/HMMIRest.c	/^static char *LatMask_Denominator = NULL;$/;"	v	file:
LatMask_Numerator	HTKTools/HMMIRest.c	/^static char *LatMask_Numerator   = NULL;$/;"	v	file:
LatPrune	HTKLib/HLat.c	/^Lattice *LatPrune (MemHeap *heap, Lattice *lat, LogDouble thresh, float arcsPerSec)$/;"	f
LatSetBoundaryWords	HTKLib/HLat.c	/^void LatSetBoundaryWords (char *start, char *end, char  *startLM, char *endLM)$/;"	f
LatSetScores	HTKLib/HLat.c	/^void LatSetScores (Lattice *lat)$/;"	f
LatStartNode	HTKLib/HLat.c	/^LNode *LatStartNode (Lattice *lat)$/;"	f
LatTopSort	HTKLib/HLat.c	/^Boolean LatTopSort (Lattice *lat, LNode **topOrder)$/;"	f
LatTopSortVisit	HTKLib/HLat.c	/^void LatTopSortVisit (LNode *ln, int *time)$/;"	f
Lattice	HTKLib/HNet.h	/^Lattice;$/;"	t	typeref:struct:lattice
LatticeFromLabels	HTKLib/HNet.c	/^Lattice *LatticeFromLabels(LabList *ll,LabId bnd,Vocab *voc,MemHeap *heap)$/;"	f
Layer	HTKLib/HRNLM.h	/^} Layer;$/;"	t	typeref:struct:_Layer
LeftTriCxt	HTKTools/HLEd.c	/^LabId LeftTriCxt(LLink l)$/;"	f
LikeToWord	HTKLib/HRec.c	/^static LogFloat LikeToWord(NetNode *node)$/;"	f	file:
LinSolve	HTKLib/HMath.c	/^static void LinSolve(Matrix a, int *perm, float *b)$/;"	f	file:
LinTranQuaProd	HTKLib/HMath.c	/^void LinTranQuaProd(Matrix Prod, Matrix A, Matrix C)$/;"	f
LinXForm	HTKLib/HModel.h	/^} LinXForm;$/;"	t	typeref:struct:__anon68
LineWidth	HTKLib/HGraf_WIN32.c	/^static int LineWidth = 1;$/;"	v	file:
Link	HTKTools/HParse.c	/^typedef struct _Node *Link;$/;"	t	typeref:struct:_Node	file:
LinkEquiv	HLMTools/LPlex.c	/^static void LinkEquiv(void)$/;"	f	file:
LinkSet	HTKTools/HParse.c	/^} LinkSet;$/;"	t	typeref:struct:__anon154	file:
ListFinds	HTKTools/HLEd.c	/^void ListFinds(void)$/;"	f
ListNewPhones	HTKTools/HDMan.c	/^void ListNewPhones(void)$/;"	f
ListParms	HTKTools/HList.c	/^void ListParms(char *src)$/;"	f
ListSpeech	HTKTools/HList.c	/^void ListSpeech(char *src)$/;"	f
ListWavefromAudio	HTKTools/HList.c	/^void ListWavefromAudio(void)$/;"	f
ListWavefromFile	HTKTools/HList.c	/^void ListWavefromFile(char *src)$/;"	f
LoadASet	HTKTools/HSmooth.c	/^int LoadASet(LabId x)$/;"	f
LoadAccs	HTKLib/HTrain.c	/^Source LoadAccs(HMMSet *hset, char *fname, UPDSet uFlags){ return LoadAccsParallel(hset,fname,uFlags,0); }$/;"	f
LoadAccsParallel	HTKLib/HTrain.c	/^Source LoadAccsParallel(HMMSet *hset, char *fname, UPDSet uFlags, int index)$/;"	f
LoadAllMacros	HTKLib/HModel.c	/^static ReturnStatus LoadAllMacros(HMMSet *hset, char *fname, short fidx)$/;"	f	file:
LoadBaseClass	HTKLib/HModel.c	/^BaseClass *LoadBaseClass(HMMSet *hset, char* macroname, char *fname)$/;"	f
LoadBiGrams	HLMTools/Cluster.c	/^static void LoadBiGrams()$/;"	f	file:
LoadBinaryRNNLM	HTKLib/HRNLM.c	/^void LoadBinaryRNNLM (char *modelfn, RNNLM* rnnlmodel)$/;"	f
LoadCMeanVector	HTKLib/HParm.c	/^static void LoadCMeanVector( MemHeap* x , IOConfig cf , char* fname )$/;"	f	file:
LoadCUEDRNLMwgt	HTKLib/HRNLM.c	/^void LoadCUEDRNLMwgt (char *orgmodelfn, char *inmap_file, char *outmap_file,$/;"	f
LoadCUEDRNLMwgt_v1_0	HTKLib/HRNLM.c	/^void LoadCUEDRNLMwgt_v1_0 (char *orgmodelfn, char *inmap_file, char *outmap_file,$/;"	f
LoadCUEDRNLMwgt_v1_1	HTKLib/HRNLM.c	/^void LoadCUEDRNLMwgt_v1_1 (char *orgmodelfn, char *inmap_file, char *outmap_file,$/;"	f
LoadCUEDRNNLM	HTKLib/HRNLM.c	/^void LoadCUEDRNNLM(char* modelfn, RNNLM* rnnlmodel){$/;"	f
LoadCUEDRNNLM_v1_0	HTKLib/HRNLM.c	/^void LoadCUEDRNNLM_v1_0(char* modelfn, RNNLM* rnnlmodel){$/;"	f
LoadCUEDRNNLM_v1_1	HTKLib/HRNLM.c	/^void LoadCUEDRNNLM_v1_1(char* modelfn, RNNLM* rnnlmodel){$/;"	f
LoadClass	HLMLib/LCMap.c	/^static void LoadClass(ClassMap *cm, Source *src, LabId clname, int clndx, $/;"	f	file:
LoadData	HTKLib/HFB.c	/^void LoadData(HMMSet *hset, UttInfo *utt, FileFormat dff, $/;"	f
LoadData	HTKLib/HWave.c	/^static ReturnStatus LoadData(FILE *f, Wave w, long fBytes)$/;"	f	file:
LoadData	HTKTools/HSLab.c	/^void LoadData(void)$/;"	f
LoadESPSLabels	HTKLib/HLabel.c	/^static void LoadESPSLabels(MemHeap *x, Transcription *t, Source *src)$/;"	f	file:
LoadFRNLMwgt	HTKLib/HRNLM.c	/^void LoadFRNLMwgt (char *orgmodelfn, char *inmap_file, char *outmap_file,$/;"	f
LoadFRNNLM	HTKLib/HRNLM.c	/^void LoadFRNNLM(char* modelfn, RNNLM* rnnlmodel){$/;"	f
LoadFile	HTKTools/HCompV.c	/^void LoadFile(char *fn)$/;"	f
LoadFile	HTKTools/HInit.c	/^void LoadFile(char *fn)$/;"	f
LoadFile	HTKTools/HQuant.c	/^void LoadFile(char *fn)$/;"	f
LoadFile	HTKTools/HRest.c	/^void LoadFile(char *fn)$/;"	f
LoadFiles	HTKTools/HSLab.c	/^void LoadFiles(void)$/;"	f
LoadHMMSet	HTKLib/HModel.c	/^ReturnStatus LoadHMMSet(HMMSet *hset, char *hmmDir, char *hmmExt)$/;"	f
LoadHTKLabels	HTKLib/HLabel.c	/^static void LoadHTKLabels(MemHeap *x, Transcription *t, Source *src)$/;"	f	file:
LoadHTKList	HTKLib/HLabel.c	/^static LabList * LoadHTKList(MemHeap *x, Source *src, int alt)$/;"	f	file:
LoadInputXForm	HTKLib/HModel.c	/^InputXForm *LoadInputXForm(HMMSet *hset, char* macroname, char *fname)$/;"	f
LoadLabs	HTKLib/HFB.c	/^void LoadLabs(UttInfo *utt, FileFormat lff, char * datafn, $/;"	f
LoadLabs	HTKTools/HSLab.c	/^void LoadLabs(void)$/;"	f
LoadLangModel	HLMLib/LModel.c	/^BackOffLM *LoadLangModel(char *fn, WordMap *wl, float gramScale,$/;"	f
LoadLattice	HTKTools/HBuild.c	/^Lattice *LoadLattice(MemHeap *latHeap, char *latFn, Vocab *voc,$/;"	f
LoadMacroFiles	HTKLib/HModel.c	/^static ReturnStatus LoadMacroFiles(HMMSet *hset)$/;"	f	file:
LoadMapData	HLMLib/LCMap.c	/^static void LoadMapData(Source *src, ClassMap *cm, int entries)$/;"	f	file:
LoadMapData	HLMLib/LWMap.c	/^static void LoadMapData(Source *src, WordMap *wm)$/;"	f	file:
LoadMasterFile	HTKLib/HLabel.c	/^void LoadMasterFile(char *fname)$/;"	f
LoadMat	HTKLib/HParm.c	/^static void LoadMat (MemHeap *x, IOConfig cf)  \/*static??*\/$/;"	f	file:
LoadMuAcc	HTKLib/HTrain.c	/^static void LoadMuAcc(Source *src, MuAcc *ma, int vSize)$/;"	f	file:
LoadNGram	HLMLib/LModel.c	/^static int LoadNGram(Source *src, int nSize, BackOffLM *lm, int *itran)$/;"	f	file:
LoadNLMwgt	HTKLib/HNLM.c	/^void LoadNLMwgt(char *wgt_file, char *inmap_file, char *outmap_file, $/;"	f
LoadOneXForm	HTKLib/HModel.c	/^AdaptXForm *LoadOneXForm(HMMSet *hset, char* macroname, char *fname)$/;"	f
LoadPhoneList	HTKTools/HDMan.c	/^void LoadPhoneList(void)$/;"	f
LoadQuestion	HTKTools/HHEd.c	/^void LoadQuestion(char *qName, ILink ilist, char *pattern)$/;"	f
LoadRNLMwgt	HTKLib/HRNLM.c	/^void LoadRNLMwgt(char* orgmodelfn, char* inmap_file, char* outmap_file,$/;"	f
LoadRNNLM	HTKLib/HRNLM.c	/^void LoadRNNLM(char* modelfn, RNNLM* rnnlmodel){$/;"	f
LoadRegTree	HTKLib/HModel.c	/^RegTree *LoadRegTree(HMMSet *hset, char* macroname, char *fname)$/;"	f
LoadSCRIBELabels	HTKLib/HLabel.c	/^static void LoadSCRIBELabels(MemHeap *x, Transcription *t, Source *src)$/;"	f	file:
LoadSSet	HTKTools/HSmooth.c	/^void LoadSSet(int i, int s)$/;"	f
LoadSegment	HTKLib/HTrain.c	/^void LoadSegment(SegStore ss, HTime start, HTime end, ParmBuf pbuf)$/;"	f
LoadSideXForm	HTKLib/HParm.c	/^static AdaptXForm *LoadSideXForm(IOConfig cf, char *fname) $/;"	f	file:
LoadStatsCommand	HTKTools/HHEd.c	/^void LoadStatsCommand(void)$/;"	f
LoadStatsFile	HTKLib/HUtil.c	/^void LoadStatsFile(char *statfile,HMMSet *hset,Boolean otrace)$/;"	f
LoadTIMITLabels	HTKLib/HLabel.c	/^static void LoadTIMITLabels(MemHeap *x, Transcription *t, Source *src)$/;"	f	file:
LoadTextRNNLM	HTKLib/HRNLM.c	/^void LoadTextRNNLM (char *modelfn, RNNLM* rnnlmodel)$/;"	f
LoadTextRNNLM_v1_0	HTKLib/HRNLM.c	/^void LoadTextRNNLM_v1_0 (char *modelfn, RNNLM* rnnlmodel)$/;"	f
LoadTextRNNLM_v1_1	HTKLib/HRNLM.c	/^void LoadTextRNNLM_v1_1 (char *modelfn, RNNLM* rnnlmodel)$/;"	f
LoadTrAcc	HTKLib/HTrain.c	/^static void LoadTrAcc(Source *src, TrAcc *ta, int numStates)$/;"	f	file:
LoadTransLabs	HTKTools/HCopy.c	/^Transcription *LoadTransLabs(char *src)$/;"	f
LoadTree	HTKTools/HHEd.c	/^Tree *LoadTree(char *name,Source *src)$/;"	f
LoadTreesCommand	HTKTools/HHEd.c	/^void LoadTreesCommand(void)$/;"	f
LoadUltraNGrams	HLMLib/LModel.c	/^static void LoadUltraNGrams(Source *src, BackOffLM *lm)$/;"	f	file:
LoadUniGrams	HLMTools/Cluster.c	/^static void LoadUniGrams()$/;"	f	file:
LoadUnigram	HLMLib/LModel.c	/^static int LoadUnigram(Source *src, BackOffLM *lm, int *itran)$/;"	f	file:
LoadVQTab	HTKLib/HVQ.c	/^VQTable LoadVQTab(char *tabFN, short magic)$/;"	f
LoadVaAcc	HTKLib/HTrain.c	/^static void LoadVaAcc(Source *src, VaAcc *va, int vSize, CovKind ck)$/;"	f	file:
LoadVarScale	HTKLib/HParm.c	/^static void LoadVarScale (MemHeap *x, IOConfig cf)$/;"	f	file:
LoadVarScaleVector	HTKLib/HParm.c	/^static void LoadVarScaleVector(MemHeap* x, IOConfig cf, char *fname)$/;"	f	file:
LoadWordList	HTKTools/HDMan.c	/^void LoadWordList(void)$/;"	f
LoadWtAcc	HTKLib/HTrain.c	/^static void LoadWtAcc(Source *src, WtAcc *wa, int numMixtures)$/;"	f	file:
LogDouble	HTKLib/HMath.h	/^typedef double LogDouble;$/;"	t
LogFloat	HTKLib/HMath.h	/^typedef float  LogFloat;   \/* types just to signal log values *\/$/;"	t
LongComplex	HTKLib/esignal.h	/^typedef struct {long	real, imag;}	LongComplex;$/;"	t	typeref:struct:__anon48
LongProd	HTKLib/esignal.c	/^LongProd(int     n,$/;"	f
LongVal	HTKLib/esignal.c	/^LongVal(void *src, int type, long *dest)$/;"	f	file:
LookupTable	HLMLib/LWMap.h	/^} LookupTable;$/;"	t	typeref:struct:__anon19
M	HTKLib/HUtil.h	/^   int M;            \/* num mixtures *\/$/;"	m	struct:__anon38
MACHASHSIZE	HTKLib/HModel.h	50;"	d
MACHEPS	HTKLib/HMath.c	682;"	d	file:
MACRO	HTKLib/HModel.c	/^   MACRO, EOFSYM, NULLSYM   \/* Special Syms - not literals *\/$/;"	e	enum:__anon40	file:
MAGIC	HTKLib/esignal.h	54;"	d
MAPENTRY	HLMLib/LWMap.h	/^typedef struct MAPENTRY {  \/* word map entry *\/$/;"	s
MAPUpdateModels	HTKLib/HMap.c	/^void MAPUpdateModels(HMMSet *hset, UPDSet uFlags)$/;"	f
MAP_ENTRY	HLMLib/LWMap.c	231;"	d	file:
MAP_ENTRY	HLMTools/LGCopy.c	321;"	d	file:
MATTRAN	HTKLib/HParm.c	/^   MATTRAN,$/;"	e	enum:__anon77	file:
MATTRANFN	HTKLib/HParm.c	/^   MATTRANFN,     \/* File name for MatTran file *\/$/;"	e	enum:__anon77	file:
MAUVE	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	e	enum:_HColour
MAX	HTKLib/HArc.c	74;"	d	file:
MAX	HTKLib/HExactMPE.c	90;"	d	file:
MAX	HTKLib/HFBLat.c	72;"	d	file:
MAX	HTKTools/HHEd.c	5313;"	d	file:
MAX	HTKTools/HMMIRest.c	61;"	d	file:
MAXARGS	HTKTools/HDMan.c	61;"	d	file:
MAXARGS	HTKTools/HLEd.c	60;"	d	file:
MAXCONMATSIZE	HTKTools/HResults.c	1165;"	d	file:
MAXCONS	HTKTools/HDMan.c	65;"	d	file:
MAXDICTS	HTKTools/HDMan.c	64;"	d	file:
MAXEFS	HTKLib/HShell.c	70;"	d	file:
MAXFNAMELEN	HTKLib/HShell.h	76;"	d
MAXGLOBS	HTKLib/HShell.h	78;"	d
MAXIDENT	HTKTools/HParse.c	276;"	d	file:
MAXINF	HLMLib/LGBase.h	44;"	d
MAXIV	HTKTools/HLEd.c	62;"	d	file:
MAXIW	HTKTools/HLEd.c	61;"	d	file:
MAXLATDEPTH	HTKLib/HNet.c	411;"	d	file:
MAXLATS	HTKLib/HArc.h	163;"	d
MAXLINELEN	HTKLib/HRNLM.c	52;"	d	file:
MAXMLFS	HTKLib/HLabel.c	115;"	d	file:
MAXMONOPHONES	HTKTools/HSmooth.c	39;"	d	file:
MAXNG	HLMLib/LGBase.h	43;"	d
MAXPHONES	HTKLib/HDict.h	35;"	d
MAXPRONS	HTKTools/HDMan.c	63;"	d	file:
MAXPVOC	HTKTools/HDMan.c	66;"	d	file:
MAXSTRLEN	HTKLib/HShell.h	75;"	d
MAXSYMLEN	HLMLib/LModel.c	120;"	d	file:
MAXSYMLEN	HTKLib/HModel.c	391;"	d	file:
MAXTIME	HTKTools/HCopy.c	107;"	d	file:
MAXVAR	HTKLib/HUtil.c	406;"	d	file:
MAXVQNODES	HTKLib/HVQ.c	36;"	d	file:
MAX_AMPL	HTKTools/HSLab.c	87;"	d	file:
MAX_ATTR	HTKLib/esig_asc.c	1080;"	d	file:
MAX_ATTR	HTKLib/esig_asc.c	1175;"	d	file:
MAX_COLOURS	HTKLib/HGraf.h	51;"	d
MAX_DEPTH	HTKLib/HNet.c	2473;"	d	file:
MAX_FIELDS	HLMTools/LGPrep.c	72;"	d	file:
MAX_FILES	HLMTools/LPlex.c	67;"	d	file:
MAX_FLD_DEPTH	HTKLib/esig_asc.c	36;"	d	file:
MAX_GC	HTKLib/HGraf.c	80;"	d	file:
MAX_GREYS	HTKLib/HGraf.h	50;"	d
MAX_INT	HTKLib/HParm.c	485;"	d	file:
MAX_INT	HTKLib/HWave.c	46;"	d	file:
MAX_ITEMS	HLMTools/LGPrep.c	73;"	d	file:
MAX_ITER	HTKTools/HHEd.c	61;"	d	file:
MAX_LAB_LEN	HTKTools/HSLab.c	81;"	d	file:
MAX_LM	HLMTools/LPlex.c	64;"	d	file:
MAX_LMID	HTKLib/HLM.h	79;"	d
MAX_LMODEL	HLMLib/LPMerge.h	43;"	d
MAX_LMODEL	HTKLib/HLM.h	89;"	d
MAX_MATBILMID	HTKLib/HLM.h	84;"	d
MAX_NGRAM_FILES	HLMTools/LAdapt.c	109;"	d	file:
MAX_NGRAM_ORDER	HTKLib/HRNLM.h	62;"	d
MAX_OOV	HLMTools/LPlex.c	63;"	d	file:
MAX_PB_SIZE	HTKLib/HParm.c	484;"	d	file:
MAX_POINT	HTKLib/HGraf_WIN32.c	41;"	d	file:
MAX_SETS	HLMTools/LGPrep.c	74;"	d	file:
MAX_STACK	HTKLib/HMath.c	686;"	d	file:
MAX_STRING	HTKLib/HRNLM.h	43;"	d
MAX_STRING_LENGTH	HTKLib/HNLM.h	66;"	d
MAX_TEST	HLMTools/LPlex.c	65;"	d	file:
MAX_TOKS	HTKLib/HRec.h	32;"	d
MAX_TYPE_LEN	HTKLib/esignal.h	85;"	d
MAX_ZOOM	HTKTools/HSLab.c	74;"	d	file:
MD	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon168	file:
MEAN	HTKLib/HModel.c	/^   MEAN, VARIANCE, INVCOVAR, XFORM, GCONST,$/;"	e	enum:__anon40	file:
MEANBASE	HTKLib/HModel.h	/^enum _BaseClassKind {MIXBASE, MEANBASE, COVBASE};$/;"	e	enum:_BaseClassKind
MEAN_KEY	HTKLib/HUtil.c	/^   MIX_KEY, MEAN_KEY, STREAM_KEY, COV_KEY$/;"	e	enum:__anon132	file:
MEASURESIL	HTKLib/HParm.c	/^   MEASURESIL,    \/* Measure Background Silence *\/$/;"	e	enum:__anon77	file:
MELSPEC	HTKLib/HParm.h	/^      MELSPEC,                         \/* Mel-Freq Spectrum (Linear) *\/$/;"	e	enum:_BaseParmKind
MERGE	HTKTools/HLEd.c	/^   REPLACE, CHANGE, FIND,   MERGE,  EDOP_DELETE, DEFCON, TRIST,  $/;"	e	enum:__anon141	file:
MERGEP	HTKTools/HDMan.c	/^              REPLACEP, CONREPLACE, MERGEP, SPLITP, DELETEP, DELSOURCE, $/;"	e	enum:__anon158	file:
MFCC	HTKLib/HParm.h	/^      MFCC,                            \/* Mel-Freq Cepstra *\/$/;"	e	enum:_BaseParmKind
MHEAP	HTKLib/HMem.h	/^typedef enum{MHEAP, MSTAK, CHEAP} HeapType;$/;"	e	enum:__anon72
MILink	HTKLib/HModel.h	/^typedef struct _MMFInfo *MILink;$/;"	t	typeref:struct:_MMFInfo
MIN	HTKLib/HArc.c	75;"	d	file:
MIN	HTKLib/HExactMPE.c	89;"	d	file:
MIN	HTKLib/HFBLat.c	73;"	d	file:
MIN	HTKTools/HHEd.c	5314;"	d	file:
MIN	HTKTools/HMMIRest.c	62;"	d	file:
MINDLOGP	HTKLib/HModel.h	55;"	d
MINEARG	HTKLib/HMath.h	44;"	d
MINLARG	HTKLib/HMath.h	45;"	d
MINMIX	HTKLib/HModel.h	52;"	d
MINOUT	HTKLib/HNLM.c	91;"	d	file:
MINPRONPROB	HTKLib/HDict.h	38;"	d
MINVAR	HTKLib/HUtil.c	405;"	d	file:
MIN_AMPL	HTKTools/HSLab.c	86;"	d	file:
MIN_BOWT	HLMLib/LModel.h	68;"	d
MIN_PB_SIZE	HTKLib/HParm.c	483;"	d	file:
MIN_PROB	HLMLib/LModel.c	219;"	d	file:
MIXBASE	HTKLib/HModel.h	/^enum _BaseClassKind {MIXBASE, MEANBASE, COVBASE};$/;"	e	enum:_BaseClassKind
MIXER_DEV	HTKLib/HAudio.c	127;"	d	file:
MIXTURE	HTKLib/HModel.c	/^   STATE, TMIX, MIXTURE, STREAM, SWEIGHTS,$/;"	e	enum:__anon40	file:
MIX_KEY	HTKLib/HUtil.c	/^   MIX_KEY, MEAN_KEY, STREAM_KEY, COV_KEY$/;"	e	enum:__anon132	file:
MIX_UPDATE_SHARING	HTKLib/HTrain.h	235;"	d
MInfo	HTKLib/HAdapt.c	/^} MInfo;$/;"	t	typeref:struct:__anon93	file:
MLF Examples	HTKBook/labels.tex	/^the form \\texttt{*\/file} to be generated.\\index{master label files!patterns}$/;"	u
MLF Search	HTKBook/labels.tex	/^A string is any sequence of characters enclosed in double quotes.$/;"	u
MLFCHUNKSIZE	HTKLib/HLabel.c	114;"	d	file:
MLFDef	HTKLib/HLabel.h	/^}MLFDef;$/;"	t	typeref:union:__anon118
MLFDefType	HTKLib/HLabel.h	/^typedef enum _MLFDefType MLFDefType;$/;"	t	typeref:enum:_MLFDefType
MLFEntry	HTKLib/HLabel.h	/^}MLFEntry;$/;"	t	typeref:struct:_MLFEntry
MLFHash	HTKLib/HLabel.c	/^static unsigned MLFHash(char *s)$/;"	f	file:
MLFPatType	HTKLib/HLabel.h	/^typedef enum _MLFPatType MLFPatType;$/;"	t	typeref:enum:_MLFPatType
MLF_FULL	HTKLib/HLabel.h	/^   MLF_IMMEDIATE, MLF_SIMPLE, MLF_FULL$/;"	e	enum:_MLFDefType
MLF_IMMEDIATE	HTKLib/HLabel.h	/^   MLF_IMMEDIATE, MLF_SIMPLE, MLF_FULL$/;"	e	enum:_MLFDefType
MLF_SIMPLE	HTKLib/HLabel.h	/^   MLF_IMMEDIATE, MLF_SIMPLE, MLF_FULL$/;"	e	enum:_MLFDefType
MLL	HLMTools/LLink.c	90;"	d	file:
MLLRCOV	HTKLib/HModel.h	/^enum _XFormKind {MLLRMEAN, MLLRCOV, MLLRVAR, CMLLR, SEMIT};$/;"	e	enum:_XFormKind
MLLRMEAN	HTKLib/HModel.h	/^enum _XFormKind {MLLRMEAN, MLLRCOV, MLLRVAR, CMLLR, SEMIT};$/;"	e	enum:_XFormKind
MLLRVAR	HTKLib/HModel.h	/^enum _XFormKind {MLLRMEAN, MLLRCOV, MLLRVAR, CMLLR, SEMIT};$/;"	e	enum:_XFormKind
MLPLM	HTKLib/HLM.h	/^} MLPLM;$/;"	t	typeref:struct:mlplm
MLPLMPROBNORM_OOS	HTKLib/HLM.h	66;"	d
MLPLMPROBNORM_OOS	HTKLib/HLM.h	71;"	d
MLPWeightFile	HTKLib/HNLM.h	/^} MLPWeightFile;$/;"	t	typeref:struct:mlpweightfile
MLP_NSIZE	HTKLib/HNLM.h	68;"	d
MLUpdateModels	HTKTools/HERest.c	/^void MLUpdateModels(HMMSet *hset, UPDSet uFlags)$/;"	f
ML_MODE	HTKTools/HMMIRest.c	/^static Boolean ML_MODE = FALSE;     \/* when only one set of accs are supplied. *\/$/;"	v	file:
ML_PARTS	HTKLib/HParm.c	/^   ML_PARTS=10$/;"	e	enum:__anon80	file:
ML_SIL_EN	HTKLib/HParm.c	/^   ML_SIL_EN=3,$/;"	e	enum:__anon80	file:
ML_SIL_ST	HTKLib/HParm.c	/^   ML_SIL_ST=2,$/;"	e	enum:__anon80	file:
ML_SP_EN	HTKLib/HParm.c	/^   ML_SP_EN=9,$/;"	e	enum:__anon80	file:
ML_SP_ST	HTKLib/HParm.c	/^   ML_SP_ST=8,$/;"	e	enum:__anon80	file:
MLink	HTKLib/HModel.h	/^typedef struct _MacroDef *MLink;$/;"	t	typeref:struct:_MacroDef
MM	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon168	file:
MMAPI_AUDIO	HTKLib/HAudio.c	62;"	d	file:
MMAPI_AUDIO	HTKLib/HAudio.c	69;"	d	file:
MMAPI_BUFFER_COUNT	HTKLib/HAudio.c	169;"	d	file:
MMAPI_BUFFER_DURATION	HTKLib/HAudio.c	168;"	d	file:
MMFIDMASK	HTKLib/HModel.c	/^   CLASS, XFORMWGTSET, CLASSXFORM, MMFIDMASK, PARAMETERS,$/;"	e	enum:__anon40	file:
MMFInfo	HTKLib/HModel.h	/^} MMFInfo;$/;"	t	typeref:struct:_MMFInfo
MMIPrior	HTKTools/HMMIRest.c	/^static Boolean MMIPrior = FALSE;    \/* use MMI prior as I-smoothing prior *\/$/;"	v	file:
MMITauI	HTKTools/HMMIRest.c	/^static float MMITauI = 0.0;        \/* I-smoothing tau for MMI prior in MPE training *\/$/;"	v	file:
MOutP	HTKLib/HModel.c	/^LogFloat MOutP(Vector x, MixPDF *mp)$/;"	f
MPE	HTKLib/HFBLat.h	/^  Boolean MPE;  \/* currently doing MPE\/MWE, this may change from call to call$/;"	m	struct:__anon54
MPE	HTKTools/HMMIRest.c	/^static Boolean MPE = FALSE;         \/* when we are doing MPE\/MWE. *\/$/;"	v	file:
MPEFileLength	HTKLib/HFBLat.h	/^  int MPEFileLength;$/;"	m	struct:__anon54
MPEStoreML	HTKTools/HMMIRest.c	/^static Boolean MPEStoreML=FALSE;   \/*  Set TRUE if we need to accumulate ML stats while doing MPE. *\/$/;"	v	file:
MPEStruct	HTKLib/HArc.h	/^} MPEStruct;$/;"	t	typeref:struct:_MPEStruct
MPE_GetFileLen	HTKLib/HFBLat.c	/^int MPE_GetFileLen(Lattice *lat){$/;"	f
MRound	HTKLib/HMem.c	/^size_t MRound(size_t size)$/;"	f
MSTAK	HTKLib/HMem.h	/^typedef enum{MHEAP, MSTAK, CHEAP} HeapType;$/;"	e	enum:__anon72
MSolve	HTKLib/HMath.c	/^static void MSolve(DMatrix L, int i, DVector x, DVector y)$/;"	f	file:
MT	HTKTools/HHEd.c	/^                         TC , UT , MT , SH , SU , SW , SK ,$/;"	e	enum:__anon168	file:
MU	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon168	file:
M_LN10	HTKLib/HRNLM.c	64;"	d	file:
M_LN2	HTKLib/HRNLM.c	63;"	d	file:
MacroDef	HTKLib/HModel.h	/^} MacroDef;$/;"	t	typeref:struct:_MacroDef
MakeDictionary	HLMTools/HLMCopy.c	/^void MakeDictionary(char *fn,dictList *dicts,Vocab *wlist)$/;"	f
MakeFN	HTKLib/HShell.c	/^char * MakeFN(char *fn, char *path, char *ext, char *s)$/;"	f
MakeFindAccumulator	HTKTools/HLEd.c	/^void MakeFindAccumulator(LabId *pat)$/;"	f
MakeHMMSet	HTKLib/HModel.c	/^ReturnStatus MakeHMMSet(HMMSet *hset, char *fname)$/;"	f
MakeHashTab	HTKLib/HModel.c	/^void ** MakeHashTab(HMMSet *hset, int size)$/;"	f
MakeHeaderInfo	HTKLib/HWave.c	/^static ReturnStatus MakeHeaderInfo(FILE *f, int hdrSize, Wave w)$/;"	f	file:
MakeIOConfig	HTKLib/HParm.c	/^static IOConfig MakeIOConfig(MemHeap *x,ChannelInfo *chan)$/;"	f	file:
MakeIntoMacrosCommand	HTKTools/HHEd.c	/^void MakeIntoMacrosCommand(void)$/;"	f
MakeNewClass	HLMLib/LCMap.c	/^ClassEntry *MakeNewClass(ClassMap *c, LabId id, int clndx, Boolean inClass)$/;"	f
MakeObservation	HTKLib/HParm.c	/^Observation MakeObservation(MemHeap *x, short *swidth, $/;"	f
MakeOneHMM	HTKLib/HModel.c	/^ReturnStatus MakeOneHMM(HMMSet *hset, char *hname)$/;"	f
MakePredLinks	HTKTools/HParse.c	/^static void MakePredLinks(int numElements, LinkSet *asucc)$/;"	f	file:
MakeSuccLinks	HTKTools/HParse.c	/^static void MakeSuccLinks(int numElements, LinkSet *asucc)$/;"	f	file:
MakeTraceBack	HTKTools/HInit.c	/^void MakeTraceBack(int segLen)$/;"	f
MakeTriCommand	HTKTools/HHEd.c	/^void MakeTriCommand(void)$/;"	f
MakeTriId	HTKTools/HDMan.c	/^LabId MakeTriId(LabId l, LabId c, LabId r)$/;"	f
MakeTriId	HTKTools/HLEd.c	/^LabId MakeTriId(LabId l, LabId c, LabId r)$/;"	f
MakeTriList	HTKTools/HParse.c	/^static SplitName* MakeTriList(int numElements, LinkSet *asucc)$/;"	f	file:
MakeTriLoop	HTKTools/HParse.c	/^static void MakeTriLoop(Link *hd, Link *tl)$/;"	f	file:
MakeTriSubNets	HTKTools/HParse.c	/^static void MakeTriSubNets(LinkSet *asucc, int numElements, $/;"	f	file:
MakeVocabularyClass	HTKLib/HRNLM.c	/^static void MakeVocabularyClass(RNNLM* rnnlm)$/;"	f	file:
MakeWtAccLists	HTKTools/HSmooth.c	/^void MakeWtAccLists()$/;"	f
MakeXGraf	HTKLib/HGraf.c	/^void MakeXGraf(char *wname, int x, int y, int w, int h, int bw)$/;"	f
MakeXGraf	HTKLib/HGraf.null.c	/^void MakeXGraf(char *wname, int x, int y, int w, int h, int bw)$/;"	f
MakeXGraf	HTKLib/HGraf_WIN32.c	/^void MakeXGraf(char *wname, int x, int y, int w, int h, int bw)$/;"	f
MapEntry	HLMLib/LWMap.h	/^} MapEntry;$/;"	t	typeref:struct:MAPENTRY
MapTreeName	HTKTools/HHEd.c	/^void MapTreeName(char *buf) {$/;"	f
MarkBack	HTKLib/HRec.c	/^static void MarkBack(LNode *ln,int *nn)$/;"	f	file:
MarkPaths	HTKLib/HRec.c	/^static void MarkPaths(Path *path,int *nn,int *nl)$/;"	f	file:
MarkTree	HTKLib/HVQ.c	/^static void MarkTree(VQNode n, short *nid)$/;"	f	file:
MarkWordList	HLMLib/LWMap.c	/^void MarkWordList(WordMap *wl)$/;"	f
MaskMatch	HTKLib/HShell.c	/^Boolean MaskMatch(char *mask, char *spkr, char *str)$/;"	f
Mat2DMat	HTKLib/HMath.c	/^void Mat2DMat(Matrix m1,  DMatrix m2)$/;"	f
Mat2Tri	HTKLib/HMath.c	/^void Mat2Tri (Matrix m1,  TriMat m2)$/;"	f
MatBiLM	HTKLib/HLM.h	/^} MatBiLM;$/;"	t	typeref:struct:matbilm
MatCofact	HTKLib/HMath.c	/^double MatCofact(Matrix c, int r, Vector cofact)$/;"	f
MatDet	HTKLib/HMath.c	/^float MatDet(Matrix c)$/;"	f
MatHeader	HTKLib/HNLM.h	/^} MatHeader;$/;"	t	typeref:struct:matheader
MatInfo	HTKLib/HNLM.h	/^} MatInfo;$/;"	t	typeref:struct:matinfo
MatInvert	HTKLib/HMath.c	/^float MatInvert(Matrix c, Matrix invc)$/;"	f
MatTran	HTKLib/HParm.c	/^   Matrix MatTran;            \/* Stores transformation matrix *\/ $/;"	m	struct:__anon76	file:
MatTranFN	HTKLib/HParm.c	/^   char *MatTranFN;           \/* points to the file name string *\/$/;"	m	struct:__anon76	file:
MatchFiles	HTKTools/HResults.c	/^void MatchFiles(void)$/;"	f
MatchRecFiles	HTKTools/HResults.c	/^void MatchRecFiles(void)$/;"	f
MatchRule	HLMTools/LGPrep.c	/^Boolean MatchRule(RuleDef *r)$/;"	f
MatchSpotFiles	HTKTools/HResults.c	/^void MatchSpotFiles(void)$/;"	f
Matrix	HTKLib/HMem.h	/^typedef float **Matrix;    \/* matrix[1..nrows][1..ncols] *\/$/;"	t
MatrixElemSize	HTKLib/HMem.c	/^size_t MatrixElemSize(int nrows,int ncols)$/;"	f
MatrixIDFT	HTKLib/HSigP.c	/^float MatrixIDFT(Vector as, Vector ac, DMatrix cm)$/;"	f
MatrixMult	HTKLib/HAdapt.c	/^static void MatrixMult(Matrix m1, Matrix m2, Matrix m)$/;"	f	file:
MaxMixInS	HTKLib/HModel.c	/^int MaxMixInS(HLink hmm, int s)$/;"	f
MaxMixInSet	HTKLib/HModel.c	/^int MaxMixInSet(HMMSet *hset)$/;"	f
MaxMixInSetS	HTKLib/HModel.c	/^int MaxMixInSetS(HMMSet *hset, int s)$/;"	f
MaxMixtures	HTKLib/HModel.c	/^int MaxMixtures(HLink hmm)$/;"	f
MaxModelProb	HTKLib/HFB.c	/^static LogDouble MaxModelProb(AlphaBeta *ab, int q, int t, int minq)$/;"	f	file:
MaxStatesInSet	HTKLib/HModel.c	/^int MaxStatesInSet(HMMSet *hset)$/;"	f
MaxTimesLabelled	HTKTools/HSLab.c	/^int MaxTimesLabelled(LabList *ll, long st, long en)$/;"	f
MeanRec	HTKLib/HParm.c	/^MeanRec;$/;"	t	typeref:struct:meanrec	file:
Mel	HTKLib/HSigP.c	/^float Mel(int k,float fres)$/;"	f
MelSpec2FBank	HTKLib/HSigP.c	/^void MelSpec2FBank(Vector melspec)$/;"	f
MemHeap	HTKLib/HMem.h	/^}MemHeap;$/;"	t	typeref:struct:__anon73
MemHeapRec	HTKLib/HMem.c	/^} MemHeapRec;$/;"	t	typeref:struct:_MemHeapRec	file:
MergeArcs	HTKLib/HLat.c	/^void MergeArcs(Lattice *lat, LArc *la1, LArc *la2)$/;"	f
MergeArcsForNode	HTKLib/HLat.c	/^void MergeArcsForNode(Lattice *lat, LNode *ln)$/;"	f
MergeCost	HTKTools/HHEd.c	/^float MergeCost(Node *a, Node *b, CLink atail)$/;"	f
MergeFE	HLMLib/LPMerge.c	/^static int MergeFE(MergeInfo *mi, FLEntry **context, FLEntry **srcFE, int lev) $/;"	f	file:
MergeGroups	HTKTools/HHEd.c	/^void MergeGroups(int i, int j, CLink *cvec, int N)$/;"	f
MergeInfo	HLMLib/LPMerge.c	/^} MergeInfo;$/;"	t	typeref:struct:__anon1	file:
MergeLatNodesArcs	HTKLib/HLat.c	/^Lattice *MergeLatNodesArcs(Lattice *lat, MemHeap *heap, Boolean mergeFwd)$/;"	f
MergeLatNodesBackw	HTKLib/HLat.c	/^void MergeLatNodesBackw(Lattice *lat, LNode *ln)$/;"	f
MergeLatNodesForw	HTKLib/HLat.c	/^void MergeLatNodesForw(Lattice *lat, LNode *ln)$/;"	f
MergeLeaves	HTKTools/HHEd.c	/^void MergeLeaves(Tree *tree, float threshold)$/;"	f
MergeLevels	HTKTools/HLEd.c	/^LabList *MergeLevels(Transcription *ltr)$/;"	f
MergeLinks	HTKTools/HParse.c	/^static LinkSet*  MergeLinks(LinkSet *from, LinkSet *to)$/;"	f	file:
MergeMix	HTKTools/HHEd.c	/^void MergeMix(StreamElem *ste,int p,int q, Boolean inPlace)$/;"	f
MergeModels	HLMLib/LPMerge.c	/^BackOffLM *MergeModels(MemHeap *heap, LMInfo *lmInfo, int nLModel, $/;"	f
MergeNode	HTKTools/HHEd.c	/^Boolean MergeNode(Node *node, float threshold)$/;"	f
MergeNodes	HTKLib/HLat.c	/^static LNode *MergeNodes(Lattice *lat, LNode *ln1, LNode *ln2)$/;"	f	file:
MergeOp	HTKTools/HLEd.c	/^int MergeOp(LabList *ll,int nArgs, LabId *args)$/;"	f
MergePhon	HTKTools/HDMan.c	/^void MergePhon(Pronunciation *p, int nArgs, LabId *args)$/;"	f
MergePhoneOp	HTKTools/HDMan.c	/^void MergePhoneOp(WordBuf *wb, int nArgs, LabId *args)$/;"	f
MinGDist	HTKTools/HHEd.c	/^float MinGDist(Matrix g, int *ix, int *jx, int N)$/;"	f
MinOcc	HTKTools/HMMIRest.c	/^static float MinOcc = 10;              \/* Minimum numerator (ML) occupancy for a Gaussian to be updated *\/$/;"	v	file:
MinOccSum	HTKTools/HHEd.c	/^int MinOccSum(Vector occSum, int N)$/;"	f
MinOccTrans	HTKTools/HMMIRest.c	/^static float MinOccTrans = 10;         \/* Minimum numerator (ML) occupancy for a transition row *\/$/;"	v	file:
MinOccWeights	HTKTools/HMMIRest.c	/^static float MinOccWeights = 10;       \/* Minimum numerator (ML) occupancy for a set of weights. *\/$/;"	v	file:
MixDownCommand	HTKTools/HHEd.c	/^void MixDownCommand(void)$/;"	f
MixFloor	HTKLib/HModel.h	59;"	d
MixLogWeight	HTKLib/HModel.c	/^LogFloat MixLogWeight(HMMSet *hset, float weight)$/;"	f
MixMergeCost	HTKTools/HHEd.c	/^float MixMergeCost(MixtureElem *me1,MixtureElem *me2)$/;"	f
MixOcc	HTKLib/HFBLat.c	/^} MixOcc;$/;"	t	typeref:struct:__anon90	file:
MixPDF	HTKLib/HModel.h	/^} MixPDF;$/;"	t	typeref:struct:__anon56
MixUpCommand	HTKTools/HHEd.c	/^void MixUpCommand(void)$/;"	f
MixWeight	HTKLib/HModel.c	/^float MixWeight(HMMSet *hset, float weight)$/;"	f
MixtureElem	HTKLib/HModel.h	/^} MixtureElem;$/;"	t	typeref:struct:__anon57
MixtureVector	HTKLib/HModel.h	/^} MixtureVector; $/;"	t	typeref:union:__anon58
MouseMark	HTKTools/HSLab.c	/^void MouseMark(int x, int *markA, int *markB)$/;"	f
MousePos	HTKLib/HGraf_WIN32.c	/^static POINT MousePos;   \/* updated when a WM_MOUSEMOVE occurs *\/$/;"	v	file:
MoveAlignYesRef	HTKLib/HRec.c	/^static void MoveAlignYesRef(Align *align)$/;"	f	file:
MovePathYesRef	HTKLib/HRec.c	/^static void MovePathYesRef(Path *path)$/;"	f	file:
MoveToRecent	HTKLib/HRec.c	/^static void MoveToRecent(NetInst *inst)$/;"	f	file:
MuAcc	HTKLib/HTrain.h	/^} MuAcc;$/;"	t	typeref:struct:__anon113
MultCovMeanLinXForms	HTKLib/HAdapt.c	/^static void MultCovMeanLinXForms(LinXForm *xf1, LinXForm *xf2, LinXForm *xf)$/;"	f	file:
MustSwap	HTKLib/HWave.c	/^static Boolean MustSwap(SrcOrder so)$/;"	f	file:
N	HLMLib/LGBase.h	/^   int N;                  \/* N-gram *\/$/;"	m	struct:__anon7
N	HLMLib/LGBase.h	/^   int N;                  \/* N-gram size *\/$/;"	m	struct:__anon5
N	HLMLib/LGBase.h	/^   int N;                  \/* N-gram size N (2..MAXNG)*\/$/;"	m	struct:__anon3
N	HLMTools/Cluster.c	/^static int         N = 1000;                \/* Default number of classes *\/$/;"	v	file:
N	HTKLib/HUtil.h	/^   int N;            \/* num states in curret hmm *\/$/;"	m	struct:__anon38
NAMESYM	HTKTools/HParse.c	/^enum _Symbol{NAMESYM, VARSYM, VARATSYM, LPARSYM, RPARSYM, LBRACESYM, $/;"	e	enum:_Symbol	file:
NARC	HTKLib/HNet.h	100;"	d
NATIVE	HTKLib/esignal.h	105;"	d
NBIN	HTKLib/HLat.c	746;"	d	file:
NBestEntry	HTKLib/HRec.c	/^typedef struct nbestentry NBestEntry;$/;"	t	typeref:struct:nbestentry	file:
NC	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon168	file:
NDUR	HTKLib/HModel.c	/^   NDUR, PDUR, GDUR, RELDUR, GENDUR,$/;"	e	enum:__anon40	file:
NEntry	HTKLib/HLM.h	/^} NEntry;$/;"	t	typeref:struct:nentry
NGBuffer	HLMLib/LGBase.h	/^} NGBuffer;$/;"	t	typeref:struct:__anon6
NGHSIZE1	HTKLib/HLM.c	662;"	d	file:
NGHSIZE2	HTKLib/HLM.c	663;"	d	file:
NGHSIZE3	HTKLib/HLM.c	664;"	d	file:
NGHSIZE4	HTKLib/HLM.c	665;"	d	file:
NGInfo	HLMLib/LGBase.h	/^}NGInfo;$/;"	t	typeref:struct:__anon3
NGInputSet	HLMLib/LGBase.h	/^}NGInputSet;$/;"	t	typeref:struct:__anon5
NGSource	HLMLib/LGBase.h	/^}NGSource;$/;"	t	typeref:struct:__anon4
NGram	HLMLib/LGBase.h	/^typedef UInt *NGram;          \/* N-gram: {w1,w2,...,wN count} *\/$/;"	t
NGramExpand	HLMLib/LGBase.c	/^void NGramExpand(int N, Byte *comp, NGram ng)$/;"	f
NGramInfo	HLMLib/LModel.h	/^} NGramInfo;$/;"	t	typeref:struct:__anon14
NGramLM	HTKLib/HLM.h	/^} NGramLM;$/;"	t	typeref:struct:ngramlm
NGramSquash	HLMLib/LGBase.c	/^void NGramSquash(int N, NGram ng, Byte *comp)$/;"	f
NIL	HTKTools/HResults.c	/^enum _Direction{DIAG,VERT,HOR,NIL};$/;"	e	enum:_Direction	file:
NIST	HTKLib/HWave.h	/^        NIST,              \/* NIST databases eg RM1,TIMIT *\/$/;"	e	enum:__anon36
NISTSkipLine	HTKLib/HWave.c	/^static void NISTSkipLine(FILE *f)$/;"	f	file:
NISTmutab	HTKLib/HWave.c	/^static short int NISTmutab[256] = {$/;"	v	file:
NNLM	HTKLib/HNLM.h	/^} NNLM;$/;"	t	typeref:struct:nnlm
NNODE	HTKLib/HNet.h	101;"	d
NOARG	HTKLib/HShell.h	/^typedef enum {SWITCHARG, STRINGARG, INTARG, FLOATARG, NOARG} ArgKind;$/;"	e	enum:__anon88
NOCMD	HTKTools/HDMan.c	/^              NOCMD} EdOp;$/;"	e	enum:__anon158	file:
NOCMD	HTKTools/HLEd.c	/^   NOCMD=0, $/;"	e	enum:__anon141	file:
NODE	HTKLib/HModel.c	/^   RCLASS=110, REGTREE, NODE, TNODE,$/;"	e	enum:__anon40	file:
NODEBLOCK	HTKTools/HParse.c	279;"	d	file:
NOHEAD	HTKLib/HWave.h	/^        NOHEAD,            \/* Headerless File *\/$/;"	e	enum:__anon36
NOPRUNE	HTKLib/HFB.h	31;"	d
NORMALKEY	HTKLib/HGraf.h	/^enum _KeyType {NORMALKEY, SHIFTKEY, COMMANDKEY, CONTROLKEY, $/;"	e	enum:_KeyType
NO_AUDIO	HTKLib/HAudio.c	58;"	d	file:
NO_HDR	HLMLib/LUtil.h	/^   NO_HDR, WMAP_HDR, CMAP_HDR, GRAM_HDR, LFOF_HDR$/;"	e	enum:__anon22
NO_OF_FONTS	HTKLib/HGraf.c	134;"	d	file:
NO_TYPE	HTKLib/esignal.h	64;"	d
NO_WIN	HTKTools/HSLab.c	/^   WAVE_WIN, LAB_WIN, IO_WIN, NO_WIN $/;"	e	enum:__anon143	file:
NSIZE	HTKLib/HLM.h	87;"	d
NULLC	HTKLib/HMath.h	/^   NULLC,         \/* none - implies Euclidean in distance metrics *\/$/;"	e	enum:__anon43
NULLD	HTKLib/HModel.h	/^enum _DurKind {NULLD, POISSOND, GAMMAD, RELD, GEND};$/;"	e	enum:_DurKind
NULLSIG	HTKLib/HAudio.h	31;"	d
NULLSYM	HTKLib/HModel.c	/^   MACRO, EOFSYM, NULLSYM   \/* Special Syms - not literals *\/$/;"	e	enum:__anon40	file:
NUMCEPS	HTKLib/HParm.c	/^   NUMCEPS,       \/* Num cepstral coefficients *\/$/;"	e	enum:__anon77	file:
NUMCHANS	HTKLib/HParm.c	/^   NUMCHANS,      \/* Num filterbank channels *\/$/;"	e	enum:__anon77	file:
NUMCKIND	HTKLib/HMath.h	/^   NUMCKIND       \/* DON'T TOUCH -- always leave as final element *\/$/;"	e	enum:__anon43
NUMCLASSES	HTKLib/HModel.c	/^   NUMCLASSES, ADAPTKIND, PREQUAL, INPUTXFORM,$/;"	e	enum:__anon40	file:
NUMMIXES	HTKLib/HModel.c	/^   BEGINHMM, USEMAC, ENDHMM, NUMMIXES, $/;"	e	enum:__anon40	file:
NUMSTATES	HTKLib/HModel.c	/^   NUMSTATES, STREAMINFO, VECSIZE, $/;"	e	enum:__anon40	file:
NUMSYM	HTKLib/HModel.c	455;"	d	file:
NUMXFORMS	HTKLib/HModel.c	/^   XFORMKIND=90, PARENTXFORM, NUMXFORMS, XFORMSET,$/;"	e	enum:__anon40	file:
NUM_OF_SCALES	HTKTools/HSLab.c	101;"	d	file:
NUM_SAMP_FREQS	HTKLib/HAudio.c	318;"	d	file:
NameCell	HTKLib/HLabel.h	/^}NameCell;$/;"	t	typeref:struct:_NameCell
NameHolder	HLMLib/LUtil.h	/^}NameHolder;$/;"	t	typeref:struct:_NameHolder
NameId	HLMLib/LUtil.h	/^typedef NameHolder *NameId;    \/* Internal representation of names *\/$/;"	t
NameOf	HTKLib/HShell.c	/^char * NameOf(char *fn, char *s)$/;"	f
NativeRead	HTKLib/esig_nat.c	/^NativeRead(void *data,$/;"	f	file:
NativeRecordSize	HTKLib/esig_nat.c	/^NativeRecordSize(FieldList list)$/;"	f
NativeTypeSize	HTKLib/esig_nat.c	/^NativeTypeSize(int type   \/* numeric data-type code *\/ )$/;"	f
NativeWrite	HTKLib/esig_nat.c	/^NativeWrite(void    *data,$/;"	f	file:
NetFilter	HTKLib/HShell.h	/^   NetFilter,       \/* Network file input via HNet *\/$/;"	e	enum:__anon83
NetInst	HTKLib/HNet.h	/^typedef struct _NetInst NetInst;$/;"	t	typeref:struct:_NetInst
NetLink	HTKLib/HNet.h	/^typedef struct _NetLink NetLink;$/;"	t	typeref:struct:_NetLink
NetNode	HTKLib/HNet.h	/^typedef struct _NetNode NetNode;$/;"	t	typeref:struct:_NetNode
NetNodeType	HTKLib/HNet.h	/^typedef int NetNodeType; $/;"	t
NetOFilter	HTKLib/HShell.h	/^   NetOFilter,      \/* Network file output via HNet *\/$/;"	e	enum:__anon83
Network	HTKLib/HNet.h	/^} Network;$/;"	t	typeref:struct:__anon128
New	HTKLib/HMem.c	/^void *New(MemHeap *x,size_t size)$/;"	f
NewBetaVec	HTKLib/HFB.c	/^static DVector NewBetaVec(MemHeap *x, int N)$/;"	f	file:
NewCell	HTKLib/HLabel.c	/^static NameCell *NewCell(char *name)$/;"	f	file:
NewFieldSpec	HTKLib/esignal.c	/^NewFieldSpec(int    type,       \/* numeric code for data type *\/$/;"	f
NewHMMScan	HTKLib/HUtil.c	/^void NewHMMScan(HMMSet *hset, HMMScanState *hss)$/;"	f
NewHMMSetCxtInfo	HTKLib/HNet.c	/^static HMMSetCxtInfo *NewHMMSetCxtInfo(HMMSet *hset, Boolean frcCxtInd)$/;"	f	file:
NewHolder	HLMLib/LUtil.c	/^static NameHolder *NewHolder(char *name)$/;"	f	file:
NewILattice	HTKLib/HNet.c	/^Lattice *NewILattice(MemHeap *heap,int nn,int na,Lattice *info)$/;"	f
NewItemBlock	HTKLib/HTrain.c	/^static IBLink NewItemBlock(MemHeap *x, int blkSize)$/;"	f	file:
NewLattice	HTKLib/HNet.c	/^Lattice *NewLattice(MemHeap *heap,int nn,int na)$/;"	f
NewMacro	HTKLib/HModel.c	/^MLink NewMacro(HMMSet *hset, short fidx, char type, LabId id, Ptr structure)$/;"	f
NewNRefAlign	HTKLib/HRec.c	/^static Align *NewNRefAlign(NetNode *node,int state,double like,$/;"	f	file:
NewNRefPath	HTKLib/HRec.c	/^static Path *NewNRefPath(void)$/;"	f	file:
NewNode	HTKLib/HNet.c	/^static NetNode *NewNode(MemHeap *heap,HLink hmm,int nlinks)$/;"	f	file:
NewOtprobVec	HTKLib/HFB.c	/^static float * NewOtprobVec(MemHeap *x, int M)$/;"	f	file:
NewOtprobVec	HTKLib/HFBLat.c	/^static float * NewOtprobVec(MemHeap *x, int M)$/;"	f	file:
NewPron	HTKLib/HDict.c	/^void NewPron(Vocab *voc, Word wid, int nphones, LabId *phones, $/;"	f
NewPronHolder	HTKLib/HNet.c	/^static PronHolder *NewPronHolder(MemHeap *heap,HMMSetCxtInfo *hci,$/;"	f	file:
NewString	HTKLib/HMem.c	/^char *NewString(MemHeap *x, int size)$/;"	f
NewWord	HTKLib/HDict.c	/^static Word NewWord(Vocab *voc, LabId wordName)$/;"	f	file:
NextArg	HTKLib/HShell.c	/^ArgKind NextArg(void)$/;"	f
NextLArc	HTKLib/HNet.h	249;"	d
NextWord	HLMTools/LGPrep.c	/^char * NextWord(char *s, char *word)$/;"	f
NoFilter	HTKLib/HShell.h	/^   NoFilter,        \/* Direct input - no pipe *\/$/;"	e	enum:__anon83
NoMLFHeader	HTKLib/HLabel.c	/^static Boolean NoMLFHeader(char *s)$/;"	f	file:
NoOFilter	HTKLib/HShell.h	/^   NoOFilter        \/* Direct output - no pipe *\/$/;"	e	enum:__anon83
NoSilence	HTKLib/HFBLat.c	/^static Boolean NoSilence = FALSE;                      \/* If TRUE, then (in non-exact MPE) the silences are omitted from the reference transcription$/;"	v	file:
Node	HTKTools/HHEd.c	/^}Node;$/;"	t	typeref:struct:_Node	file:
Node	HTKTools/HParse.c	/^} Node;$/;"	t	typeref:struct:_Node	file:
NodeId	HTKLib/HNet.h	/^typedef struct lnode *NodeId;$/;"	t	typeref:struct:lnode
NodeInfo	HTKTools/HParse.c	/^}NodeInfo;$/;"	t	typeref:struct:_NodeInfo	file:
NodeType	HTKTools/HParse.c	/^typedef enum {unknown, wdInternal, wdExternal, wdBegin, wdEnd, nullNode} NodeType;$/;"	t	typeref:enum:__anon156	file:
NonSil_and_Quinphone_IsStartPhone	HTKLib/HExactMPE.c	/^Boolean NonSil_and_Quinphone_IsStartPhone(LArc *larc, int i){$/;"	f
NonSkipRegion	HTKLib/HFB.c	/^static Boolean NonSkipRegion(int skipstart, int skipend, int t)$/;"	f	file:
NormaliseFE	HLMLib/LPMerge.c	/^static void NormaliseFE(FLEntry *tgtFE)$/;"	f	file:
NormaliseLM	HLMLib/LPMerge.c	/^void NormaliseLM(BackOffLM *lm) $/;"	f
NormaliseLogEnergy	HTKLib/HSigP.c	/^void NormaliseLogEnergy(float *data,int n,int step,float silFloor,float escale)$/;"	f
NormaliseName	HTKTools/HResults.c	/^void NormaliseName(LabList *ll,int lev)$/;"	f
NotLinked	HTKTools/HParse.c	/^static Boolean NotLinked(LinkSet *ls, Link x)$/;"	f	file:
Nq	HTKLib/HArc.h	/^  int Nq;$/;"	m	struct:_Acoustic
NumAccs	HTKTools/HMMIRest.c	/^static int NumAccs;                \/*  Set in Initialise() to  1 or 2 or 3. *\/$/;"	v	file:
NumArgs	HTKLib/HShell.c	/^int  NumArgs(void)$/;"	f
NumAuxCases	HTKLib/HLabel.c	/^int NumAuxCases(LabList *ll, LabId id, int i)$/;"	f
NumCases	HTKLib/HLabel.c	/^int NumCases(LabList *ll, LabId id)$/;"	f
NumCols	HTKLib/HMem.c	/^int NumCols(Matrix m)$/;"	f
NumDCols	HTKLib/HMem.c	/^int NumDCols(DMatrix m)$/;"	f
NumDRows	HTKLib/HMem.c	/^int NumDRows(DMatrix m)$/;"	f
NumEnergy	HTKLib/HParm.c	/^static int NumEnergy(ParmKind pk)$/;"	f	file:
NumEquiv	HLMTools/LPlex.c	/^static int NumEquiv(void)$/;"	f	file:
NumFrame	HTKTools/HCompV.c	/^   int NumFrame;                         \/* number of frames for speaker *\/$/;"	m	struct:__anon152	file:
NumHead	HTKLib/HShell.c	/^static Boolean NumHead(char *s)$/;"	f	file:
NumItems	HTKLib/HUtil.c	/^int NumItems(ILink list)$/;"	f
NumJPreds	HTKTools/HParse.c	/^static int NumJPreds(int a)$/;"	f	file:
NumJSuccs	HTKTools/HParse.c	/^static int NumJSuccs(int a)$/;"	f	file:
NumLMHdrFields	HLMLib/LUtil.c	/^int NumLMHdrFields(LMFileHdr hdr)$/;"	f
NumLines	HLMLib/LUtil.c	/^static int NumLines(Source *src, IOFilter filter)$/;"	f	file:
NumMLFEntries	HTKLib/HLabel.c	/^int NumMLFEntries(void)$/;"	f
NumMLFFiles	HTKLib/HLabel.c	/^int NumMLFFiles(void)$/;"	f
NumNodeFoll	HTKLib/HNet.c	/^int NumNodeFoll(NodeId n)$/;"	f
NumNodePred	HTKLib/HNet.c	/^int NumNodePred(NodeId n)$/;"	f
NumParts	HTKTools/HLEd.c	/^int NumParts(LabId id)$/;"	f
NumRows	HTKLib/HMem.c	/^int NumRows(Matrix m)$/;"	f
NumSegs	HTKLib/HTrain.c	/^int NumSegs(SegStore ss)$/;"	f
NumStatic	HTKLib/HParm.c	/^static int NumStatic(int nTotal, ParmKind pk)$/;"	f	file:
NumTreeNodes	HTKLib/HTrain.c	/^static int NumTreeNodes(int nc)$/;"	f	file:
NumbLArc	HTKLib/HNet.h	242;"	d
NumberBytes	HTKLib/HWave.c	/^static long NumberBytes(FILE *f, int hSize, Boolean isPipe)$/;"	f	file:
NumberEntries	HTKTools/HBuild.c	/^void NumberEntries(WPGrammar *wpg, Word sentEnd)$/;"	f
NxtPath	HTKLib/HRec.h	/^typedef struct nxtpath NxtPath;    \/* NBest traceback route (HRec.c) *\/$/;"	t	typeref:struct:nxtpath
OBEXPFORM	HTKLib/HParm.c	2929;"	d	file:
OBFLTFORM	HTKLib/HParm.c	2928;"	d	file:
OBMARGIN	HTKLib/HParm.c	2927;"	d	file:
OFFSET	HTKLib/HModel.c	/^   LINXFORM, OFFSET, BIAS, LOGDET, BLOCKINFO, BLOCK, BASECLASS, $/;"	e	enum:__anon40	file:
OGI	HTKLib/HWave.h	/^        OGI,               \/* Oregon Institute format (similar to TIMIT) *\/$/;"	e	enum:__anon36
OGIhdr	HTKLib/HWave.c	/^} OGIhdr;$/;"	t	typeref:struct:__anon101	file:
OOS_NODE	HTKLib/HNLM.c	49;"	d	file:
OOVEntry	HLMTools/LPlex.c	/^} OOVEntry;$/;"	t	typeref:struct:__anon32	file:
OPTIONAL	HTKLib/esignal.h	91;"	d
ORANGE	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	e	enum:_HColour
OSS_AUDIO	HTKLib/HAudio.c	54;"	d	file:
OUTSILWARN	HTKLib/HParm.c	/^   OUTSILWARN,    \/* Output Warning before Measure Sil *\/$/;"	e	enum:__anon77	file:
OWarn	HTKLib/HModel.c	/^static void OWarn(HMMSet *hset,Boolean equal,char *opt)$/;"	f	file:
ObsCache	HTKLib/HAdapt.c	/^} ObsCache;                        \/* observation cache to save rotated observations *\/$/;"	t	typeref:struct:_ObsCache	file:
ObsInBuffer	HTKLib/HParm.c	/^int ObsInBuffer(ParmBuf pbuf)$/;"	f
Observation	HTKLib/HParm.h	/^} Observation;$/;"	t	typeref:struct:__anon120
OpType	HTKTools/HSLab.c	/^} OpType;$/;"	t	typeref:enum:__anon146	file:
OpenAsChannel	HTKLib/HParm.c	/^static ReturnStatus OpenAsChannel(ParmBuf pbuf, int maxObs, $/;"	f	file:
OpenAudioInput	HTKLib/HAudio.c	/^AudioIn OpenAudioInput(MemHeap *x, HTime *sampPeriod, HTime winDur, HTime frPeriod)$/;"	f
OpenAudioOutput	HTKLib/HAudio.c	/^AudioOut OpenAudioOutput(MemHeap *x, HTime *sampPeriod)$/;"	f
OpenBuffer	HTKLib/HParm.c	/^ParmBuf OpenBuffer(MemHeap *x, char *fn, int maxObs, FileFormat ff, $/;"	f
OpenExtBuffer	HTKLib/HParm.c	/^ParmBuf OpenExtBuffer(MemHeap *x, char *fn, int maxObs, $/;"	f
OpenIn	HTKLib/esignal.c	/^OpenIn(char     *filename,      \/* name of input file *\/$/;"	f
OpenInputSet	HLMLib/LGBase.c	/^void OpenInputSet(NGInputSet *inset)$/;"	f
OpenLLF	HTKLib/HLat.c	/^LLFInfo *OpenLLF (char *fn)$/;"	f
OpenLabFile	HTKLib/HLabel.c	/^static FILE * OpenLabFile(char *fname, Boolean *isMLF)$/;"	f	file:
OpenNGramFile	HLMLib/LGBase.c	/^void OpenNGramFile(NGSource *ngs, char *fn, WordMap *wm)$/;"	f
OpenOut	HTKLib/esignal.c	/^OpenOut(char        *filename,$/;"	f
OpenParmChannel	HTKLib/HParm.c	/^static ReturnStatus OpenParmChannel(ParmBuf pbuf,char *fname, int *ret_val)$/;"	f	file:
OpenParmFile	HTKTools/HCopy.c	/^HTime OpenParmFile(char *src)$/;"	f
OpenSpeechFile	HTKTools/HCopy.c	/^void OpenSpeechFile(char *s)$/;"	f
OpenWaveFile	HTKTools/HCopy.c	/^HTime OpenWaveFile(char *src)$/;"	f
OpenWaveInput	HTKLib/HWave.c	/^Wave OpenWaveInput(MemHeap *x, char *fname, FileFormat fmt, HTime winDur, $/;"	f
OpenWaveOutput	HTKLib/HWave.c	/^Wave OpenWaveOutput(MemHeap *x, HTime *sampPeriod, long bufSize)$/;"	f
Option 1 - Recognition	HTKBook/exampsys.tex	/^and stored in a file \\texttt{bg\\_lm.gz} in the ARPA-MIT format.$/;"	u
Option 2 - Speaker Adaptation	HTKBook/exampsys.tex	/^option).$/;"	u
Option 3 - Lattice Generation	HTKBook/exampsys.tex	/^The recognition output is written to  \\texttt{recoutAdapt.mlf}.$/;"	u
Option 4 - Lattice Rescoring	HTKBook/exampsys.tex	/^found to make lattice generation more robust.$/;"	u
OutConMat	HTKTools/HResults.c	/^void OutConMat(void)$/;"	f
OutMLFEntry	HTKLib/HLabel.c	/^} OutMLFEntry;$/;"	t	typeref:struct:__anon135	file:
OutMacro	HTKTools/HHEd.c	/^void OutMacro(char type,Ptr structure)$/;"	f
OutP	HTKLib/HModel.c	/^LogFloat OutP(Observation *x, HLink hmm, int state)$/;"	f
OutSamples	HTKLib/HAudio.c	/^static int OutSamples(AudioOut a)$/;"	f	file:
OutString	HLMLib/LCMap.c	/^static void OutString(FILE *f, Boolean htkEsc, LabId id)$/;"	f	file:
OutTrans	HTKTools/HResults.c	/^void OutTrans(void)$/;"	f
OutputAlign	HTKLib/HNet.c	/^static void OutputAlign(LArc *la,int format,FILE *file)$/;"	f	file:
OutputBoBigram	HTKTools/HLStats.c	/^void OutputBoBigram(void)$/;"	f
OutputCounts	HTKTools/HLStats.c	/^void OutputCounts(void)$/;"	f
OutputDurs	HTKTools/HLStats.c	/^void OutputDurs(void)$/;"	f
OutputFloatField	HTKLib/HNet.c	/^static void OutputFloatField(char field,float val,Boolean bin,$/;"	f	file:
OutputIntField	HTKLib/HNet.c	/^static void OutputIntField(char field,int val,Boolean bin,$/;"	f	file:
OutputList	HTKTools/HLStats.c	/^void OutputList(void)$/;"	f
OutputMatBigram	HTKTools/HLStats.c	/^void OutputMatBigram(void)$/;"	f
OutputSpotStats	HTKTools/HResults.c	/^void OutputSpotStats(void)$/;"	f
OutputStats	HTKTools/HLStats.c	/^void OutputStats(void)$/;"	f
OutputStats	HTKTools/HResults.c	/^void OutputStats(void)$/;"	f
P	HTKTools/HMMIRest.c	/^static int P;                        \/* number of physical HMM's *\/$/;"	v	file:
PARAMETERS	HTKLib/HModel.c	/^   CLASS, XFORMWGTSET, CLASSXFORM, MMFIDMASK, PARAMETERS,$/;"	e	enum:__anon40	file:
PARENTXFORM	HTKLib/HModel.c	/^   XFORMKIND=90, PARENTXFORM, NUMXFORMS, XFORMSET,$/;"	e	enum:__anon40	file:
PARMKIND	HTKLib/HModel.c	/^   PARMKIND=120, $/;"	e	enum:__anon40	file:
PATHCHAR	HTKLib/HShell.h	482;"	d
PATHCHAR	HTKLib/HShell.h	485;"	d
PATHCHAR	HTKLib/HShell.h	488;"	d
PATHCHAR	HTKLib/HShell.h	492;"	d
PAT_ANYPATH	HTKLib/HLabel.h	/^   PAT_ANYPATH,   \/* pat is "* \/ name" and name is hashed *\/$/;"	e	enum:_MLFPatType
PAT_FIXED	HTKLib/HLabel.h	/^   PAT_FIXED,     \/* whole "pattern" is hashed *\/$/;"	e	enum:_MLFPatType
PAT_GENERAL	HTKLib/HLabel.h	/^   PAT_GENERAL    \/* general pattern - no hashing *\/$/;"	e	enum:_MLFPatType
PAT_LEN	HTKLib/HUtil.c	619;"	d	file:
PBStatus	HTKLib/HParm.h	/^} PBStatus;$/;"	t	typeref:enum:__anon121
PB_CLEARED	HTKLib/HParm.h	/^   PB_CLEARED   \/* Buffer has been emptied *\/$/;"	e	enum:__anon121
PB_FILLING	HTKLib/HParm.h	/^   PB_FILLING,  \/* Buffer is filling *\/$/;"	e	enum:__anon121
PB_INIT	HTKLib/HParm.h	/^   PB_INIT,     \/* Buffer is initialised and empty *\/$/;"	e	enum:__anon121
PB_STOPPED	HTKLib/HParm.h	/^   PB_STOPPED,  \/* Buffer has stopped but not yet empty *\/$/;"	e	enum:__anon121
PB_STOPPING	HTKLib/HParm.h	/^   PB_STOPPING, \/* Buffer is waiting for silence *\/$/;"	e	enum:__anon121
PB_WAITING	HTKLib/HParm.h	/^   PB_WAITING,  \/* Buffer is waiting for speech *\/$/;"	e	enum:__anon121
PBlock	HTKLib/HParm.c	/^PBlock;$/;"	t	typeref:struct:pblock	file:
PClip	HTKTools/HResults.c	/^void PClip(char * instr, char *outstr, int max)$/;"	f
PDEMOutP	HTKLib/HModel.c	/^Boolean PDEMOutP(Vector otvs, MixPDF *mp, LogFloat *mixp, LogFloat xwtdet)$/;"	f
PDUR	HTKLib/HModel.c	/^   NDUR, PDUR, GDUR, RELDUR, GENDUR,$/;"	e	enum:__anon40	file:
PERCENTSYM	HTKTools/HParse.c	/^             LTRISYM,RTRISYM,EQSYM, SEMISYM, BARSYM, PERCENTSYM, $/;"	e	enum:_Symbol	file:
PExpr	HTKTools/HParse.c	/^static void PExpr(Link *hd, Link *tl)$/;"	f	file:
PFactor	HTKTools/HParse.c	/^static void PFactor(Link *hd, Link *tl)$/;"	f	file:
PGetCh	HTKTools/HParse.c	/^static void PGetCh(void)$/;"	f	file:
PGetIdent	HTKTools/HParse.c	/^static void PGetIdent(void)$/;"	f	file:
PGetSym	HTKTools/HParse.c	/^static void PGetSym(void)$/;"	f	file:
PGroup	HTKTools/HParse.c	/^static void PGroup(Link *hd, Link *tl)$/;"	f	file:
PHIdent	HTKLib/HUtil.c	/^static void PHIdent(ILink *models, HMMSet *hset)$/;"	f	file:
PHName	HTKLib/HUtil.c	/^static void PHName(ILink *models,HMMSet *hset)$/;"	f	file:
PHONE_BEAM	HTKLib/HExactMPE.c	/^static int PHONE_BEAM=4; \/* phones before & after...*\/$/;"	v	file:
PI	HTKLib/HMath.h	38;"	d
PI	HTKLib/HMath.h	40;"	d
PIndex	HTKLib/HUtil.c	/^static void PIndex(IntSet s)$/;"	f	file:
PInstInfo	HTKLib/HNet.c	/^PInstInfo;$/;"	t	typeref:struct:pinstinfo	file:
PIntRange	HTKLib/HUtil.c	/^static void PIntRange(IntSet s)$/;"	f	file:
PItemList	HTKLib/HUtil.c	/^char *PItemList(ILink *ilist, char *type, HMMSet *hset,$/;"	f
PItemSet	HTKLib/HUtil.c	/^static void PItemSet(ILink *ilist, char *type, HMMSet *hset)$/;"	f	file:
PLAINHS	HTKLib/HModel.h	/^enum _HSetKind {PLAINHS, SHAREDHS, TIEDHS, DISCRETEHS};$/;"	e	enum:_HSetKind
PLP	HTKLib/HParm.h	/^      PLP,                             \/* Standard PLP coefficients *\/$/;"	e	enum:_BaseParmKind
PMix	HTKLib/HUtil.c	/^static void PMix(ILink models, ILink *ilist, char *type,$/;"	f	file:
PModel	HTKTools/HParse.c	/^static void PModel(Link *hd, Link *tl)$/;"	f	file:
PNetwork	HTKTools/HParse.c	/^static void PNetwork(Link *hd, Link *tl, Boolean netOnly, Boolean skipExpr)$/;"	f	file:
POISSOND	HTKLib/HModel.h	/^enum _DurKind {NULLD, POISSOND, GAMMAD, RELD, GEND};$/;"	e	enum:_DurKind
POption	HTKTools/HParse.c	/^static void POption(Link *hd, Link *tl)$/;"	f	file:
POutP	HTKLib/HModel.c	/^LogFloat POutP(HMMSet *hset,Observation *x, StateInfo *si)$/;"	f
PR	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon168	file:
PREAM_MAX	HTKLib/esignal.h	53;"	d
PREEMCOEF	HTKLib/HParm.c	/^   PREEMCOEF,     \/* Preemphasis Coefficient *\/$/;"	e	enum:__anon77	file:
PREQUAL	HTKLib/HModel.c	/^   NUMCLASSES, ADAPTKIND, PREQUAL, INPUTXFORM,$/;"	e	enum:__anon40	file:
PRIMES	HTKLib/HRNLM.c	/^static unsigned int PRIMES[]={108641969, 116049371, 125925907, 133333309, 145678979, 175308587, 197530793, 234567803, 251851741, 264197411, 330864029, 399999781,$/;"	v	file:
PRIMES_SIZE	HTKLib/HRNLM.c	/^static unsigned int PRIMES_SIZE=sizeof(PRIMES)\/sizeof(PRIMES[0]);$/;"	v	file:
PROB_LOG_TO_SHORT	HLMLib/LModel.c	360;"	d	file:
PROB_LOG_TO_SHORT	HLMLib/LModel.c	375;"	d	file:
PROB_SHORT_TO_LOG	HLMLib/LModel.c	363;"	d	file:
PROB_SHORT_TO_LOG	HLMLib/LModel.c	376;"	d	file:
PROGRESS	HTKLib/HLM.c	649;"	d	file:
PROGS	HTKTools/Makefile	/^PROGS   = 	HBuild HCompV HCopy HDMan \\$/;"	m
PROJSIZE	HTKLib/HModel.c	/^   PROJSIZE,$/;"	e	enum:__anon40	file:
PRecInfo	HTKLib/HRec.h	/^typedef struct precinfo PRecInfo; \/* Private reconition information (HRec.c) *\/$/;"	t	typeref:struct:precinfo
PRepetition0	HTKTools/HParse.c	/^static void PRepetition0(Link *hd, Link *tl)$/;"	f	file:
PRepetition1	HTKTools/HParse.c	/^static void PRepetition1(Link *hd, Link *tl)$/;"	f	file:
PS	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon168	file:
PSequence	HTKTools/HParse.c	/^static void PSequence(Link *hd, Link *tl)$/;"	f	file:
PSetInfo	HTKLib/HRec.h	/^typedef struct psetinfo PSetInfo; \/* Private HMMSet information (HRec.c) *\/$/;"	t	typeref:struct:psetinfo
PState	HTKLib/HUtil.c	/^static void PState(ILink models, ILink *ilist, char *type, HMMSet *hset)$/;"	f	file:
PStatecomp	HTKLib/HUtil.c	/^static void PStatecomp(ILink models, ILink *ilist, char *type, $/;"	f	file:
PStats	HLMTools/LPlex.c	/^} PStats;$/;"	t	typeref:struct:__anon33	file:
PSubNet	HTKTools/HParse.c	/^static void PSubNet(void)$/;"	f	file:
PTRHASHSIZE	HTKLib/HModel.h	51;"	d
PTriloop	HTKTools/HParse.c	/^static void PTriloop(Link *hd, Link *tl)$/;"	f	file:
PURPLE	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	e	enum:_HColour
PVariable	HTKTools/HParse.c	/^static void PVariable(Link *hd, Link *tl)$/;"	f	file:
Pad	HTKLib/HDict.c	/^static void Pad(FILE *f, int nSp, int minSp)$/;"	f	file:
ParmBuf	HTKLib/HParm.h	/^typedef struct _ParmBuf  *ParmBuf;$/;"	t	typeref:struct:_ParmBuf
ParmBufRec	HTKLib/HParm.c	/^}ParmBufRec;$/;"	t	typeref:struct:_ParmBuf	file:
ParmFilter	HTKLib/HShell.h	/^   ParmFilter,      \/* parameter files input via HParm *\/$/;"	e	enum:__anon83
ParmKind	HTKLib/HParm.h	/^typedef short ParmKind;          \/* BaseParmKind + Qualifiers *\/$/;"	t
ParmKind2Str	HTKLib/HParm.c	/^char *ParmKind2Str(ParmKind kind, char *buf)$/;"	f
ParmOFilter	HTKLib/HShell.h	/^   ParmOFilter,     \/* parameter files output via HParm *\/$/;"	e	enum:__anon83
ParseAlpha	HTKTools/HHEd.c	/^char *ParseAlpha(char *src, char *s)$/;"	f
ParseComment	HTKLib/HShell.c	/^static char *ParseComment(Source *src,char *name)$/;"	f	file:
ParseConfIntVec	HTKLib/HAdapt.c	/^static IntVec ParseConfIntVec(MemHeap *x, char *inbuf)$/;"	f	file:
ParseError	HTKTools/HParse.c	/^static void ParseError(int errn)$/;"	f	file:
ParseNode	HTKLib/HAdapt.c	/^static Boolean ParseNode(RegNode *node, AdaptXForm *xform, $/;"	f	file:
ParseNumber	HTKLib/HNet.c	/^static LatFieldType ParseNumber(double *rval,char *buf)$/;"	f	file:
ParseString	HTKLib/HShell.c	/^char *ParseString(char *src, char *s)$/;"	f
ParseTree	HTKLib/HAdapt.c	/^static Boolean ParseTree(RegTree *rtree, AdaptXForm *xform)$/;"	f	file:
Path	HTKLib/HRec.h	/^typedef struct path Path;          \/* Traceback route *\/$/;"	t	typeref:struct:path
PathOf	HTKLib/HShell.c	/^char * PathOf(char *fn, char *s)$/;"	f
Perturb	HTKLib/HTrain.c	/^static void Perturb(int n, int n1, int n2)$/;"	f	file:
PerturbMean	HTKTools/HHEd.c	/^void PerturbMean(Vector mean, Vector covar, float pertDepth) $/;"	f
Pf	HTKLib/HRNLM.h	/^    float *Pi, *Pf, *Po;$/;"	m	struct:_Layer
PhoneMEE	HTKLib/HExactMPE.c	/^static Boolean PhoneMEE = TRUE;  \/* repeat of config also used in HFBLat.c *\/$/;"	v	file:
PhoneMEE	HTKLib/HFBLat.c	/^static Boolean PhoneMEE = TRUE;      \/*IMPORTANT*\/           \/* If true and the MPE routines are called, do MPE, else MWE (word level) *\/$/;"	v	file:
PhoneMEEUseContext	HTKLib/HFBLat.c	/^static Boolean PhoneMEEUseContext = FALSE;                  \/*Compare phones-in-context.  I doubt you would want this true, anyway it makes little difference.*\/$/;"	v	file:
Phw	HTKLib/HRNLM.h	/^    float *Phw, *Rhw;$/;"	m	struct:_Layer
Pi	HTKLib/HRNLM.h	/^    float *Pi, *Pf, *Po;$/;"	m	struct:_Layer
PlayAudio	HTKLib/HAudio.c	/^static void PlayAudio(AudioOut a, short *buf, int nSamples)$/;"	f	file:
PlayLabel	HTKTools/HSLab.c	/^void PlayLabel(int x)$/;"	f
PlayReplayBuffer	HTKLib/HAudio.c	/^void PlayReplayBuffer(AudioOut ao, AudioIn ai)$/;"	f
Playback	HTKTools/HSLab.c	/^void Playback(Wave w, long sampA, long sampB, int vol, int scale, Boolean *newData)$/;"	f
PlotFileWin	HTKTools/HSLab.c	/^void PlotFileWin(void)$/;"	f
PlotGStripes	HTKTools/HSLab.c	/^void PlotGStripes(int x, int y, int width, int height)$/;"	f
PlotLabWin	HTKTools/HSLab.c	/^void PlotLabWin(void)$/;"	f
PlotLabels	HTKTools/HSLab.c	/^void PlotLabels(RectWin *win, LabList *ll, long sStart, long sEnd)$/;"	f
PlotWaveForm	HTKTools/HSLab.c	/^void PlotWaveForm(RectWin *win, int st_pt, int en_pt)$/;"	f
PlotWaveWin	HTKTools/HSLab.c	/^void PlotWaveWin(void)$/;"	f
PlotWaveWinPtr	HTKTools/HSLab.c	/^void PlotWaveWinPtr(int pos)$/;"	f
Po	HTKLib/HRNLM.h	/^    float *Pi, *Pf, *Po;$/;"	m	struct:_Layer
Point2Sample	HTKTools/HSLab.c	/^long Point2Sample(RectWin *win, int pt)$/;"	f
PowerSizeCommand	HTKTools/HHEd.c	/^void PowerSizeCommand(void)$/;"	f
PrBar	HTKTools/HList.c	/^void PrBar(char *title)$/;"	f
PrLog	HTKLib/HFB.c	/^void PrLog(LogDouble x)$/;"	f
PrModelName	HTKTools/HParse.c	/^static void PrModelName(Link p)$/;"	f	file:
PrVInfo	HTKLib/HShell.c	/^static void PrVInfo(char *s,char *sccs)$/;"	f	file:
PreComp	HTKLib/HRec.c	/^PreComp;$/;"	t	typeref:struct:precomp	file:
PreComp	HTKLib/HTrain.h	/^} PreComp;$/;"	t	typeref:struct:__anon115
PreEmphasise	HTKLib/HSigP.c	/^void PreEmphasise (Vector s, float k)$/;"	f
PrecomputeTMix	HTKLib/HModel.c	/^void PrecomputeTMix(HMMSet *hset, Observation *x, float tmThresh, int topM)$/;"	f
PreparePlot	HTKTools/HSLab.c	/^void PreparePlot(RectWin *win, short *data, int st, int en)$/;"	f
PrintAllHeapStats	HTKLib/HMem.c	/^void PrintAllHeapStats(void)$/;"	f
PrintArc	HTKLib/HArc.c	/^void PrintArc(FILE *f, HArc *a){$/;"	f
PrintArcInfo	HTKLib/HArc.c	/^void PrintArcInfo(FILE *f, ArcInfo *ai){$/;"	f
PrintArcs	HTKLib/HArc.c	/^void PrintArcs(FILE *f, HArc *a){$/;"	f
PrintBar	HTKTools/HResults.c	/^void PrintBar(int offset, int width, char c, char *title)$/;"	f
PrintBaseClass	HTKTools/HHEd.c	/^void PrintBaseClass(FILE *f, RegTree *t, int nNodes, char *bname) $/;"	f
PrintChain	HTKLib/HNet.c	/^static void PrintChain(Network *wnet,HMMSet *hset)$/;"	f	file:
PrintChain	HTKTools/HParse.c	/^void PrintChain(Link chain)$/;"	f
PrintConfig	HTKLib/HShell.c	/^void PrintConfig(void)$/;"	f
PrintContexts	HTKTools/HLEd.c	/^void PrintContexts(void)$/;"	f
PrintCriteria	HTKTools/HMMIRest.c	/^void PrintCriteria(){$/;"	f
PrintDataBar	HTKTools/HList.c	/^void PrintDataBar(long st, long en)$/;"	f
PrintFields	HLMTools/LGPrep.c	/^void PrintFields(FieldVec *fl)$/;"	f
PrintFileStats	HTKTools/HResults.c	/^void PrintFileStats(char *fn, int h, int d, int s, int i)$/;"	f
PrintGlobalStats	HTKTools/HResults.c	/^void PrintGlobalStats(void)$/;"	f
PrintHMMProfile	HTKLib/HModel.c	/^void PrintHMMProfile(FILE *f, HLink hmm)$/;"	f
PrintHParseNetwork	HTKTools/HParse.c	/^static void PrintHParseNetwork(HPNetwork *network)$/;"	f	file:
PrintHSetProfile	HTKLib/HModel.c	/^void PrintHSetProfile(FILE *f, HMMSet *hset)$/;"	f
PrintHashTabStats	HLMLib/LUtil.c	/^void PrintHashTabStats(HashTab *htab)$/;"	f
PrintHashUsage	HTKLib/HModel.c	/^static void PrintHashUsage(FILE *f, HMMSet *hset)$/;"	f	file:
PrintHeader	HTKTools/HResults.c	/^void PrintHeader(void)$/;"	f
PrintHeading	HTKTools/HList.c	/^void PrintHeading(HeadInfo h)$/;"	f
PrintHeapStats	HTKLib/HMem.c	/^void PrintHeapStats(MemHeap *x)$/;"	f
PrintIdList	HTKTools/HDMan.c	/^void PrintIdList(LabId *i)$/;"	f
PrintIdList	HTKTools/HLEd.c	/^void PrintIdList(LabId *i)$/;"	f
PrintInfo	HLMTools/LPlex.c	/^static void PrintInfo(PStats *ps, Boolean showOOV)$/;"	f	file:
PrintInitialInfo	HTKTools/HInit.c	/^void PrintInitialInfo(void)$/;"	f
PrintInitialInfo	HTKTools/HRest.c	/^void PrintInitialInfo(void)$/;"	f
PrintKeySpots	HTKTools/HResults.c	/^void PrintKeySpots(void)$/;"	f
PrintLabel	HTKLib/HLabel.c	/^static void PrintLabel(LLink p, int maxAux)$/;"	f	file:
PrintLinkSet	HTKTools/HParse.c	/^static void PrintLinkSet(int n, LinkSet *p)$/;"	f	file:
PrintLinks	HTKLib/HNet.c	/^static void PrintLinks(NetLink *links,int nlinks)$/;"	f	file:
PrintList	HTKLib/HLabel.c	/^static void PrintList(LabList *ll)$/;"	f	file:
PrintLog	HTKTools/HDMan.c	/^void PrintLog(void)$/;"	f
PrintLog	HTKTools/HSmooth.c	/^void PrintLog(LogDouble x)$/;"	f
PrintMsg	HTKTools/HSLab.c	/^void PrintMsg(RectWin *win, char *msg)$/;"	f
PrintNBar	HTKTools/HResults.c	/^void PrintNBar(int width, char c, char left, char right)$/;"	f
PrintNGBuffer	HLMLib/LGBase.c	/^void PrintNGBuffer(NGBuffer *ngb)$/;"	f
PrintNGram	HLMLib/LGBase.c	/^void PrintNGram(int N, NGram ng, WordMap *wm)$/;"	f
PrintNMargin	HTKTools/HResults.c	/^void PrintNMargin(void)$/;"	f
PrintNameTabStats	HTKLib/HLabel.c	/^void PrintNameTabStats(void)$/;"	f
PrintNode	HTKLib/HNet.c	/^static void PrintNode(NetNode *node,HMMSet *hset)$/;"	f	file:
PrintNode	HTKTools/HParse.c	/^static void PrintNode(Link p)$/;"	f	file:
PrintNodeInfo	HTKTools/HHEd.c	/^void PrintNodeInfo(RNode *n, int vSize) $/;"	f
PrintObsFmt	HTKTools/HList.c	/^void PrintObsFmt(Observation *o)$/;"	f
PrintObservation	HTKLib/HParm.c	/^void PrintObservation(int i, Observation *o, int itemsPerLine)$/;"	f
PrintPDEstats	HTKLib/HModel.c	/^void PrintPDEstats()$/;"	f
PrintROCInfo	HTKTools/HResults.c	/^void PrintROCInfo(int kn)$/;"	f
PrintRawVec	HTKTools/HList.c	/^void PrintRawVec(Vector v)$/;"	f
PrintRegTree	HTKTools/HHEd.c	/^void PrintRegTree(FILE *f, RegTree *t, int nNodes, char* rname, char* bname) $/;"	f
PrintRuleSet	HLMTools/LGPrep.c	/^void PrintRuleSet(RuleSet *rset)$/;"	f
PrintScript	HTKTools/HDMan.c	/^void PrintScript(char *name, DBuffer *db)$/;"	f
PrintScript	HTKTools/HLEd.c	/^void PrintScript(char *scriptFN)$/;"	f
PrintSettings	HTKTools/HLStats.c	/^void PrintSettings(void)$/;"	f
PrintSpkrStats	HTKTools/HResults.c	/^void PrintSpkrStats(void)$/;"	f
PrintSpotList	HTKTools/HResults.c	/^void PrintSpotList(SpotRec *p)$/;"	f
PrintStats	HTKTools/HERest.c	/^void PrintStats(HMMSet *hset,FILE *f, int n, HLink hmm, int numEgs)$/;"	f
PrintStats	HTKTools/HMMIRest.c	/^void PrintStats(FILE *f, int n, HLink hmm, int numEgs)$/;"	f
PrintStats	HTKTools/HParse.c	/^void PrintStats(void)$/;"	f
PrintStats	HTKTools/HSmooth.c	/^void PrintStats(FILE *f, int n, HLink hmm, int numEgs)$/;"	f
PrintStdOpts	HTKLib/HShell.c	/^void PrintStdOpts(char *opt)$/;"	f
PrintTotalAccessStats	HLMLib/LModel.c	/^void PrintTotalAccessStats(FILE *f,BackOffLM *lm)$/;"	f
PrintTrace	HTKTools/HCopy.c	/^void PrintTrace(void)$/;"	f
PrintTranscription	HTKLib/HLabel.c	/^void PrintTranscription(Transcription *t, char *title)$/;"	f
PrintTree	HTKLib/HVQ.c	/^static void PrintTree(VQNode n, CovKind ck)$/;"	f	file:
PrintUsage	HTKTools/HDMan.c	/^void PrintUsage(DBuffer *db)$/;"	f
PrintVBounds	HTKTools/HLEd.c	/^void PrintVBounds(void)$/;"	f
PrintVQTab	HTKLib/HVQ.c	/^void PrintVQTab(VQTable vqTab)$/;"	f
PrintWBounds	HTKTools/HLEd.c	/^void PrintWBounds(void)$/;"	f
PrintWaveLine	HTKTools/HList.c	/^void PrintWaveLine(short *data, int nItems, long idx)$/;"	f
PrintWord	HTKTools/HSGen.c	/^void PrintWord(NodeId n)$/;"	f
PriorK	HTKTools/HMMIRest.c	/^static float PriorK = 0.0;           \/* e.g. use 1 if disc. trained prior model is better than ML trained new model.  *\/$/;"	v	file:
PriorTau	HTKTools/HMMIRest.c	/^static float PriorTau = 0.0;         \/* tau value [e.g. 10,25] for use in discriminative MAP with -Hprior option. *\/$/;"	v	file:
PriorTauTrans	HTKTools/HMMIRest.c	/^static float PriorTauTrans = 0.0;$/;"	v	file:
PriorTauWeights	HTKTools/HMMIRest.c	/^static float PriorTauWeights = 0.0;$/;"	v	file:
Prob2Shrt	HLMLib/LModel.c	/^static UShort Prob2Shrt(float f)$/;"	f	file:
ProcessBiGram	HTKTools/HBuild.c	/^Lattice *ProcessBiGram(MemHeap *latHeap, Vocab *voc, LModel *biLM)$/;"	f
ProcessBoBiGram	HTKTools/HBuild.c	/^Lattice *ProcessBoBiGram(MemHeap *latHeap, Vocab *voc, NGramLM *nLM)$/;"	f
ProcessCrossWordLinks	HTKLib/HNet.c	/^void ProcessCrossWordLinks(MemHeap *heap,Lattice *lat,int xc)$/;"	f
ProcessFile	HTKTools/HVite.c	/^Boolean ProcessFile(char *fn, Network *net, int utterNum, LogDouble currGenBeam, Boolean restartable)$/;"	f
ProcessFiles	HLMTools/LPlex.c	/^static void ProcessFiles()$/;"	f	file:
ProcessLabelFile	HLMTools/LPlex.c	/^static void ProcessLabelFile(char *fn, int nSize)$/;"	f	file:
ProcessLabels	HTKTools/HLRescore.c	/^void ProcessLabels (char *labfn_in, char *labfn_ou)$/;"	f
ProcessLattice	HTKTools/HLRescore.c	/^void ProcessLattice (char *latfn_in, char *latfn_ou)$/;"	f
ProcessMatBiGram	HTKTools/HBuild.c	/^Lattice *ProcessMatBiGram(MemHeap *latHeap, Vocab *voc, MatBiLM *bg)$/;"	f
ProcessObservation	HTKLib/HRec.c	/^void ProcessObservation(VRecInfo *vri,Observation *obs,int id, AdaptXForm *xform)$/;"	f
ProcessText	HLMTools/LAdapt.c	/^void ProcessText(char *fn, Boolean lastFile)$/;"	f
ProcessText	HLMTools/LGPrep.c	/^void ProcessText(char *fn, Boolean lastFile)$/;"	f
ProcessTextStream	HLMTools/LPlex.c	/^static void ProcessTextStream(char *fn, int nSize)$/;"	f	file:
ProcessWordLoop	HTKTools/HBuild.c	/^Lattice *ProcessWordLoop(MemHeap *latHeap, Vocab *voc)$/;"	f
ProcessWordPair	HTKTools/HBuild.c	/^Lattice *ProcessWordPair(MemHeap *latHeap, Vocab *voc, char *gramFn)$/;"	f
ProjectCommand	HTKTools/HHEd.c	/^void ProjectCommand(void)$/;"	f
Pron	HTKLib/HDict.h	/^typedef struct _WordPron  *Pron;$/;"	t	typeref:struct:_WordPron
PronHolder	HTKLib/HNet.c	/^PronHolder;$/;"	t	typeref:struct:pronholder	file:
Pronunciation	HTKTools/HDMan.c	/^}Pronunciation;$/;"	t	typeref:struct:__anon160	file:
ProtectedFillBufferFromAudio	HTKLib/HAudio.c	/^static void ProtectedFillBufferFromAudio(AudioIn a,int min)$/;"	f	file:
PruneInfo	HTKLib/HFB.h	/^} PruneInfo;$/;"	t	typeref:struct:__anon137
Ptr	HTKLib/HMem.h	/^typedef void * Ptr;$/;"	t
PtrMap	HTKLib/HModel.h	/^} PtrMap;$/;"	t	typeref:struct:_PtrMap
PurgeMacros	HTKTools/HHEd.c	/^void PurgeMacros(HMMSet *hset)$/;"	f
PutAdaptXForm	HTKLib/HModel.c	/^static void PutAdaptXForm(HMMSet *hset, FILE *f, MLink q, AdaptXForm *xform, $/;"	f	file:
PutBaseClass	HTKLib/HModel.c	/^static void PutBaseClass(HMMSet *hset, FILE *f, MLink q, BaseClass *bclass, $/;"	f	file:
PutBias	HTKLib/HModel.c	/^static void PutBias(HMMSet *hset, FILE *f, MLink q, SVector m, $/;"	f	file:
PutCovar	HTKLib/HModel.c	/^static void PutCovar(HMMSet *hset, FILE *f, MLink q, STriMat m,$/;"	f	file:
PutDiscrete	HTKLib/HModel.c	/^void PutDiscrete(FILE *f, StreamElem *se, Boolean binary)$/;"	f
PutDiscreteWeights	HTKLib/HModel.c	/^void PutDiscreteWeights(FILE *f, StreamElem *se, Boolean binary)$/;"	f
PutDuration	HTKLib/HModel.c	/^static void PutDuration(HMMSet *hset, FILE *f, MLink q, SVector v,$/;"	f	file:
PutESIGHeaderInfo	HTKLib/HWave.c	/^void PutESIGHeaderInfo(FILE *f, Wave w)$/;"	f
PutHMMDef	HTKLib/HModel.c	/^static void PutHMMDef(HMMSet *hset, FILE *f, MLink m, Boolean withHdr,$/;"	f	file:
PutHTKHeaderInfo	HTKLib/HWave.c	/^static void PutHTKHeaderInfo(FILE *f, Wave w)$/;"	f	file:
PutInputXForm	HTKLib/HModel.c	/^static void PutInputXForm(HMMSet *hset, FILE *f, MLink q, InputXForm *xf, $/;"	f	file:
PutLab	HTKTools/HLEd.c	/^void PutLab(LabId id)$/;"	f
PutLinXForm	HTKLib/HModel.c	/^static void PutLinXForm(HMMSet *hset, FILE *f, MLink q, LinXForm *xf, $/;"	f	file:
PutMacroHdr	HTKLib/HModel.c	/^static void PutMacroHdr(HMMSet *hset, FILE *f, MLink m, char mType, $/;"	f	file:
PutMean	HTKLib/HModel.c	/^static void PutMean(HMMSet *hset, FILE *f, MLink q, SVector m, $/;"	f	file:
PutMixPDF	HTKLib/HModel.c	/^static void PutMixPDF(HMMSet *hset, FILE *f, MLink q, MixPDF *mp, $/;"	f	file:
PutMixWeight	HTKLib/HModel.c	/^void PutMixWeight(FILE *f, short repeatLast, short w, Boolean binary)$/;"	f
PutOptions	HTKLib/HModel.c	/^static void PutOptions(HMMSet *hset, FILE *f, Boolean binary)$/;"	f	file:
PutPhone	HTKTools/HDMan.c	/^void PutPhone(LabId id)$/;"	f
PutRegNode	HTKLib/HModel.c	/^static void PutRegNode(HMMSet *hset, FILE *f, RegNode *rnode, Boolean binary) $/;"	f	file:
PutRegTree	HTKLib/HModel.c	/^static void PutRegTree(HMMSet *hset, FILE *f, MLink q, RegTree *t, $/;"	f	file:
PutSWeights	HTKLib/HModel.c	/^static void PutSWeights(HMMSet *hset, FILE *f, MLink q, SVector v,$/;"	f	file:
PutShiftRegister	HLMTools/LAdapt.c	/^void PutShiftRegister(LabId id, ShiftReg *sr)$/;"	f
PutShiftRegister	HLMTools/LGPrep.c	/^void PutShiftRegister(LabId id, ShiftReg *sr)$/;"	f
PutStateInfo	HTKLib/HModel.c	/^static void PutStateInfo(HMMSet *hset, FILE *f, MLink q, StateInfo *si, $/;"	f	file:
PutSymbol	HTKLib/HModel.c	/^static void PutSymbol(FILE *f, Symbol sym, Boolean binary)$/;"	f	file:
PutTargetFile	HTKTools/HCopy.c	/^void PutTargetFile(char *s)$/;"	f
PutTiedMixtures	HTKLib/HModel.c	/^void PutTiedMixtures(HMMSet *hset,FILE *f,int s,StreamElem *se,Boolean binary)$/;"	f
PutTiedWeight	HTKLib/HModel.c	/^void PutTiedWeight(FILE *f, short repeatLast, float w, Boolean binary)$/;"	f
PutTiedWeights	HTKLib/HModel.c	/^void PutTiedWeights(FILE *f, StreamElem *se, Boolean binary)$/;"	f
PutTransMat	HTKLib/HModel.c	/^static void PutTransMat(HMMSet *hset, FILE *f, MLink q, SMatrix m,$/;"	f	file:
PutTransform	HTKLib/HModel.c	/^static void PutTransform(HMMSet *hset, FILE *f, MLink q, SMatrix m,$/;"	f	file:
PutVFloor	HTKTools/HCompV.c	/^void PutVFloor(void)$/;"	f
PutVariance	HTKLib/HModel.c	/^static void PutVariance(HMMSet *hset, FILE *f, MLink q, SVector v,$/;"	f	file:
PutWaveSample	HTKLib/HWave.c	/^void PutWaveSample(Wave w, long nSamples, short *buf)$/;"	f
PutXFormSet	HTKLib/HModel.c	/^static void PutXFormSet(HMMSet *hset, FILE *f, MLink q, XFormSet *xformSet, $/;"	f	file:
Q	HTKLib/HArc.h	/^  int Q;       \/*number of unique arcs.. *\/$/;"	m	struct:ArcInfoStruct
Q	HTKLib/HFB.h	/^  int Q;              \/* number of models in transcription *\/$/;"	m	struct:__anon136
Q	HTKLib/HFBLat.h	/^  int Q;$/;"	m	struct:__anon54
Q	HTKLib/esig_asc.c	39;"	d	file:
QEnt	HTKTools/HHEd.c	/^}QEnt;$/;"	t	typeref:struct:_QEnt	file:
QLink	HTKTools/HHEd.c	/^typedef struct _QEnt *QLink;   \/* Linked list of Questions *\/$/;"	t	typeref:struct:_QEnt	file:
QMatch	HTKTools/HHEd.c	/^Boolean QMatch(char *name, QLink q)$/;"	f
QN_MAT_NAMLEN_MAX	HTKLib/HNLM.h	64;"	d
QN_MAT_TYPE_DOUBLE	HTKLib/HNLM.h	53;"	d
QN_MAT_TYPE_FLOAT	HTKLib/HNLM.h	54;"	d
QN_MAT_TYPE_FULL	HTKLib/HNLM.h	60;"	d
QN_MAT_TYPE_IEEEBIG	HTKLib/HNLM.h	51;"	d
QN_MAT_TYPE_IEEELITTLE	HTKLib/HNLM.h	50;"	d
QN_MAT_TYPE_INT16	HTKLib/HNLM.h	56;"	d
QN_MAT_TYPE_INT32	HTKLib/HNLM.h	55;"	d
QN_MAT_TYPE_SPARSE	HTKLib/HNLM.h	62;"	d
QN_MAT_TYPE_TEXT	HTKLib/HNLM.h	61;"	d
QN_MAT_TYPE_UINT16	HTKLib/HNLM.h	57;"	d
QN_MAT_TYPE_UINT8	HTKLib/HNLM.h	58;"	d
QN_MAX_LAYERS	HTKLib/HNLM.h	44;"	d
QN_MAX_SECTIONS	HTKLib/HNLM.h	46;"	d
QN_MAX_WEIGHTMATS	HTKLib/HNLM.h	45;"	d
QN_SIZET_BAD	HTKLib/HNLM.h	47;"	d
QN_WEIGHTS_UNKNOWN	HTKLib/HNLM.h	48;"	d
QS	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon168	file:
QSCmpArcs	HTKLib/HNet.c	/^static int QSCmpArcs(const void *v1,const void *v2)$/;"	f	file:
QSCmpNodes	HTKLib/HNet.c	/^static int QSCmpNodes(const void *v1,const void *v2)$/;"	f	file:
QUOTE	HTKLib/esig_asc.c	40;"	d	file:
QuestionCommand	HTKTools/HHEd.c	/^void QuestionCommand(void)$/;"	f
Quinphone	HTKLib/HExactMPE.c	/^static Boolean Quinphone = FALSE; \/* repeat of config also used in HFBLat.c *\/$/;"	v	file:
Quinphone	HTKLib/HFBLat.c	/^static Boolean Quinphone = FALSE;            \/* Set this TRUE if this is a quinphone model set.  The code for quinphones depends on the naming conventions $/;"	v	file:
RANDF	HTKLib/HMath.c	1623;"	d	file:
RANDF	HTKLib/HMath.c	1627;"	d	file:
RANGSYM	HTKTools/HParse.c	/^             RBRACESYM, LANGSYM, RANGSYM, LBRAKSYM, RBRAKSYM, $/;"	e	enum:_Symbol	file:
RANLIB	HTKLib/Makefile	/^RANLIB = ranlib$/;"	m
RAWENERGY	HTKLib/HParm.c	/^   RAWENERGY,     \/* Use raw energy *\/$/;"	e	enum:__anon77	file:
RAWMODE	HTKTools/HDMan.c	/^              TCTXT, APPSIL, REMSTRESS, REPLACEW, RAWMODE, $/;"	e	enum:__anon158	file:
RBRACESYM	HTKTools/HParse.c	/^             RBRACESYM, LANGSYM, RANGSYM, LBRAKSYM, RBRAKSYM, $/;"	e	enum:_Symbol	file:
RBRAKSYM	HTKTools/HParse.c	/^             RBRACESYM, LANGSYM, RANGSYM, LBRAKSYM, RBRAKSYM, $/;"	e	enum:_Symbol	file:
RC	HTKTools/HHEd.c	/^                         RC ,$/;"	e	enum:__anon168	file:
RCLASS	HTKLib/HModel.c	/^   RCLASS=110, REGTREE, NODE, TNODE,$/;"	e	enum:__anon40	file:
RCTXT	HTKTools/HDMan.c	/^              LCTXT, RCTXT,$/;"	e	enum:__anon158	file:
RCTXT	HTKTools/HLEd.c	/^   RCTXT,   TCTXT,  SETLEV, DELLEV, SPLLEV, ISIL,$/;"	e	enum:__anon141	file:
RCtxtOp	HTKTools/HDMan.c	/^void RCtxtOp(WordBuf *wb, int nArgs,LabId *args)$/;"	f
READ_FLOAT	HLMLib/LModel.c	652;"	d	file:
REC_BUF_SIZE	HTKTools/HSLab.c	368;"	d	file:
RED	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	e	enum:_HColour
REGTREE	HTKLib/HModel.c	/^   RCLASS=110, REGTREE, NODE, TNODE,$/;"	e	enum:__anon40	file:
RELD	HTKLib/HModel.h	/^enum _DurKind {NULLD, POISSOND, GAMMAD, RELD, GEND};$/;"	e	enum:_DurKind
RELDUR	HTKLib/HModel.c	/^   NDUR, PDUR, GDUR, RELDUR, GENDUR,$/;"	e	enum:__anon40	file:
REMSTRESS	HTKTools/HDMan.c	/^              TCTXT, APPSIL, REMSTRESS, REPLACEW, RAWMODE, $/;"	e	enum:__anon158	file:
REPLACE	HTKTools/HLEd.c	/^   REPLACE, CHANGE, FIND,   MERGE,  EDOP_DELETE, DEFCON, TRIST,  $/;"	e	enum:__anon141	file:
REPLACEP	HTKTools/HDMan.c	/^              REPLACEP, CONREPLACE, MERGEP, SPLITP, DELETEP, DELSOURCE, $/;"	e	enum:__anon158	file:
REPLACEW	HTKTools/HDMan.c	/^              TCTXT, APPSIL, REMSTRESS, REPLACEW, RAWMODE, $/;"	e	enum:__anon158	file:
REQUIRED	HTKLib/esignal.h	90;"	d
RM	HTKTools/HHEd.c	/^                         RO , RM , RN , RP ,$/;"	e	enum:__anon168	file:
RMatch	HTKLib/HShell.c	/^Boolean RMatch(char *s,char *p,int slen,int minplen,int numstars)$/;"	f
RN	HTKTools/HHEd.c	/^                         RO , RM , RN , RP ,$/;"	e	enum:__anon168	file:
RNLM	HTKLib/HLM.h	/^} RNLM;$/;"	t	typeref:struct:__anon124
RNLMInit	HTKLib/HLM-RNNLM.c	/^void RNLMInit (LModel *lm)$/;"	f
RNLMReset	HTKLib/HLM-RNNLM.c	/^void RNLMReset (LModel *lm)$/;"	f
RNNLM	HTKLib/HRNLM.h	/^} RNNLM;$/;"	t	typeref:struct:_RNNLM
RNNLMAcceptWord	HTKLib/HRNLM.c	/^float RNNLMAcceptWord(RNNLM* rnnlm, int lastword, int curword)$/;"	f
RNNLMCalcProb	HTKLib/HRNLM.c	/^void RNNLMCalcProb(RNNLM* rnnlm, Vector hist, int lastword)$/;"	f
RNNLMEnd	HTKLib/HRNLM.c	/^void RNNLMEnd(RNNLM* rnnlm)$/;"	f
RNNLMInVocabMap	HTKLib/HRNLM.c	/^int RNNLMInVocabMap(RNNLM* rnnlm, char* name)$/;"	f
RNNLMOutVocabMap	HTKLib/HRNLM.c	/^int RNNLMOutVocabMap(RNNLM* rnnlm, char* name)$/;"	f
RNNLMStart	HTKLib/HRNLM.c	/^void RNNLMStart(RNNLM* rnnlm)$/;"	f
RNNOutputLogProb	HTKLib/HRNLM.c	/^void RNNOutputLogProb(char* modelfn, char* textfn)$/;"	f
RNode	HTKTools/HHEd.c	/^} RNode;$/;"	t	typeref:struct:__anon167	file:
RO	HTKTools/HHEd.c	/^                         RO , RM , RN , RP ,$/;"	e	enum:__anon168	file:
RP	HTKTools/HHEd.c	/^                         RO , RM , RN , RP ,$/;"	e	enum:__anon168	file:
RPARSYM	HTKTools/HParse.c	/^enum _Symbol{NAMESYM, VARSYM, VARATSYM, LPARSYM, RPARSYM, LBRACESYM, $/;"	e	enum:_Symbol	file:
RT	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon168	file:
RTRISYM	HTKTools/HParse.c	/^             LTRISYM,RTRISYM,EQSYM, SEMISYM, BARSYM, PERCENTSYM, $/;"	e	enum:_Symbol	file:
RandInit	HTKLib/HMath.c	/^void RandInit(int seed)$/;"	f
RandSucc	HTKTools/HSGen.c	/^NodeId RandSucc(NodeId n)$/;"	f
RandomValue	HTKLib/HMath.c	/^float RandomValue(void)$/;"	f
RawReadFloat	HTKLib/HShell.c	/^Boolean RawReadFloat(Source *src, float *x, int n, Boolean bin, Boolean swap)$/;"	f
RawReadInt	HTKLib/HShell.c	/^Boolean RawReadInt(Source *src, int *i, int n, Boolean bin, Boolean swap)$/;"	f
RawReadShort	HTKLib/HShell.c	/^Boolean RawReadShort(Source *src, short *s, int n, Boolean bin, Boolean swap)$/;"	f
ReEstimateModel	HTKTools/HRest.c	/^void ReEstimateModel(void)$/;"	f
ReOrderComponents	HTKLib/HModel.c	/^static void ReOrderComponents(HMMSet *hset)$/;"	f	file:
ReOrderFeaturesCommand	HTKTools/HHEd.c	/^void ReOrderFeaturesCommand()$/;"	f
ReOrderList	HTKLib/HRec.c	/^static void ReOrderList(NetNode *node)$/;"	f	file:
RePtrHT	HTKLib/HLM.h	/^   void *RePtrHT;               \/* Recombination for interpolated models (trn) *\/$/;"	m	struct:intpltlm
ReSizeNodes	HTKTools/HParse.c	/^static void ReSizeNodes(HPNetwork *net)$/;"	f	file:
ReSortGFList	HLMLib/LGBase.c	/^static void ReSortGFList(NGInputSet *inset)$/;"	f	file:
ReWriteString	HTKLib/HShell.c	/^char *ReWriteString(char *s,char *dst, char q)$/;"	f
Read	HTKLib/HRNLM.c	/^void Read (Layer *self, FILE *fptr)$/;"	f
ReadAlign	HTKLib/HNet.c	/^static int ReadAlign(Lattice *lat,LArc *la,char *buf)$/;"	f	file:
ReadAsBuffer	HTKLib/HParm.c	/^Boolean ReadAsBuffer(ParmBuf pbuf, Observation *o)$/;"	f
ReadAsTable	HTKLib/HParm.c	/^void ReadAsTable(ParmBuf pbuf, int index, Observation *o)$/;"	f
ReadAsciiArray	HTKLib/esig_asc.c	/^ReadAsciiArray(Array    *array,$/;"	f	file:
ReadAsciiAxisNames	HTKLib/esig_asc.c	/^ReadAsciiAxisNames(char ***axis_names, int rank, FILE *file)$/;"	f	file:
ReadAsciiData	HTKLib/esig_asc.c	/^ReadAsciiData(FieldSpec *field, FILE *file)$/;"	f	file:
ReadAsciiDims	HTKLib/esig_asc.c	/^ReadAsciiDims(short *rank, long **dim, FILE *file)$/;"	f	file:
ReadAsciiDouble	HTKLib/esig_asc.c	/^ReadAsciiDouble(double *x, FILE *file)$/;"	f	file:
ReadAsciiEscape	HTKLib/esig_asc.c	/^ReadAsciiEscape(unsigned long   *val,$/;"	f	file:
ReadAsciiFieldList	HTKLib/esig_asc.c	/^ReadAsciiFieldList(FieldList    *listp,$/;"	f
ReadAsciiFieldSpec	HTKLib/esig_asc.c	/^ReadAsciiFieldSpec(FieldSpec    **field,$/;"	f	file:
ReadAsciiFieldStruct	HTKLib/esig_asc.c	/^ReadAsciiFieldStruct(FieldSpec  **field,$/;"	f	file:
ReadAsciiMisc	HTKLib/esig_asc.c	/^ReadAsciiMisc(int rank, char **units, double *scale,$/;"	f	file:
ReadAsciiName	HTKLib/esig_asc.c	/^ReadAsciiName(int depth, char **names, FILE *file)$/;"	f	file:
ReadAsciiNewline	HTKLib/esig_asc.c	/^ReadAsciiNewline(FILE *file)$/;"	f	file:
ReadAsciiOccurrence	HTKLib/esig_asc.c	/^ReadAsciiOccurrence(short *occurrence, FILE *file)$/;"	f	file:
ReadAsciiRecord	HTKLib/esig_asc.c	/^ReadAsciiRecord(FieldSpec **fields,$/;"	f
ReadAsciiSamples	HTKLib/esig_asc.c	/^ReadAsciiSamples(void       *data,$/;"	f
ReadAsciiString	HTKLib/esig_asc.c	/^ReadAsciiString(char **string, FILE *file)$/;"	f	file:
ReadAsciiType	HTKLib/esig_asc.c	/^ReadAsciiType(short *type, FILE *file)$/;"	f	file:
ReadAudio	HTKLib/HAudio.c	/^static void ReadAudio(AudioIn a, short *buf, int nSamples)$/;"	f	file:
ReadBoNGram	HTKLib/HLM.c	/^static void ReadBoNGram(LModel *lm,char *fn)$/;"	f	file:
ReadCh	HTKLib/HUtil.c	/^static void ReadCh(void)$/;"	f	file:
ReadChanFiles	HTKLib/HParm.c	/^static ReturnStatus ReadChanFiles(ChannelInfo *chan)$/;"	f	file:
ReadClassCounts	HLMLib/LModel.c	/^static void ReadClassCounts(Source *src, int nWords, BackOffLM *lm)$/;"	f	file:
ReadClassProbs	HLMLib/LModel.c	/^static void ReadClassProbs(Source *src, int nWords, BackOffLM *lm)$/;"	f	file:
ReadClassProbsHeader	HLMLib/LModel.c	/^static void ReadClassProbsHeader(char *fname, int *nWords, Source *src, BackOffLM *lm)$/;"	f	file:
ReadCmd	HTKTools/HDMan.c	/^EdOp ReadCmd(Source *src)$/;"	f
ReadCmd	HTKTools/HLEd.c	/^EdOp ReadCmd(Source *src)$/;"	f
ReadConfName	HTKLib/HShell.c	/^static Boolean ReadConfName(Source *src, char *s)$/;"	f	file:
ReadConfigFile	HTKLib/HShell.c	/^static ReturnStatus ReadConfigFile(char *fname)$/;"	f	file:
ReadDict	HTKLib/HDict.c	/^ReturnStatus ReadDict(char *dictFn, Vocab *voc)$/;"	f
ReadDictProns	HTKTools/HDMan.c	/^Boolean ReadDictProns(DBuffer *db)$/;"	f
ReadDictWord	HTKLib/HDict.c	/^ReturnStatus ReadDictWord(Source *src,LabId *labels,float *prob, int *num)$/;"	f
ReadESIGPHeader	HTKLib/HParm.c	/^Boolean ReadESIGPHeader(FILE *f, long *nSamp, long *sampP, short *sampS,$/;"	f
ReadEdrArray	HTKLib/esig_edr.c	/^ReadEdrArray(Array  *array,$/;"	f	file:
ReadEdrData	HTKLib/esig_edr.c	/^ReadEdrData(FieldSpec *field,$/;"	f	file:
ReadEdrFieldList	HTKLib/esig_edr.c	/^ReadEdrFieldList(FieldList  *listp,  \/* output variable *\/$/;"	f
ReadEdrFieldSpec	HTKLib/esig_edr.c	/^ReadEdrFieldSpec(FILE   *file,$/;"	f	file:
ReadEdrRecord	HTKLib/esig_edr.c	/^ReadEdrRecord(FieldSpec **fields,$/;"	f
ReadEdrSamples	HTKLib/esig_edr.c	/^ReadEdrSamples(void         *data,$/;"	f
ReadEdrString	HTKLib/esig_edr.c	/^ReadEdrString(char  **string,$/;"	f	file:
ReadEsignalHeader	HTKLib/HWave.c	/^Boolean ReadEsignalHeader(FILE *f, long *nSamp, long *sampP, short *sampS,$/;"	f
ReadFieldList	HTKLib/esignal.c	/^ReadFieldList(FieldList *list,$/;"	f
ReadFile	HTKLib/HRNLM.c	/^void ReadFile (float *U, FILE *fptr, int nrows, int ncols)$/;"	f
ReadFloat	HTKLib/HShell.c	/^Boolean ReadFloat(Source *src, float *x, int n, Boolean binary)$/;"	f
ReadFoFTab	HLMLib/LGBase.c	/^FoFTab *ReadFoFTab(MemHeap *mem, char *fn)$/;"	f
ReadHGram	HLMLib/LGBase.c	/^static void ReadHGram(char *name, LMFileHdr hdr, int N, LabId *ng, char *fn)$/;"	f	file:
ReadHMMList	HTKTools/HResults.c	/^void ReadHMMList(char *fn)$/;"	f
ReadHTKHeader	HTKLib/HWave.c	/^Boolean ReadHTKHeader(FILE *f, long *nSamp, long *sampP, short *sampS, $/;"	f
ReadHeader	HTKLib/esignal.c	/^ReadHeader(char     **version,  \/* version (output) *\/$/;"	f
ReadHeaderInfo	HLMLib/LModel.c	/^void ReadHeaderInfo(Source *src, BackOffLM *lm, char *line1)$/;"	f
ReadIOConfig	HTKLib/HParm.c	/^static IOConfig ReadIOConfig(IOConfig p)$/;"	f	file:
ReadIdList	HTKTools/HDMan.c	/^int ReadIdList(Source *src, LabId *argList)$/;"	f
ReadIdList	HTKTools/HLEd.c	/^int ReadIdList(Source *src,LabId *argList)$/;"	f
ReadInt	HTKLib/HShell.c	/^Boolean ReadInt(Source *src, int *i, int n, Boolean binary)$/;"	f
ReadIntVec	HTKLib/HMath.c	/^Boolean ReadIntVec(Source *src, IntVec v, Boolean binary)$/;"	f
ReadIntpltLM	HTKLib/HLM.c	/^static void ReadIntpltLM(LModel *lm, char *fn)$/;"	f	file:
ReadLMHeader	HLMLib/LUtil.c	/^LMHdrKind ReadLMHeader(MemHeap *mem, Source *src, IOFilter filter,$/;"	f
ReadLMWord	HTKLib/HLM.c	/^static char *ReadLMWord(char *buf)$/;"	f	file:
ReadLMWord	HTKLib/HRNLM.c	/^static char *ReadLMWord(Source* source, char *buf)$/;"	f	file:
ReadLModel	HTKLib/HLM.c	/^LModel *ReadLModel(MemHeap *heap,char *fn, int iditer)$/;"	f
ReadLabId	HTKTools/HLEd.c	/^LabId ReadLabId(Source *src)$/;"	f
ReadLabel	HTKLib/HLabel.c	/^Boolean ReadLabel(FILE *f, char *buf)$/;"	f
ReadLattice	HTKLib/HNet.c	/^Lattice *ReadLattice(FILE *file, MemHeap *heap, Vocab *voc,$/;"	f
ReadLine	HTKLib/HShell.c	/^Boolean ReadLine(Source *src,char *s)$/;"	f
ReadMLPLM	HTKLib/HLM.c	/^static void ReadMLPLM(LModel *lm, char *fn)$/;"	f	file:
ReadMapHeader	HLMLib/LCMap.c	/^static void ReadMapHeader(Source *src, ClassMap *cm, int *entries)$/;"	f	file:
ReadMapHeader	HLMLib/LWMap.c	/^static void ReadMapHeader(Source *src, WordMap *wm)$/;"	f	file:
ReadMatBigram	HTKLib/HLM.c	/^static void ReadMatBigram(LModel *lm,char *fn)$/;"	f	file:
ReadMatrix	HTKLib/HMath.c	/^Boolean ReadMatrix(Source *src, Matrix m, Boolean binary)$/;"	f
ReadNGram	HLMLib/LGBase.c	/^void ReadNGram(NGSource *ngs, NGram ng)$/;"	f
ReadNGrams	HTKLib/HLM.c	/^static int ReadNGrams(NGramLM *nglm,int n,int count, Boolean bin)$/;"	f	file:
ReadNativeArray	HTKLib/esig_nat.c	/^ReadNativeArray(Array *array,$/;"	f	file:
ReadNativeData	HTKLib/esig_nat.c	/^ReadNativeData(FieldSpec *field,$/;"	f	file:
ReadNativeFieldList	HTKLib/esig_nat.c	/^ReadNativeFieldList(FieldList *listp, \/* output variable *\/$/;"	f
ReadNativeFieldSpec	HTKLib/esig_nat.c	/^ReadNativeFieldSpec(FILE *file)$/;"	f	file:
ReadNativeRecord	HTKLib/esig_nat.c	/^ReadNativeRecord(FieldSpec  **fields,$/;"	f
ReadNativeSamples	HTKLib/esig_nat.c	/^ReadNativeSamples(void      *data,$/;"	f
ReadNativeString	HTKLib/esig_nat.c	/^ReadNativeString(char **string, FILE *file)$/;"	f	file:
ReadNextWord	HTKTools/HDMan.c	/^Boolean ReadNextWord(DBuffer *db)$/;"	f
ReadObs	HTKLib/HParm.c	/^static void ReadObs(ParmBuf pbuf, int outRow,Observation *o)$/;"	f	file:
ReadOneLattice	HTKLib/HNet.c	/^Lattice *ReadOneLattice(Source *src, MemHeap *heap, Vocab *voc,$/;"	f
ReadOptSpace	HTKLib/esig_asc.c	/^ReadOptSpace(FILE *file)$/;"	f	file:
ReadPreamble	HTKLib/esignal.c	/^ReadPreamble(char **version,    \/* version (output) *\/$/;"	f
ReadRNLM	HTKLib/HLM-RNNLM.c	/^static void ReadRNLM(LModel* lm, char* fn, Boolean usefrnnlm, Boolean usecuedrnnlm, float cuedversion)$/;"	f	file:
ReadRawString	HTKLib/HShell.c	/^Boolean ReadRawString(Source *src, char *s)$/;"	f
ReadRecord	HTKLib/esignal.c	/^ReadRecord(FieldSpec    **fields,$/;"	f
ReadRow	HTKLib/HLM.c	/^int ReadRow(Vector v)$/;"	f
ReadRuleDef	HLMTools/LGPrep.c	/^void ReadRuleDef(char *s, RuleSet *rset)$/;"	f
ReadRuleSet	HLMTools/LGPrep.c	/^void ReadRuleSet(char *fn, RuleSet *rset)$/;"	f
ReadSamples	HTKLib/esignal.c	/^ReadSamples(void        *data,$/;"	f
ReadScript	HTKTools/HDMan.c	/^void ReadScript(char *scriptFn, DBuffer *db, Boolean isInput)$/;"	f
ReadScript	HTKTools/HLEd.c	/^void ReadScript(char *scriptFn)$/;"	f
ReadSetDef	HLMTools/LGPrep.c	/^void ReadSetDef(char *s, RuleSet *rset)$/;"	f
ReadShort	HTKLib/HShell.c	/^Boolean ReadShort(Source *src, short *s, int n, Boolean binary)$/;"	f
ReadShortVec	HTKLib/HMath.c	/^Boolean ReadShortVec(Source *src, ShortVec v, Boolean binary)$/;"	f
ReadSpace	HTKLib/esig_asc.c	/^ReadSpace(FILE *file)$/;"	f	file:
ReadString	HTKLib/HShell.c	/^Boolean ReadString(Source *src, char *s){  $/;"	f
ReadStringWithLen	HTKLib/HShell.c	/^Boolean ReadStringWithLen(Source *src, char *s, int buflen)$/;"	f
ReadTopicMatrixFile	HTKLib/HRNLM.c	/^void ReadTopicMatrixFile (RNNLM *rnnlm)$/;"	f
ReadTriMat	HTKLib/HMath.c	/^Boolean ReadTriMat(Source *src, TriMat m, Boolean binary)$/;"	f
ReadUntilLine	HTKLib/HShell.c	/^void ReadUntilLine (Source *src, char *s)$/;"	f
ReadVector	HTKLib/HMath.c	/^Boolean ReadVector(Source *src, Vector v, Boolean binary)$/;"	f
ReadWPGrammar	HTKTools/HBuild.c	/^void ReadWPGrammar(WPGrammar *wpg, Vocab * voc, char *gramFn)$/;"	f
ReadWordFromLine	HTKTools/HResults.c	/^Boolean ReadWordFromLine(Source *src, char *s)$/;"	f
Realft	HTKLib/HSigP.c	/^void Realft (Vector s)$/;"	f
RebuildAETab	HTKTools/HLStats.c	/^void RebuildAETab(AEntry **aelists)$/;"	f
RebuildLM	HLMLib/LPCalc.c	/^void RebuildLM(BackOffLM *lm, int *cutOff, float *wdThresh, LMProbType tgtPType) $/;"	f
RebuildNGrams	HLMLib/LPCalc.c	/^static int RebuildNGrams(BackOffLM *lm,int cxSize,int nSize,FLEntry **context)$/;"	f	file:
Recognition Tools	HTKBook/htkoview.tex	/^tool \\htool{HSmooth}\\index{hsmooth@\\htool{HSmooth}} is used for this.$/;"	u
Record	HTKTools/HSLab.c	/^Wave Record(long *nSamples, HTime *sampPeriod)$/;"	f
RecordFileStats	HTKTools/HResults.c	/^Boolean RecordFileStats(CellPtr p)$/;"	f
RecordHeap	HTKLib/HMem.c	/^static void RecordHeap(MemHeap *x)$/;"	f	file:
RecordOp	HTKTools/HSLab.c	/^void RecordOp(OpType op, LLink p)$/;"	f
RecordSize	HTKLib/esignal.c	/^RecordSize(FieldList list,$/;"	f
RecordTriphone	HTKTools/HHEd.c	/^void RecordTriphone(HLink left, HLink right, MLink ml)$/;"	f
RecoverArcsForNode	HTKLib/HLat.c	/^void RecoverArcsForNode(Lattice *lat, LNode *ln)$/;"	f
RectWin	HTKTools/HSLab.c	/^} RectWin;$/;"	t	typeref:struct:__anon148	file:
RedrawHButton	HTKLib/HGraf.c	/^void RedrawHButton(HButton *btn)$/;"	f
RedrawHButton	HTKLib/HGraf.null.c	/^void RedrawHButton(HButton *btn)$/;"	f
RedrawHButton	HTKLib/HGraf_WIN32.c	/^void RedrawHButton(HButton *btn)$/;"	f
RedrawHButtonList	HTKLib/HGraf.c	/^void RedrawHButtonList(HButton *btnlst)$/;"	f
RedrawHButtonList	HTKLib/HGraf.null.c	/^void RedrawHButtonList(HButton *btnlst)$/;"	f
RedrawHButtonList	HTKLib/HGraf_WIN32.c	/^void RedrawHButtonList(HButton *btnlst)$/;"	f
RefAlign	HTKLib/HRec.c	/^static void RefAlign(Align *align)$/;"	f	file:
RefC2LPC	HTKLib/HSigP.c	/^void RefC2LPC (Vector k, Vector a)$/;"	f
RefPath	HTKLib/HRec.c	/^static void RefPath(Path *path)$/;"	f	file:
Reference Section	HTKBook/htkbook-pdf.tex	/^\\include{hlmfiles}$/;"	p
Reference Section	HTKBook/htkbook.tex	/^\\include{hlmfiles}$/;"	p
RegAcc	HTKLib/HAdapt.c	/^} RegAcc;$/;"	t	typeref:struct:__anon94	file:
RegClassesCommand	HTKTools/HHEd.c	/^void RegClassesCommand(void) $/;"	f
RegNode	HTKLib/HModel.h	/^} RegNode ;$/;"	t	typeref:struct:_RegNode
RegTree	HTKLib/HModel.h	/^typedef struct RegTree {$/;"	s
RegTree	HTKLib/HModel.h	/^} RegTree;             $/;"	t	typeref:struct:RegTree
Register	HTKLib/HShell.c	/^void Register(char *ver, char *sccs)$/;"	f
RegisterExtFileName	HTKLib/HShell.c	/^char * RegisterExtFileName(char *s)$/;"	f
Regress	HTKLib/HSigP.c	/^static void Regress(float *data, int vSize, int n, int step, int offset,$/;"	f	file:
RelToken	HTKLib/HRec.c	/^RelToken;$/;"	t	typeref:struct:reltoken	file:
RemDuplicates	HTKTools/HDMan.c	/^void RemDuplicates(DBuffer *db)$/;"	f
RemMean	HTKTools/HHEd.c	/^void RemMean(Vector src, Vector tgt)$/;"	f
RemMeansCommand	HTKTools/HHEd.c	/^void RemMeansCommand(void)$/;"	f
RemOutliers	HTKTools/HHEd.c	/^void RemOutliers(CLink *cvec, Matrix idist, Matrix gdist, int *numClust, $/;"	f
RemOutliersCommand	HTKTools/HHEd.c	/^void RemOutliersCommand(void)$/;"	f
RemStress	HTKTools/HDMan.c	/^void RemStress(WordBuf *wb, LabId *args)$/;"	f
RemTop	HTKTools/HHEd.c	/^MixtureElem RemTop(void)$/;"	f
RemWordFromClass	HLMLib/LCMap.c	/^void RemWordFromClass(ClassMap *c, int clndx, int wdndx)$/;"	f
RemoveDiscon	HTKTools/HParse.c	/^static void RemoveDiscon(HPNetwork *net)$/;"	f	file:
RemoveGlue	HTKTools/HParse.c	/^static void  RemoveGlue(HPNetwork *network)$/;"	f	file:
RenameHMMSetIdCommand	HTKTools/HHEd.c	/^void RenameHMMSetIdCommand(void)$/;"	f
ReplaceOp	HTKTools/HLEd.c	/^int ReplaceOp(LabList *ll,LabId *args)$/;"	f
ReplacePhoneOp	HTKTools/HDMan.c	/^void ReplacePhoneOp(WordBuf *wb, LabId *args)$/;"	f
ReplaceUnigrams	HLMTools/HLMCopy.c	/^void ReplaceUnigrams(char *fn, BackOffLM *lm)$/;"	f
ReplaceWordOp	HTKTools/HDMan.c	/^void ReplaceWordOp(WordBuf *wb, LabId *args)$/;"	f
ReplayAudio	HTKTools/HVite.c	/^void ReplayAudio(BufferInfo info)$/;"	f
ReplayBuf	HTKLib/HAudio.c	/^}ReplayBuf;$/;"	t	typeref:struct:__anon53	file:
ReportOutput	HTKTools/HCompV.c	/^void ReportOutput()$/;"	f
ReportUsage	HLMTools/Cluster.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/HLMCopy.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LAdapt.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LBuild.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LFoF.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LGCopy.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LGList.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LGPrep.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LLink.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LMerge.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LNewMap.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LNorm.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LPlex.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LSubset.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HBuild.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HCompV.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HCopy.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HDMan.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HERest.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HHEd.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HInit.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HLEd.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HLRescore.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HLStats.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HList.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HMMIRest.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HParse.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HQuant.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HRest.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HResults.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HSGen.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HSLab.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HSmooth.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HVite.c	/^void ReportUsage(void)$/;"	f
Reset	HTKLib/HRNLM.c	/^void Reset (Layer *self)$/;"	f
ResetAccCache	HTKLib/HAdapt.c	/^void ResetAccCache(void)$/;"	f
ResetAccessInfo	HLMLib/LModel.c	/^void ResetAccessInfo(BackOffLM *lm)$/;"	f
ResetChannelSession	HTKLib/HParm.c	/^void ResetChannelSession(char *confName)$/;"	f
ResetComp	HTKLib/HAdapt.c	/^static void ResetComp(MixPDF *mp)$/;"	f	file:
ResetHMMPreComps	HTKLib/HTrain.c	/^void ResetHMMPreComps(HLink hmm, int nStreams)$/;"	f
ResetHMMSet	HTKLib/HModel.c	/^void ResetHMMSet(HMMSet *hset)$/;"	f
ResetHMMWtAccs	HTKLib/HTrain.c	/^void ResetHMMWtAccs(HLink hmm, int nStreams)$/;"	f
ResetHeap	HTKLib/HMem.c	/^void ResetHeap(MemHeap *x)$/;"	f
ResetHeaps	HTKTools/HSmooth.c	/^void ResetHeaps(void)$/;"	f
ResetHooks	HTKLib/HUtil.c	/^void ResetHooks(HMMSet *hset,char *what)$/;"	f
ResetMLPLMCache	HTKLib/HLM.c	/^void ResetMLPLMCache(LModel *lm)$/;"	f
ResetObsCache	HTKLib/HAdapt.c	/^void ResetObsCache(void)$/;"	f
ResetPreComps	HTKLib/HTrain.c	/^void ResetPreComps(HMMSet *hset)$/;"	f
ResetReplayBuf	HTKLib/HAudio.c	/^static void ResetReplayBuf(AudioIn a)$/;"	f	file:
ResetStacks	HTKLib/HFB.c	/^static void ResetStacks(AlphaBeta *ab)$/;"	f	file:
ResetUtilItemList	HTKLib/HUtil.c	/^void ResetUtilItemList()$/;"	f
ResetXFormHMMSet	HTKLib/HAdapt.c	/^void ResetXFormHMMSet(HMMSet *hset)$/;"	f
ResizeLinkSet	HTKTools/HParse.c	/^static void ResizeLinkSet(LinkSet *ls, int newSize)$/;"	f	file:
ResizeSTriMat	HTKTools/HHEd.c	/^STriMat ResizeSTriMat(HMMSet *hset,STriMat m, int n, char type, float pad)$/;"	f
ResizeSVector	HTKTools/HHEd.c	/^SVector ResizeSVector(HMMSet *hset,SVector v, int n, char type, float pad)$/;"	f
ResolveFilterList	HLMTools/LGList.c	/^void ResolveFilterList(void)$/;"	f
RestCoVar	HTKTools/HRest.c	/^Boolean RestCoVar(MixPDF *mp, int vSize, Vector minV,$/;"	f
RestMean	HTKTools/HRest.c	/^void RestMean(Vector mean, int vSize)$/;"	f
RestMixWeights	HTKTools/HRest.c	/^void RestMixWeights(int state, int s, StreamElem *se)$/;"	f
RestStream	HTKTools/HRest.c	/^void RestStream(int state, int s, StreamElem *se, int vSize)$/;"	f
RestTransP	HTKTools/HRest.c	/^void RestTransP(void)$/;"	f
RestoreAccs	HTKLib/HTrain.c	/^void RestoreAccs(HMMSet *hset){ RestoreAccsParallel(hset,0); }$/;"	f
RestoreAccsParallel	HTKLib/HTrain.c	/^void RestoreAccsParallel(HMMSet *hset, int index)$/;"	f
RestorePDF	HTKLib/HTrain.c	/^void RestorePDF(MixPDF *mp, int index){$/;"	f
RetrieveCommandLine	HTKLib/HShell.c	/^char *RetrieveCommandLine(void)$/;"	f
RetrieveESIGFieldList	HTKLib/HWave.c	/^void RetrieveESIGFieldList(HFieldList *fList)$/;"	f
ReturnLMName	HLMTools/HLMCopy.c	/^char *ReturnLMName(int fmt)$/;"	f
ReturnLMName	HLMTools/LAdapt.c	/^char *ReturnLMName(int fmt)$/;"	f
ReturnLMName	HLMTools/LBuild.c	/^char *ReturnLMName(int fmt)$/;"	f
ReturnLMName	HLMTools/LMerge.c	/^char *ReturnLMName(int fmt)$/;"	f
ReturnLMName	HLMTools/LNorm.c	/^char *ReturnLMName(int fmt)$/;"	f
ReturnStatus	HTKLib/HShell.h	/^typedef enum {FAIL=-1, SUCCESS=0} ReturnStatus;$/;"	t	typeref:enum:__anon81
Rhw	HTKLib/HRNLM.h	/^    float *Phw, *Rhw;$/;"	m	struct:_Layer
RightTriCxt	HTKTools/HLEd.c	/^LabId RightTriCxt(LLink l)$/;"	f
RotRows	HTKLib/HMath.c	/^static void RotRows(DMatrix M, int i, int k, $/;"	f	file:
RuleDef	HLMTools/LGPrep.c	/^} RuleDef;$/;"	t	typeref:struct:ruledef	file:
RuleSet	HLMTools/LGPrep.c	/^} RuleSet;$/;"	t	typeref:struct:__anon28	file:
RuleSummary	HLMTools/LGPrep.c	/^void RuleSummary(void)$/;"	f
RunSilDet	HTKLib/HParm.c	/^void RunSilDet(ParmBuf pbuf,Boolean cleared)$/;"	f
S	HTKLib/HFB.h	/^  int S;              \/* number of data streams *\/$/;"	m	struct:__anon136
S	HTKLib/HFBLat.h	/^  int S;$/;"	m	struct:__anon54
S	HTKLib/HMap.c	/^static int S;$/;"	v	file:
S	HTKLib/HUtil.h	/^   int S;            \/* num Streams = hset->swidth[0] *\/$/;"	m	struct:__anon38
S	HTKTools/HMMIRest.c	/^static int S;                    \/* number of data streams *\/   \/*! Equals 1 or error![?] *\/$/;"	v	file:
SANITY	HTKLib/HRec.c	45;"	d	file:
SAVECOMPRESSED	HTKLib/HParm.c	/^   SAVECOMPRESSED,\/* Save output files in compressed form *\/$/;"	e	enum:__anon77	file:
SAVEWITHCRC	HTKLib/HParm.c	/^   SAVEWITHCRC,   \/* Add crc check to output files *\/$/;"	e	enum:__anon77	file:
SBDEF	HTKTools/HLEd.c	/^   SBDEF,   EXPAND, IFILL,  SORT,   WBDEF,  VBDEF,  LCTXT,  $/;"	e	enum:__anon141	file:
SCANBUFMAX	HTKTools/HParse.c	1298;"	d	file:
SCHAR	HTKLib/esignal.h	72;"	d
SCHAR_COMPLEX	HTKLib/esignal.h	79;"	d
SCHCX_FMT	HTKLib/esig_asc.c	91;"	d	file:
SCHCX_W	HTKLib/esig_asc.c	90;"	d	file:
SCHCX_WFMT	HTKLib/esig_asc.c	92;"	d	file:
SCH_FMT	HTKLib/esig_asc.c	67;"	d	file:
SCH_W	HTKLib/esig_asc.c	66;"	d	file:
SCH_WFMT	HTKLib/esig_asc.c	68;"	d	file:
SCRIBE	HTKLib/HWave.h	/^        SCRIBE,            \/* UK Scribe databases *\/$/;"	e	enum:__anon36
SCRIBE Label Files	HTKBook/labels.tex	/^are used on both the prototype and final versions of the TIMIT CD ROM.$/;"	u
SCROLL_PT	HTKTools/HSLab.c	100;"	d	file:
SDES1	HTKLib/HWave.h	/^        SDES1,             \/* Sound Designer I format *\/$/;"	e	enum:__anon36
SDes1Header	HTKLib/HWave.c	/^} SDes1Header;$/;"	t	typeref:struct:__anon102	file:
SELFCALSILDET	HTKLib/HParm.c	/^   SELFCALSILDET, \/* Self calibrating silence detection on each utterance *\/$/;"	e	enum:__anon77	file:
SEMISYM	HTKTools/HParse.c	/^             LTRISYM,RTRISYM,EQSYM, SEMISYM, BARSYM, PERCENTSYM, $/;"	e	enum:_Symbol	file:
SEMIT	HTKLib/HModel.h	/^enum _XFormKind {MLLRMEAN, MLLRCOV, MLLRVAR, CMLLR, SEMIT};$/;"	e	enum:_XFormKind
SETLEV	HTKTools/HLEd.c	/^   RCTXT,   TCTXT,  SETLEV, DELLEV, SPLLEV, ISIL,$/;"	e	enum:__anon141	file:
SET_totalProbScale	HTKLib/HFBLat.c	144;"	d	file:
SEntry	HTKLib/HLM.h	/^} SEntry;$/;"	t	typeref:struct:sentry
SH	HTKTools/HHEd.c	/^                         TC , UT , MT , SH , SU , SW , SK ,$/;"	e	enum:__anon168	file:
SHAREDHS	HTKLib/HModel.h	/^enum _HSetKind {PLAINHS, SHAREDHS, TIEDHS, DISCRETEHS};$/;"	e	enum:_HSetKind
SHELL	HTKLib/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	HTKTools/Makefile	/^SHELL =	\/bin\/sh$/;"	m
SHIFTKEY	HTKLib/HGraf.h	/^enum _KeyType {NORMALKEY, SHIFTKEY, COMMANDKEY, CONTROLKEY, $/;"	e	enum:_KeyType
SHORT	HTKLib/esignal.h	70;"	d
SHORTEN	HTKLib/HWave.c	/^   SHORTEN,     \/* CUED Shorten *\/$/;"	e	enum:_CompressType	file:
SHORTPACK	HTKLib/HWave.c	/^   SHORTPACK,   \/* MIT shortpack-v0 *\/$/;"	e	enum:_CompressType	file:
SHORT_COMPLEX	HTKLib/esignal.h	78;"	d
SHRCX_FMT	HTKLib/esig_asc.c	87;"	d	file:
SHRCX_W	HTKLib/esig_asc.c	86;"	d	file:
SHRCX_WFMT	HTKLib/esig_asc.c	88;"	d	file:
SHR_FMT	HTKLib/esig_asc.c	59;"	d	file:
SHR_W	HTKLib/esig_asc.c	58;"	d	file:
SHR_WFMT	HTKLib/esig_asc.c	60;"	d	file:
SIDEXFORMEXT	HTKLib/HParm.c	/^   SIDEXFORMEXT, \/* extension for use with side-based xforms *\/$/;"	e	enum:__anon77	file:
SIDEXFORMMASK	HTKLib/HParm.c	/^   SIDEXFORMMASK,\/* mask for use with side-based xforms *\/$/;"	e	enum:__anon77	file:
SILDISCARD	HTKLib/HParm.c	/^   SILDISCARD,    \/* Energy below which frames discarded when calibrating *\/$/;"	e	enum:__anon77	file:
SILENERGY	HTKLib/HParm.c	/^   SILENERGY,     \/* Silence detector threshold *\/$/;"	e	enum:__anon77	file:
SILFLOOR	HTKLib/HParm.c	/^   SILFLOOR,      \/* Silence floor in dBs *\/$/;"	e	enum:__anon77	file:
SILGLCHCOUNT	HTKLib/HParm.c	/^   SILGLCHCOUNT,  \/* Silence glitch count *\/$/;"	e	enum:__anon77	file:
SILMARGIN	HTKLib/HParm.c	/^   SILMARGIN,     \/* Margin of silence around speech *\/$/;"	e	enum:__anon77	file:
SILSEQCOUNT	HTKLib/HParm.c	/^   SILSEQCOUNT,   \/* Silence sequence count *\/$/;"	e	enum:__anon77	file:
SIMPLEDIFFS	HTKLib/HParm.c	/^   SIMPLEDIFFS,   \/* Use simple differences *\/$/;"	e	enum:__anon77	file:
SING_QUOTE	HTKLib/HShell.h	80;"	d
SK	HTKTools/HHEd.c	/^                         TC , UT , MT , SH , SU , SW , SK ,$/;"	e	enum:__anon168	file:
SLEN	HTKTools/HSLab.c	73;"	d	file:
SMAX	HTKLib/HShell.h	77;"	d
SMEntry	HLMLib/LModel.h	/^} SMEntry;$/;"	t	typeref:struct:_SMEntry
SMatrix	HTKLib/HMem.h	/^typedef Matrix SMatrix;    \/* shared matrix[1..nrows][1..ncols] *\/$/;"	t
SMatrixElemSize	HTKLib/HMem.c	/^size_t SMatrixElemSize(int nrows,int ncols)$/;"	f
SORT	HTKTools/HLEd.c	/^   SBDEF,   EXPAND, IFILL,  SORT,   WBDEF,  VBDEF,  LCTXT,  $/;"	e	enum:__anon141	file:
SORT_FREQ	HLMTools/Cluster.c	79;"	d	file:
SORT_WMAP	HLMTools/Cluster.c	78;"	d	file:
SOURCEFORMAT	HTKLib/HParm.c	/^   SOURCEFORMAT,  \/* FileFormat *\/$/;"	e	enum:__anon77	file:
SOURCEKIND	HTKLib/HParm.c	/^   SOURCEKIND,    \/* ParmKind *\/ $/;"	e	enum:__anon77	file:
SOURCERATE	HTKLib/HParm.c	/^   SOURCERATE,    \/* Source sample rate in 100ns *\/$/;"	e	enum:__anon77	file:
SOutP	HTKLib/HModel.c	/^LogFloat SOutP(HMMSet *hset, int s, Observation *x, StreamElem *se)$/;"	f
SP	HTKLib/HArc.h	/^  Boolean SP; \/*short pause.  If (SP) rest of variables are NULL.*\/$/;"	m	struct:_Acoustic
SP	HTKLib/HRec.c	58;"	d	file:
SPCGLCHCOUNT	HTKLib/HParm.c	/^   SPCGLCHCOUNT,  \/* Speech glitch count *\/$/;"	e	enum:__anon77	file:
SPCSEQCOUNT	HTKLib/HParm.c	/^   SPCSEQCOUNT,   \/* Speech sequence count *\/$/;"	e	enum:__anon77	file:
SPEECHTHRESH	HTKLib/HParm.c	/^   SPEECHTHRESH,  \/* Speech detector threshold *\/$/;"	e	enum:__anon77	file:
SPLITP	HTKTools/HDMan.c	/^              REPLACEP, CONREPLACE, MERGEP, SPLITP, DELETEP, DELSOURCE, $/;"	e	enum:__anon158	file:
SPLLEV	HTKTools/HLEd.c	/^   RCTXT,   TCTXT,  SETLEV, DELLEV, SPLLEV, ISIL,$/;"	e	enum:__anon141	file:
SQUASH	HLMLib/LGBase.h	41;"	d
SRAND	HTKLib/HMath.c	1624;"	d	file:
SRAND	HTKLib/HMath.c	1628;"	d	file:
SS	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon168	file:
ST	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon168	file:
STACKSIZE	HTKTools/HCopy.c	98;"	d	file:
STACKSIZE	HTKTools/HSLab.c	144;"	d	file:
STATE	HTKLib/HModel.c	/^   STATE, TMIX, MIXTURE, STREAM, SWEIGHTS,$/;"	e	enum:__anon40	file:
STATE_KEY	HTKLib/HUtil.c	/^   TRANSP_KEY, STATE_KEY, DUR_KEY, WEIGHTS_KEY,$/;"	e	enum:__anon132	file:
STATICPRIOR	HTKTools/HMMIRest.c	/^static Boolean STATICPRIOR = FALSE;$/;"	v	file:
STREAM	HTKLib/HModel.c	/^   STATE, TMIX, MIXTURE, STREAM, SWEIGHTS,$/;"	e	enum:__anon40	file:
STREAMINFO	HTKLib/HModel.c	/^   NUMSTATES, STREAMINFO, VECSIZE, $/;"	e	enum:__anon40	file:
STREAM_KEY	HTKLib/HUtil.c	/^   MIX_KEY, MEAN_KEY, STREAM_KEY, COV_KEY$/;"	e	enum:__anon132	file:
STRINGARG	HTKLib/HShell.h	/^typedef enum {SWITCHARG, STRINGARG, INTARG, FLOATARG, NOARG} ArgKind;$/;"	e	enum:__anon88
STR_ALLOC_SIZE	HTKLib/esig_asc.c	37;"	d	file:
STR_BG	HTKTools/HSLab.c	1148;"	d	file:
STR_FG	HTKTools/HSLab.c	1147;"	d	file:
STR_FIELD	HTKLib/HNet.c	/^typedef enum {UNK_FIELD, STR_FIELD, INT_FIELD, FLT_FIELD} LatFieldType;$/;"	e	enum:__anon55	file:
STriMat	HTKLib/HMem.h	/^typedef Matrix STriMat;    \/* shared matrix[1..nrows][1..i] (lower tri) *\/$/;"	t
STriMatElemSize	HTKLib/HMem.c	/^size_t STriMatElemSize(int size)$/;"	f
SU	HTKTools/HHEd.c	/^                         TC , UT , MT , SH , SU , SW , SK ,$/;"	e	enum:__anon168	file:
SUBLATHASHSIZE	HTKLib/HNet.c	312;"	d	file:
SUCCESS	HTKLib/HShell.h	/^typedef enum {FAIL=-1, SUCCESS=0} ReturnStatus;$/;"	e	enum:__anon81
SUN16_AUDIO	HTKLib/HAudio.c	107;"	d	file:
SUNAU8	HTKLib/HWave.h	/^        SUNAU8,            \/* Sun 8 bit MuLaw .au format *\/$/;"	e	enum:__anon36
SUNSO	HTKLib/HWave.c	/^   SUNSO,      \/* big-endian ie hi byte first *\/$/;"	e	enum:_SrcOrder	file:
SUPPORT_EXACT_CORRECTNESS	HTKLib/HExactMPE.h	38;"	d
SUPPORT_QUINPHONE	HTKLib/HFBLat.h	119;"	d
SVD	HTKLib/HMath.c	/^void SVD(DMatrix A, DMatrix U, DMatrix V, DVector d)$/;"	f
SVector	HTKLib/HMem.h	/^typedef Vector SVector;    \/* shared vector[1..size]   *\/$/;"	t
SVectorElemSize	HTKLib/HMem.c	/^size_t SVectorElemSize(int size){ return (size+1)*sizeof(float)+2*sizeof(Ptr); }$/;"	f
SW	HTKTools/HHEd.c	/^                         TC , UT , MT , SH , SU , SW , SK ,$/;"	e	enum:__anon168	file:
SWEIGHTS	HTKLib/HModel.c	/^   STATE, TMIX, MIXTURE, STREAM, SWEIGHTS,$/;"	e	enum:__anon40	file:
SWITCHARG	HTKLib/HShell.h	/^typedef enum {SWITCHARG, STRINGARG, INTARG, FLOATARG, NOARG} ArgKind;$/;"	e	enum:__anon88
S_EOF	HTKLib/HLabel.c	/^   S_LBB, S_LBA, S_UTS, S_EOF$/;"	e	enum:_ScribeLab	file:
S_LBA	HTKLib/HLabel.c	/^   S_LBB, S_LBA, S_UTS, S_EOF$/;"	e	enum:_ScribeLab	file:
S_LBB	HTKLib/HLabel.c	/^   S_LBB, S_LBA, S_UTS, S_EOF$/;"	e	enum:_ScribeLab	file:
S_UTS	HTKLib/HLabel.c	/^   S_LBB, S_LBA, S_UTS, S_EOF$/;"	e	enum:_ScribeLab	file:
SafeCopyString	HTKLib/HNet.c	142;"	d	file:
SameArcs	HTKLib/HArc.c	/^Boolean SameArcs(LArc *a1, LArc *a2){ \/*word arcs have same times & phones *\/$/;"	f
SameGrams	HLMLib/LGBase.c	/^Boolean SameGrams(int N, NGram ng1, NGram ng2)$/;"	f
SameHGrams	HLMLib/LGBase.c	/^static Boolean SameHGrams(int N, NGram ng, LabId *tg)$/;"	f	file:
SameLinks	HTKTools/HParse.c	/^static Boolean SameLinks(int a1, int a2)$/;"	f	file:
SameTriphone	HTKTools/HHEd.c	/^MLink SameTriphone(HLink left, HLink right)$/;"	f
SampleType	HTKTools/HSLab.c	/^typedef signed short SampleType;$/;"	t	file:
SamplesInAudio	HTKLib/HAudio.c	/^int SamplesInAudio(AudioIn a)$/;"	f
SamplesToPlay	HTKLib/HAudio.c	/^int SamplesToPlay(AudioOut a)$/;"	f
SampsInAudioFrame	HTKLib/HAudio.c	/^int SampsInAudioFrame(AudioIn a)$/;"	f
SampsInWaveFrame	HTKLib/HWave.c	/^int SampsInWaveFrame(Wave w)$/;"	f
SaveAllXForms	HTKLib/HModel.c	/^void SaveAllXForms(HMMSet *hset, char *fname, Boolean binary)$/;"	f
SaveBuffer	HTKLib/HParm.c	/^ReturnStatus SaveBuffer(ParmBuf pbuf, char *fname, FileFormat ff)$/;"	f
SaveClassMap	HLMLib/LCMap.c	/^void SaveClassMap(char *fn, ClassMap *c)$/;"	f
SaveCommandLine	HTKLib/HShell.c	/^static void SaveCommandLine(int argc, char **argv)$/;"	f	file:
SaveESPSLabels	HTKLib/HLabel.c	/^static void SaveESPSLabels( FILE *f, Transcription *t)$/;"	f	file:
SaveHMMList	HTKLib/HModel.c	/^ReturnStatus SaveHMMList(HMMSet *hset, char *fname)$/;"	f
SaveHMMSet	HTKLib/HModel.c	/^ReturnStatus SaveHMMSet(HMMSet *hset, char *hmmDir, char *hmmExt, char *macroExt, Boolean binary)$/;"	f
SaveHTKLabels	HTKLib/HLabel.c	/^static void SaveHTKLabels( FILE *f, Transcription *t) $/;"	f	file:
SaveInOneFile	HTKLib/HModel.c	/^void SaveInOneFile(HMMSet *hset, char *fname)$/;"	f
SaveInReplay	HTKLib/HAudio.c	/^static void SaveInReplay(AudioIn a, short x)$/;"	f	file:
SaveInputXForm	HTKLib/HModel.c	/^void SaveInputXForm(HMMSet *hset, InputXForm *xf, char *fname, Boolean binary)$/;"	f
SaveLabs	HTKTools/HCopy.c	/^void SaveLabs(char *tgt, Transcription *t)$/;"	f
SaveLangModel	HLMLib/LModel.c	/^void SaveLangModel(char *lmFn, BackOffLM *lm)$/;"	f
SaveLattice	HTKTools/HBuild.c	/^void SaveLattice(Lattice *lat, char *latFn, LatFormat format)$/;"	f
SaveLattice	HTKTools/HParse.c	/^static void SaveLattice(Lattice *lat, char *latFn, LatFormat format)$/;"	f	file:
SaveMacros	HTKLib/HModel.c	/^static void SaveMacros(FILE *f, HMMSet *hset, short fidx, Boolean binary)$/;"	f	file:
SaveModel	HTKTools/HCompV.c	/^void SaveModel(char *outfn)$/;"	f
SaveModel	HTKTools/HInit.c	/^void SaveModel(char *outfn)$/;"	f
SaveNGram	HLMLib/LModel.c	/^static int SaveNGram(FILE *f, int G, BackOffLM *lm)$/;"	f	file:
SaveOneXForm	HTKLib/HModel.c	/^void SaveOneXForm(HMMSet *hset, AdaptXForm *xform, char *fname, Boolean binary)$/;"	f
SaveOutBuffer	HLMTools/LGCopy.c	/^static void SaveOutBuffer(void)$/;"	f	file:
SaveToMasterfile	HTKLib/HLabel.c	/^ReturnStatus SaveToMasterfile(char *fname)$/;"	f
SaveUltraNGrams	HLMLib/LModel.c	/^static void SaveUltraNGrams(FILE *f, BackOffLM *lm)$/;"	f	file:
SaveWordMap	HLMLib/LWMap.c	/^void SaveWordMap(char *fn, WordMap *w, Boolean noHeader)$/;"	f
SavedMixes	HTKLib/HFBLat.c	/^static MixOcc *SavedMixes[SMAX]; \/* [1..S][1..nPDFs[s]] *\/$/;"	v	file:
SavedMixesSize	HTKLib/HFBLat.c	/^static int SavedMixesSize[SMAX]; $/;"	v	file:
ScaleAccs	HTKLib/HTrain.c	/^double ScaleAccs(HMMSet *hset, float wt)$/;"	f
ScaleAccsParallel	HTKLib/HTrain.c	/^double ScaleAccsParallel(HMMSet *hset, float wt, int index)$/;"	f
ScalePDF	HTKLib/HTrain.c	/^double ScalePDF(MixPDF *mpdf, int vSize, int index, float wt)$/;"	f
ScanDict	HTKTools/HDMan.c	/^Boolean ScanDict(DBuffer *db, LabId reqd)$/;"	f
ScanLLF	HTKLib/HLat.c	/^Boolean ScanLLF (LLFInfo *llf, char *fn, char *ext)$/;"	f
Schar	HTKLib/esignal.h	/^typedef signed char			Schar;$/;"	t
ScharComplex	HTKLib/esignal.h	/^typedef struct {Schar	real, imag;}	ScharComplex;$/;"	t	typeref:struct:__anon50
ScribeLab	HTKLib/HLabel.c	/^typedef enum _ScribeLab ScribeLab;$/;"	t	typeref:enum:_ScribeLab	file:
ScriptItem	HTKTools/HDMan.c	/^}ScriptItem;$/;"	t	typeref:struct:_ScriptItem	file:
ScriptItem	HTKTools/HLEd.c	/^}ScriptItem;$/;"	t	typeref:struct:_ScriptItem	file:
ScriptWord	HTKLib/HShell.c	/^static char * ScriptWord(void)$/;"	f	file:
ScriptWord	HTKTools/HERest.c	/^char *ScriptWord(FILE *script, char *scriptBuf)$/;"	f
SegLength	HTKLib/HTrain.c	/^int SegLength(SegStore ss, int i)$/;"	f
SegStore	HTKLib/HTrain.h	/^typedef struct _SegStoreRec * SegStore;$/;"	t	typeref:struct:_SegStoreRec
SegStoreRec	HTKLib/HTrain.h	/^}SegStoreRec;$/;"	t	typeref:struct:_SegStoreRec
Select	HTKTools/HSGen.c	/^int Select(NodeId n, int nfoll, LogFloat *prob)$/;"	f
Semi-Tied Transform Estimation  htool  HERest	HTKBook/train.tex	/^\\]$/;"	u
SendToEditBuffer	HLMTools/LGPrep.c	/^void SendToEditBuffer(LabId id)$/;"	f
SeqMatch	HTKTools/HDMan.c	/^Boolean SeqMatch(int nMerge, LabId *list1, LabId *list2)$/;"	f
SeqMatch	HTKTools/HLEd.c	/^LLink SeqMatch(LLink l,int numIds, LabId *idList)$/;"	f
Sequence	HTKLib/HTrain.h	/^typedef SequenceInfo *Sequence;$/;"	t
SequenceCov	HTKLib/HTrain.c	/^void SequenceCov(Sequence ss, CovKind ck, Covariance cov, Vector mean)$/;"	f
SequenceInfo	HTKLib/HTrain.h	/^}SequenceInfo;$/;"	t	typeref:struct:__anon108
SequenceMean	HTKLib/HTrain.c	/^void SequenceMean(Sequence ss, Vector mean)$/;"	f
SetAInfo	HTKLib/HAdapt.c	/^static void SetAInfo(HMMSet *hset, AdaptXForm *xform, Boolean parent)$/;"	f	file:
SetAccCache	HTKLib/HAdapt.c	/^static void SetAccCache(AdaptXForm *xform)$/;"	f	file:
SetActive	HTKLib/HGraf.c	/^void SetActive(HButton *btnlst, Boolean active)$/;"	f
SetActive	HTKLib/HGraf.null.c	/^void SetActive(HButton *btnlst, Boolean active)$/;"	f
SetActive	HTKLib/HGraf_WIN32.c	/^void SetActive(HButton *btnlst, Boolean active)$/;"	f
SetActiveCount	HTKTools/HDMan.c	/^void SetActiveCount(void)$/;"	f
SetAlpha	HTKTools/HRest.c	/^LogDouble SetAlpha(int seg)$/;"	f
SetAudioSpDetParms	HTKLib/HParm.c	/^static void SetAudioSpDetParms(ParmBuf pbuf, float dur, Boolean warn)$/;"	f	file:
SetBarWidth	HTKTools/HList.c	/^void SetBarWidth(int itemWidth)$/;"	f
SetBaseAccsTime	HTKLib/HAdapt.c	/^void SetBaseAccsTime(int t)$/;"	f
SetBeamTaper	HTKLib/HFB.c	/^static void SetBeamTaper(PruneInfo *p, short *qDms, int Q, int T)$/;"	f	file:
SetBeta	HTKLib/HFB.c	/^static LogDouble SetBeta(AlphaBeta *ab, FBInfo *fbInfo, UttInfo *utt)$/;"	f	file:
SetBeta	HTKTools/HRest.c	/^LogDouble SetBeta(int seg)$/;"	f
SetBetaPlus	HTKLib/HFBLat.c	/^static void SetBetaPlus()$/;"	f	file:
SetButtonLit	HTKLib/HGraf.c	/^void SetButtonLit(HButton *btn, Boolean lit)$/;"	f
SetButtonLit	HTKLib/HGraf.null.c	/^void SetButtonLit(HButton *btn, Boolean lit)$/;"	f
SetButtonLit	HTKLib/HGraf_WIN32.c	/^void SetButtonLit(HButton *btn, Boolean lit)$/;"	f
SetCase	HTKTools/HDMan.c	/^static void SetCase(EdOp cmd, char *s)$/;"	f	file:
SetChannel	HTKLib/HParm.c	/^ReturnStatus SetChannel(char *confName)$/;"	f
SetClassWords	HLMLib/LCMap.c	/^static void SetClassWords(ClassEntry *ce, WordMap *wmap, int nItem, LabId *cword)$/;"	f	file:
SetCodeStyle	HTKLib/HParm.c	/^static void SetCodeStyle(IOConfig cf)$/;"	f	file:
SetConfParms	HLMTools/Cluster.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/HLMCopy.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LAdapt.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LBuild.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LFoF.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LGCopy.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LGList.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LGPrep.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LLink.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LMerge.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LNewMap.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LNorm.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LPlex.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LSubset.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HBuild.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HCompV.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HCopy.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HDMan.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HERest.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HHEd.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HInit.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HLEd.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HLRescore.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HLStats.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HList.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HMMIRest.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HParse.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HQuant.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HRest.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HResults.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HSGen.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HSLab.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HSmooth.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HVite.c	/^void SetConfParms(void)$/;"	f
SetCorrectness	HTKLib/HFBLat.c	/^static void SetCorrectness(FBLatInfo *fbInfo, Lattice *numLat){  $/;"	f	file:
SetCorrectnessAsError	HTKLib/HFBLat.c	/^static void SetCorrectnessAsError(FBLatInfo *fbInfo, Lattice *numLat){    \/* re the "CALCASERROR" option, other version of approx MPE. *\/$/;"	f	file:
SetCovKindUsage	HTKLib/HModel.c	/^void SetCovKindUsage (HMMSet *hset)$/;"	f
SetCovs	HTKTools/HCompV.c	/^void SetCovs(void)$/;"	f
SetDef	HLMTools/LGPrep.c	/^} SetDef;$/;"	t	typeref:struct:__anon26	file:
SetDoingFourthAcc	HTKLib/HFBLat.c	/^void SetDoingFourthAcc(Boolean DO, int indx){$/;"	f
SetEntryState	HTKLib/HRec.c	/^static void SetEntryState(NetNode *node,TokenSet *src)$/;"	f	file:
SetExtSpDetParms	HTKLib/HParm.c	/^static void SetExtSpDetParms(ParmBuf pbuf, float dur, Boolean warn)$/;"	f	file:
SetFieldOrdering	HTKLib/esignal.c	/^SetFieldOrdering(FieldList  *list,$/;"	f
SetGCStats	HTKTools/HHEd.c	/^void SetGCStats(void)$/;"	f
SetGDist	HTKTools/HHEd.c	/^void SetGDist(CLink *cvec, Matrix id, Matrix gd, int N)$/;"	f
SetHSetKindCommand	HTKTools/HHEd.c	/^void SetHSetKindCommand(void)$/;"	f
SetHook	HTKLib/HMem.c	/^void SetHook(Ptr m, Ptr ptr)$/;"	f
SetIDist	HTKTools/HHEd.c	/^void SetIDist(CLink *cvec, Matrix id, int N, char type)$/;"	f
SetIndexes	HTKLib/HModel.c	/^void SetIndexes(HMMSet *hset)$/;"	f
SetInputXFormConfig	HTKLib/HParm.c	/^static void SetInputXFormConfig(IOConfig cf, InputXForm *xf)$/;"	f	file:
SetLabSeg	HTKTools/HCopy.c	/^void SetLabSeg(Transcription *tr)$/;"	f
SetMInfo	HTKLib/HAdapt.c	/^static void SetMInfo(HMMSet *hset, AdaptXForm *xform)$/;"	f	file:
SetMLPLMVocab	HTKLib/HLM.c	/^void SetMLPLMVocab(LModel *lm)$/;"	f
SetMSize	HTKTools/HHEd.c	/^void SetMSize(STriMat m,int n)$/;"	f
SetMacroHook	HTKLib/HUtil.c	/^void SetMacroHook(MLink ml,Ptr hook)$/;"	f
SetMacroUse	HTKLib/HUtil.c	/^void SetMacroUse(MLink ml,int use)$/;"	f
SetMinDurs	HTKLib/HFB.c	/^void SetMinDurs(HMMSet *hset)$/;"	f
SetModelBetaPlus	HTKLib/HFBLat.c	/^void SetModelBetaPlus(int t, int q){$/;"	f
SetNGInfo	HLMLib/LGBase.c	/^static NGInfo SetNGInfo(int N)$/;"	f	file:
SetNewConfig	HTKLib/HParm.c	/^void SetNewConfig(char *confName)$/;"	f
SetNext	HLMLib/LGBase.c	/^static void SetNext(NGSource *ngs, Byte ngRawBuf[GSIZE])$/;"	f	file:
SetNodeOcc	HTKLib/HAdapt.c	/^static float SetNodeOcc(RegNode *node, BaseClass *bclass)$/;"	f	file:
SetNullContexts	HTKLib/HNet.c	/^void SetNullContexts(Lattice *lat,int xc)$/;"	f
SetNullLRecurse	HTKLib/HNet.c	/^void SetNullLRecurse(PronHolder *pInst,Lattice *lat,int xc)$/;"	f
SetNullRRecurse	HTKLib/HNet.c	/^void SetNullRRecurse(PronHolder *pInst,Lattice *lat,int xc)$/;"	f
SetObsCache	HTKLib/HAdapt.c	/^static void SetObsCache(AdaptXForm *xform, Boolean parent)$/;"	f	file:
SetOccSums	HTKTools/HHEd.c	/^Vector SetOccSums(CLink *cvec, int N)$/;"	f
SetOccr	HTKTools/HRest.c	/^void SetOccr(LogDouble pr, int seg)$/;"	f
SetOcct	HTKLib/HFB.c	/^static void SetOcct(HLink hmm, int q, Vector occt, Vector *occa,$/;"	f	file:
SetOutP	HTKTools/HRest.c	/^void SetOutP(int seg)$/;"	f
SetParentXForm	HTKLib/HAdapt.c	/^void SetParentXForm(HMMSet *hset, AdaptXForm *xform)$/;"	f
SetParmHMMSet	HTKLib/HParm.c	/^void SetParmHMMSet(Ptr aset)$/;"	f
SetParsePhysicalHMM	HTKLib/HUtil.c	/^void SetParsePhysicalHMM(Boolean parse)$/;"	f
SetPruningLevels	HTKLib/HRec.c	/^void SetPruningLevels(VRecInfo *vri,int maxBeam,LogFloat genBeam,$/;"	f
SetSampKindCommand	HTKTools/HHEd.c	/^void SetSampKindCommand(void)$/;"	f
SetScriptFile	HTKLib/HShell.c	/^ReturnStatus SetScriptFile(char *fn)$/;"	f
SetSelfCalSpDetParms	HTKLib/HParm.c	/^static void SetSelfCalSpDetParms(ParmBuf pbuf)$/;"	f	file:
SetSemiTiedAvCov	HTKLib/HAdapt.c	/^static void SetSemiTiedAvCov(HMMSet *hset)$/;"	f	file:
SetSemiTiedVFloor	HTKLib/HModel.c	/^void SetSemiTiedVFloor(HMMSet *hset)$/;"	f
SetSet	HTKLib/HUtil.c	/^void SetSet(IntSet s)$/;"	f
SetSilDetParms	HTKLib/HParm.c	/^static void SetSilDetParms(ParmBuf pbuf, TriState silMeasure)$/;"	f	file:
SetSize	HTKTools/HHEd.c	/^int SetSize(char *hname, StreamElem *ste \/*nMix must be +ve*\/, int tgt){ \/*returns nDefunct*\/$/;"	f
SetStreamWidthCommand	HTKTools/HHEd.c	/^void SetStreamWidthCommand(void)$/;"	f
SetStreamWidths	HTKLib/HParm.c	/^void  SetStreamWidths(ParmKind pk, int size, short *swidth, Boolean *eSep)$/;"	f
SetTraceCommand	HTKTools/HHEd.c	/^void SetTraceCommand(void)$/;"	f
SetTraceFB	HTKLib/HFB.c	/^void SetTraceFB(void)$/;"	f
SetTreeName	HTKTools/HHEd.c	/^static void SetTreeName(char *name) {$/;"	f	file:
SetUpForCoding	HTKLib/HParm.c	/^static void SetUpForCoding(MemHeap *x, IOConfig cf, int frSize)$/;"	f	file:
SetUse	HTKLib/HMem.c	/^void SetUse(Ptr m,int n)$/;"	f
SetVFloor	HTKLib/HModel.c	/^void SetVFloor(HMMSet *hset, Vector *vFloor, float minVar)$/;"	f
SetVSize	HTKTools/HHEd.c	/^void SetVSize(SVector v,int n)$/;"	f
SetVol	HTKLib/HAudio.c	/^static void SetVol(AudioOut a, float volume)$/;"	f	file:
SetVolume	HTKLib/HAudio.c	/^void SetVolume(AudioOut a, int volume)$/;"	f
SetWaveSpDetParms	HTKLib/HParm.c	/^static void SetWaveSpDetParms(ParmBuf pbuf)$/;"	f	file:
SetXForm	HTKLib/HAdapt.c	/^void SetXForm(HMMSet *hset, AdaptXForm *xform)$/;"	f
Setotprob	HTKLib/HFB.c	/^static void Setotprob(AlphaBeta *ab, FBInfo *fbInfo, ParmBuf pbuf, $/;"	f	file:
Setotprob	HTKLib/HFBLat.c	/^static void Setotprob(int t)$/;"	f	file:
SetuFlags	HTKTools/HERest.c	/^void SetuFlags(void)$/;"	f
SetuFlags	HTKTools/HInit.c	/^void SetuFlags(void)$/;"	f
SetuFlags	HTKTools/HMMIRest.c	/^void SetuFlags(UPDSet *uFlags)$/;"	f
SetuFlags	HTKTools/HRest.c	/^void SetuFlags(void)$/;"	f
SetuFlags	HTKTools/HSmooth.c	/^void SetuFlags(void)$/;"	f
ShStrP	HTKLib/HFB.c	/^static float * ShStrP(HMMSet *hset, StreamElem *ste, Vector v, int t,$/;"	f	file:
ShStrP	HTKLib/HFBLat.c	/^static float * ShStrP(Vector v, int t, StreamElem *ste, AdaptXForm *xform, MemHeap *amem)$/;"	f	file:
ShiftReg	HLMTools/LAdapt.c	/^} ShiftReg;$/;"	t	typeref:struct:__anon34	file:
ShiftReg	HLMTools/LGPrep.c	/^} ShiftReg;$/;"	t	typeref:struct:__anon29	file:
Short2DProb	HTKLib/HModel.c	/^LogFloat Short2DProb(short s)$/;"	f
ShortComplex	HTKLib/esignal.h	/^typedef struct {short	real, imag;}	ShortComplex;$/;"	t	typeref:struct:__anon49
ShortVec	HTKLib/HMem.h	/^typedef short *ShortVec;   \/* short vector[1..size] *\/$/;"	t
ShortVecElemSize	HTKLib/HMem.c	/^size_t ShortVecElemSize(int size) { return (size+1)*sizeof(short); }$/;"	f
ShortVecSize	HTKLib/HMem.c	/^int ShortVecSize(ShortVec v)$/;"	f
ShowAbbrRawGram	HLMLib/LGBase.c	/^static void ShowAbbrRawGram(int N, NGram ng, WordMap *wm)$/;"	f	file:
ShowAbbrTxtGram	HLMLib/LGBase.c	/^static void ShowAbbrTxtGram(int N, LabId *ng)$/;"	f	file:
ShowAccs	HTKLib/HTrain.c	/^void ShowAccs(HMMSet *hset, UPDSet uFlags){ ShowAccsParallel(hset, uFlags, 0); }$/;"	f
ShowAccsParallel	HTKLib/HTrain.c	/^void ShowAccsParallel(HMMSet *hset, UPDSet uFlags, int index)$/;"	f
ShowAlignment	HTKTools/HInit.c	/^void ShowAlignment(int segNum, int segLen, IntVec states, IntVec *mixes)$/;"	f
ShowClassMap	HLMLib/LCMap.c	/^void ShowClassMap(ClassMap *c)$/;"	f
ShowClusterSet	HTKLib/HTrain.c	/^void ShowClusterSet(ClusterSet *cs)$/;"	f
ShowDB	HTKTools/HDMan.c	/^void ShowDB(DBuffer *db, char * title)$/;"	f
ShowDMatrix	HTKLib/HMath.c	/^void ShowDMatrix(char * title,DMatrix m,int maxCols,int maxRows)$/;"	f
ShowDVector	HTKLib/HMath.c	/^void ShowDVector(char * title, DVector v,int maxTerms)$/;"	f
ShowDict	HTKLib/HDict.c	/^void ShowDict(Vocab *voc)$/;"	f
ShowGFSons	HLMLib/LGBase.c	/^static void ShowGFSons(int N, GFLink gf, char * parent, WordMap *wm)$/;"	f	file:
ShowHMMSet	HTKTools/HHEd.c	/^void ShowHMMSet(void)$/;"	f
ShowInputSetTree	HLMLib/LGBase.c	/^static void ShowInputSetTree(NGInputSet *inset)$/;"	f	file:
ShowInputState	HLMLib/LGBase.c	/^static void ShowInputState(char *mess, NGInputSet *inset)$/;"	f	file:
ShowIntVec	HTKLib/HMath.c	/^void ShowIntVec(char * title, IntVec v,int maxTerms)$/;"	f
ShowLattice	HTKLib/HLat.c	/^void ShowLattice(Lattice *lat)$/;"	f
ShowMacros	HTKTools/HHEd.c	/^void ShowMacros(HMMDef *hmm)$/;"	f
ShowMatrix	HTKLib/HMath.c	/^void ShowMatrix(char * title,Matrix m,int maxCols,int maxRows)$/;"	f
ShowNgram	HLMTools/LGList.c	/^Boolean ShowNgram(int N, NGram ng)$/;"	f
ShowP	HTKTools/HInit.c	/^void ShowP(int col, Vector colVec)$/;"	f
ShowSegNum	HTKTools/HRest.c	/^void ShowSegNum(int seg)$/;"	f
ShowSeqMat	HTKTools/HInit.c	/^void ShowSeqMat(Sequence **seqMat)$/;"	f
ShowShortVec	HTKLib/HMath.c	/^void ShowShortVec(char * title, ShortVec v,int maxTerms)$/;"	f
ShowStats	HLMLib/LModel.c	/^static void ShowStats(FILE *f, AccessInfo *acs, char *lmstr)$/;"	f	file:
ShowTraceBack	HTKTools/HInit.c	/^void ShowTraceBack(int len, short **tB)$/;"	f
ShowTreesCommand	HTKTools/HHEd.c	/^void ShowTreesCommand(void)$/;"	f
ShowTriMat	HTKLib/HMath.c	/^void ShowTriMat(char * title,TriMat m,int maxCols,int maxRows)$/;"	f
ShowVector	HTKLib/HMath.c	/^void ShowVector(char * title,Vector v,int maxTerms)$/;"	f
ShowWaveInfo	HTKLib/HWave.c	/^static void ShowWaveInfo(Wave w)$/;"	f	file:
ShowWhere	HTKTools/HHEd.c	/^void ShowWhere(int state, int stream, int mix)$/;"	f
ShowWordMap	HLMLib/LWMap.c	/^void ShowWordMap(WordMap *w)$/;"	f
ShowWords	HTKLib/HNet.c	/^void ShowWords(Lattice *lat,Vocab *voc,HMMSetCxtInfo *hci)$/;"	f
ShrinkNode	HTKTools/HParse.c	/^static void ShrinkNode(Link p)$/;"	f	file:
Shrt2Prob	HLMLib/LModel.c	/^static float Shrt2Prob(UShort s)$/;"	f	file:
SignalFillBufferAndStopAudio	HTKLib/HAudio.c	/^static void SignalFillBufferAndStopAudio(AudioIn a)$/;"	f	file:
SkipComment	HTKLib/HShell.c	/^void SkipComment(Source *src)$/;"	f
SkipComment	HTKLib/esig_asc.c	/^SkipComment(FILE *file)$/;"	f	file:
SkipHeader	HTKTools/HBuild.c	/^Boolean SkipHeader(FILE *f)$/;"	f
SkipHeader	HTKTools/HDMan.c	/^void SkipHeader(Source *src, int skipHeaderLines)$/;"	f
SkipLine	HTKLib/HShell.c	/^Boolean SkipLine(Source *src)$/;"	f
SkipSpace	HTKLib/esig_asc.c	/^SkipSpace(int ch, FILE *file)$/;"	f	file:
SkipSpaces	HTKLib/HUtil.c	/^static void SkipSpaces(void)$/;"	f	file:
SkipSpacesEoln	HTKTools/HBuild.c	/^Boolean SkipSpacesEoln(FILE *f)$/;"	f
SkipToWord	HLMTools/LGPrep.c	/^char *SkipToWord(char *s)$/;"	f
SkipWhiteSpace	HTKLib/HShell.c	/^void SkipWhiteSpace(Source *src)$/;"	f
SliceTriMat	HTKTools/HHEd.c	/^Matrix SliceTriMat(Matrix mat, int i, int j)$/;"	f
SliceVector	HTKTools/HHEd.c	/^Vector SliceVector(Vector vec, int i, int j)$/;"	f
SmoothTransFromPriorHMM	HTKTools/HMMIRest.c	/^static void SmoothTransFromPriorHMM(int index, float Tau){$/;"	f	file:
SmoothWeightsFromPriorHMM	HTKTools/HMMIRest.c	/^static void SmoothWeightsFromPriorHMM(int index, float Tau){$/;"	f	file:
SmoothWtAcc	HTKTools/HSmooth.c	/^void SmoothWtAcc(StreamElem *ste, float l, int M)$/;"	f
SolveQuadratic	HTKTools/HMMIRest.c	/^Boolean SolveQuadratic(double a, double b, double c, double *ans1, double *ans2){$/;"	f
SortArcs	HTKLib/HArc.c	/^void SortArcs( ArcInfo *aInfo )$/;"	f
SortEntries	HTKLib/HVQ.c	/^static VQNode SortEntries(VQNode *list, short rootId)$/;"	f	file:
SortGFList	HLMLib/LGBase.c	/^static void SortGFList(NGInputSet *inset)$/;"	f	file:
SortNGBuffer	HLMLib/LGBase.c	/^void SortNGBuffer(NGBuffer *ngb)$/;"	f
SortOOV	HLMTools/LPlex.c	/^static int SortOOV(PStats *ps)$/;"	f	file:
SortOp	HTKTools/HLEd.c	/^void SortOp(LabList *rl)$/;"	f
SortWordMap	HLMLib/LWMap.c	/^void SortWordMap(WordMap *wm)$/;"	f
Source	HTKLib/HShell.h	/^} Source;$/;"	t	typeref:struct:__anon84
SpMatch	HTKTools/HResults.c	/^Boolean SpMatch(char *spkrpat, char *spkr, char *str)$/;"	f
SpRMatch	HTKLib/HShell.c	/^static Boolean SpRMatch(char *s,char *p,char *spkr,$/;"	f	file:
SpRMatch	HTKTools/HResults.c	/^static Boolean SpRMatch(char *s,char *p,char *spkr,$/;"	f	file:
SpecLogModulus	HTKLib/HSigP.c	/^void SpecLogModulus(Vector s, Vector m, Boolean invert)$/;"	f
SpecModulus	HTKLib/HSigP.c	/^void SpecModulus(Vector s, Vector m)$/;"	f
SpecPhase	HTKLib/HSigP.c	/^void SpecPhase(Vector s, Vector m)$/;"	f
Spkr	HTKTools/HResults.c	/^} Spkr;$/;"	t	typeref:struct:_Spkr	file:
SpkrAcc	HTKTools/HCompV.c	/^}SpkrAcc;                  $/;"	t	typeref:struct:__anon152	file:
SpkrAccListItem	HTKTools/HCompV.c	/^typedef struct SpkrAccListItem{$/;"	s	file:
SpkrAccListItem	HTKTools/HCompV.c	/^}SpkrAccListItem;$/;"	t	typeref:struct:SpkrAccListItem	file:
SpkrName	HTKTools/HCompV.c	/^   char SpkrName[MAXSTRLEN];             \/* speaker name *\/$/;"	m	struct:__anon152	file:
SplitLevels	HTKTools/HLEd.c	/^Transcription *SplitLevels(LabList *rl)$/;"	f
SplitMix	HTKTools/HHEd.c	/^void SplitMix(MixtureElem *mi,MixtureElem *m01,MixtureElem *m02,int vSize)$/;"	f
SplitName	HTKTools/HParse.c	/^}SplitName;$/;"	t	typeref:struct:__anon157	file:
SplitPath	HTKLib/HLabel.c	/^static void SplitPath(char *path, char *name, char *subdir, char *tryspec)$/;"	f	file:
SplitPhon	HTKTools/HDMan.c	/^void SplitPhon(Pronunciation *p, int nArgs, LabId *args)$/;"	f
SplitPhoneOp	HTKTools/HDMan.c	/^void SplitPhoneOp(WordBuf *wb, int nArgs, LabId *args)$/;"	f
SplitStreamCommand	HTKTools/HHEd.c	/^void SplitStreamCommand(Boolean userWidths)$/;"	f
SplitStreams	HTKTools/HHEd.c	/^void SplitStreams(HMMSet *hset,StateInfo *si,Boolean simple,Boolean first)$/;"	f
SplitTreeNode	HTKTools/HHEd.c	/^void SplitTreeNode(Tree *tree, Node *node)$/;"	f
SplitTriName	HTKTools/HParse.c	/^static void SplitTriName(LabId n, SplitName *x)$/;"	f	file:
SplitVectors	HTKLib/HTrain.c	/^static void SplitVectors(int n, int n1, int n2)$/;"	f	file:
SpotRec	HTKTools/HResults.c	/^} SpotRec;$/;"	t	typeref:struct:_SpotRec	file:
SrcOrder	HTKLib/HWave.c	/^}SrcOrder;$/;"	t	typeref:enum:_SrcOrder	file:
SrcPosition	HTKLib/HShell.c	/^char *SrcPosition(Source src, char *s)$/;"	f
StackInitialised	HTKLib/HArc.c	/^Boolean StackInitialised=FALSE;$/;"	v
StartAudi	HTKLib/HAudio.c	/^static void StartAudi(AudioIn a)$/;"	f	file:
StartAudioInput	HTKLib/HAudio.c	/^void StartAudioInput(AudioIn a, int sig)$/;"	f
StartAudioOutput	HTKLib/HAudio.c	/^void StartAudioOutput(AudioOut a, long nSamples, short *buf)$/;"	f
StartAudioSignal	HTKLib/HAudio.c	/^static void StartAudioSignal(void)$/;"	f	file:
StartBuffer	HTKLib/HParm.c	/^void StartBuffer(ParmBuf pbuf)$/;"	f
StartOfWord	HTKLib/HArc.h	215;"	d
StartOfWord	HTKLib/HExactMPE.c	93;"	d	file:
StartOfWord	HTKLib/HFBLat.c	133;"	d	file:
StartRecognition	HTKLib/HRec.c	/^void StartRecognition(VRecInfo *vri,Network *net,$/;"	f
StartTime	HTKLib/HFBLat.c	/^static int StartTime=0;     \/* This is a value that we use to help calculating the PreComp's of$/;"	v	file:
StatReport	HTKTools/HERest.c	/^void StatReport(HMMSet *hset)$/;"	f
StatReport	HTKTools/HMMIRest.c	/^void StatReport(void) \/*This is used by other programs so I have had to change it back to how it was.*\/$/;"	f
StatReport	HTKTools/HSmooth.c	/^void StatReport(void)$/;"	f
StateDistance	HTKTools/HHEd.c	/^float StateDistance(ILink i1, ILink i2)$/;"	f
StateElem	HTKLib/HModel.h	/^} StateElem;$/;"	t	typeref:struct:__anon63
StateInfo	HTKLib/HModel.h	/^} StateInfo;$/;"	t	typeref:struct:__anon62
StatsInfo	HTKLib/HLat.c	/^} StatsInfo;$/;"	t	typeref:struct:_StatsInfo	file:
Step 1 - Generation of Initial Maximum Likelihood Models	HTKBook/exampsys.tex	/^related command-lines are given below.$/;"	u
Step 1 - the Task Grammar	HTKBook/exampsys.tex	/^testing and a task grammar must be defined.$/;"	u
Step 14 - Evaluation of the Adapted System	HTKBook/exampsys.tex	/^of transforms.$/;"	u
Step 2 - Training Data LM Creation	HTKBook/exampsys.tex	/^stored in the MMF \\texttt{hmm20\/MODELS}.$/;"	u
Step 2 - the Dictionary	HTKBook/exampsys.tex	/^the file \\texttt{wdnet} (see Fig~\\href{f:step1}).$/;"	u
Step 3 - Recording the Data	HTKBook/exampsys.tex	/^model \\texttt{sil} as their pronunciations and null output symbols.  $/;"	u
Step 3 - Word Lattice Creation	HTKBook/exampsys.tex	/^The result of the above command is that a bigram LM for the training data in file \\texttt{trainbg.gz}.$/;"	u
Step 4 - Creating the Transcription Files	HTKBook/exampsys.tex	/^the required test data.$/;"	u
Step 4 - Phone Marking of Numerator and Denominator Lattices	HTKBook/exampsys.tex	/^altered or a new list of successful training files created for subsequent stages.$/;"	u
Step 5 - Coding the Data	HTKBook/exampsys.tex	/^\\centrefig{step4}{60}{Step 4}$/;"	u
Step 5 - Generating Discriminatively Trained Models	HTKBook/exampsys.tex	/^files for which both the numerator and denominator lattices exist will be stored in \\texttt{train3.scp}.$/;"	u
Step 6 - Creating Flat Start Monophones	HTKBook/exampsys.tex	/^\\index{monophone HMM!construction of}$/;"	u
Step 7 - Fixing the Silence Models	HTKBook/exampsys.tex	/^\\texttt{hmm3} contains the final set of initialised monophone HMMs.$/;"	u
Step 8 - Realigning the Training Data	HTKBook/exampsys.tex	/^This step is illustrated in Fig.~\\href{f:step7}$/;"	u
Step 9 - Making Triphones from Monophones	HTKBook/exampsys.tex	/^all state distributions can be robustly estimated.$/;"	u
StepAlpha	HTKLib/HFB.c	/^static void StepAlpha(AlphaBeta *ab, int t, int *start, int *end, $/;"	f	file:
StepAlpha	HTKLib/HFBLat.c	/^static void StepAlpha(int t)$/;"	f	file:
StepBack	HTKLib/HFB.c	/^static Boolean StepBack(FBInfo *fbInfo, UttInfo *utt, char * datafn)$/;"	f	file:
StepBar	HTKTools/HSLab.c	/^static void StepBar(BarType *bar, int pos)$/;"	f	file:
StepForward	HTKLib/HFB.c	/^static void StepForward(FBInfo *fbInfo, UttInfo *utt)$/;"	f	file:
StepForward	HTKLib/HFBLat.c	/^static void StepForward()$/;"	f	file:
StepHMM1	HTKLib/HRec.c	/^static void StepHMM1(NetNode *node) \/* Model internal propagation NBEST *\/$/;"	f	file:
StepHMM2	HTKLib/HRec.c	/^static void StepHMM2(NetNode *node) $/;"	f	file:
StepInst1	HTKLib/HRec.c	/^static void StepInst1(NetNode *node) \/* First pass of token propagation (Internal) *\/$/;"	f	file:
StepInst2	HTKLib/HRec.c	/^static void StepInst2(NetNode *node) \/* Second pass of token propagation (External) *\/$/;"	f	file:
StepWord1	HTKLib/HRec.c	/^static void StepWord1(NetNode *node) \/* Just invalidate the tokens *\/$/;"	f	file:
StepWord2	HTKLib/HRec.c	/^static void StepWord2(NetNode *node) \/* Update the path - may be repeated *\/$/;"	f	file:
StopAndFlushAudio	HTKLib/HAudio.c	/^static void StopAndFlushAudio(AudioIn a, Boolean deferred)$/;"	f	file:
StopAudi	HTKLib/HAudio.c	/^static void StopAudi(AudioIn a)$/;"	f	file:
StopAudioInput	HTKLib/HAudio.c	/^void StopAudioInput(AudioIn a)$/;"	f
StopAudioSignal	HTKLib/HAudio.c	/^static void StopAudioSignal(void)$/;"	f	file:
StopBuffer	HTKLib/HParm.c	/^void StopBuffer(ParmBuf pbuf)$/;"	f
StoreAdaptCov	HTKLib/HAdapt.c	/^static Boolean StoreAdaptCov(AdaptXForm *xform)$/;"	f	file:
StoreAdaptMean	HTKLib/HAdapt.c	/^static Boolean StoreAdaptMean(AdaptXForm *xform)$/;"	f	file:
StoreESIGFieldList	HTKLib/HWave.c	/^void StoreESIGFieldList(HFieldList fList)$/;"	f
StoreFEA	HLMLib/LModel.c	/^void StoreFEA(FLEntry *fe, MemHeap *heap)$/;"	f
StoreItem	HTKLib/HTrain.c	/^void StoreItem(Sequence seq, Ptr item)$/;"	f
StoreMLFEntry	HTKLib/HLabel.c	/^static void StoreMLFEntry(MLFEntry *e)$/;"	f	file:
StoreNGram	HLMLib/LGBase.c	/^Boolean StoreNGram(NGBuffer *ngb, NGram ng)$/;"	f
StoreOOV	HLMTools/LPlex.c	/^static void StoreOOV(PStats *ps, LabId wdid, int count)$/;"	f	file:
StoreObsCache	HTKLib/HAdapt.c	/^static Boolean StoreObsCache(AdaptXForm *xform)$/;"	f	file:
StoreSEA	HLMLib/LModel.c	/^void StoreSEA(FLEntry *fe, MemHeap *heap)$/;"	f
StoreTree	HTKLib/HVQ.c	/^static void StoreTree(FILE *f, VQNode n, CovKind ck, short s)$/;"	f	file:
StoreVQTab	HTKLib/HVQ.c	/^void StoreVQTab(VQTable vqTab, char *tabFN)$/;"	f
Str2AdaptKind	HTKLib/HModel.c	/^AdaptKind Str2AdaptKind(char *str)$/;"	f
Str2BaseClassKind	HTKLib/HModel.c	/^BaseClassKind Str2BaseClassKind(char *str)$/;"	f
Str2Format	HTKLib/HWave.c	/^FileFormat Str2Format(char *fmt)$/;"	f
Str2ParmKind	HTKLib/HParm.c	/^ParmKind Str2ParmKind(char *str)$/;"	f
Str2XFormKind	HTKLib/HModel.c	/^XFormKind Str2XFormKind(char *str)$/;"	f
StrArrFromRect	HTKLib/strarr.c	/^StrArrFromRect(long *dim, void *data)$/;"	f
StrArrLen	HTKLib/strarr.c	/^StrArrLen(char **str_arr)$/;"	f
StrArrMaxLen	HTKLib/strarr.c	/^StrArrMaxLen(char **str_arr)$/;"	f
StrArrToRect	HTKLib/strarr.c	/^StrArrToRect(char **strarr, long **dimenp, void **datap)$/;"	f
StrCKind	HTKLib/HShell.h	/^   StrCKind,            \/* string, optionally in dble quotes *\/$/;"	e	enum:__anon85
StrDup	HTKLib/esignal.c	/^StrDup(char *str)$/;"	f
StreamElem	HTKLib/HModel.h	/^}StreamElem;$/;"	t	typeref:struct:__anon61
String2Index	HTKLib/HNLM.c	/^int String2Index(char *string, String2IndexMap map, int num_word)$/;"	f
String2IndexMap	HTKLib/HNLM.h	/^} String2IndexMap;$/;"	t	typeref:struct:string2indexmap
SubCorrectness	HTKLib/HExactMPE.c	/^static float SubCorrectness = -1;   \/* repeat of config also used in HFBLat.c *\/$/;"	v	file:
SubFieldOrder	HTKLib/esignal.c	/^SubFieldOrder(FieldList list, char *prefix)$/;"	f	file:
SubLArc	HTKLib/HLat.c	/^typedef struct _SubLArc SubLArc;$/;"	t	typeref:struct:_SubLArc	file:
SubLNode	HTKLib/HLat.c	/^typedef struct _SubLNode SubLNode;$/;"	t	typeref:struct:_SubLNode	file:
SubLatDef	HTKLib/HNet.h	/^} SubLatDef;$/;"	t	typeref:struct:sublatdef
SubLatList	HTKLib/HNet.c	/^Lattice *SubLatList(Lattice *lat, Lattice *tail, int depth)$/;"	f
SubLattice	HTKLib/HNet.c	/^void SubLattice(Lattice *newlat,NodeId thisNode, NodeId latStart,NodeId latEnd)$/;"	f
SubNetDef	HTKTools/HParse.c	/^} SubNetDef;$/;"	t	typeref:struct:_SubNetDef	file:
SubstFName	HTKLib/HShell.c	/^void SubstFName(char *fname, char *s)$/;"	f
SubstituteSubNet	HTKTools/HParse.c	/^static void SubstituteSubNet(HPNetwork *subNet, Link p)$/;"	f	file:
SumWtChain	HTKTools/HSmooth.c	/^float SumWtChain(WALink wa, Vector v, int dBlk, int M)$/;"	f
SummarisePruning	HTKLib/HFB.c	/^static void SummarisePruning(PruneInfo *p, int Q, int T)$/;"	f	file:
Summary	HTKTools/HDMan.c	/^void Summary(void)$/;"	f
Summary	HTKTools/HHEd.c	/^void Summary(void)$/;"	f
Summary	HTKTools/HLEd.c	/^void Summary(void)$/;"	f
SunAU8Header	HTKLib/HWave.c	/^} SunAU8Header;$/;"	t	typeref:struct:__anon103	file:
SwapAdaptXForms	HTKLib/HAdapt.c	/^static void SwapAdaptXForms(AdaptXForm *xform, AdaptXForm *paxform)$/;"	f	file:
SwapInt32	HTKLib/HShell.c	/^void SwapInt32(int32 *p)$/;"	f
SwapLists	HTKTools/HHEd.c	/^void SwapLists(HMMSet *set,HMMSet *list)$/;"	f
SwapMLLRCovMLLRMean	HTKLib/HAdapt.c	/^static void SwapMLLRCovMLLRMean(AdaptXForm *xform, AdaptXForm *paxform)$/;"	f	file:
SwapMacro	HTKTools/HHEd.c	/^void SwapMacro(HMMSet *hset,char type,Ptr o, Ptr n)$/;"	f
SwapNodeNames	HTKTools/HParse.c	/^void SwapNodeNames(Link l1, Link l2)$/;"	f
SwapSN	HTKTools/HParse.c	/^void SwapSN(SplitName *sn1, SplitName *sn2)$/;"	f
SwapShort	HTKLib/HShell.c	/^void SwapShort(short *p)$/;"	f
SwapXForm	HTKLib/HAdapt.c	/^static void SwapXForm(HMMSet *hset, AdaptXForm *xform)$/;"	f	file:
Symbol	HTKLib/HModel.c	/^} Symbol;$/;"	t	typeref:enum:__anon40	file:
SyncBuffers	HTKLib/HParm.c	/^Boolean SyncBuffers(ParmBuf pbuf,ParmBuf pbuf2)$/;"	f
SyncStr	HLMLib/LModel.c	/^void SyncStr(Source *src, char *str)$/;"	f
SyncStr	HTKLib/HLM.c	/^static void SyncStr(char *buf,char *str)$/;"	f	file:
Syntax and Semantics	HTKBook/labels.tex	/^data and label files can be accommodated. $/;"	u
SynthModel	HTKTools/HHEd.c	/^HMMDef *SynthModel(LabId id)$/;"	f
T	HTKLib/HArc.h	/^  int T;       \/* time is 1..T. *\/$/;"	m	struct:ArcInfoStruct
T	HTKLib/HFB.h	/^  int T;              \/* number of frames in utterance *\/$/;"	m	struct:__anon136
T	HTKLib/HFBLat.h	/^  int T;$/;"	m	struct:__anon54
T	HTKTools/HRest.c	/^static int maxT,minT,T;    \/* max,min and current segment lengths *\/$/;"	v	file:
T	HTKTools/HSLab.c	/^static long  T;              \/* number of samples *\/$/;"	v	file:
TARGETFORMAT	HTKLib/HParm.c	/^   TARGETFORMAT,  \/* FileFormat *\/$/;"	e	enum:__anon77	file:
TARGETKIND	HTKLib/HParm.c	/^   TARGETKIND,    \/* ParmKind *\/$/;"	e	enum:__anon77	file:
TARGETRATE	HTKLib/HParm.c	/^   TARGETRATE,    \/* Target sample rate in 100ns *\/$/;"	e	enum:__anon77	file:
TB	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon168	file:
TC	HTKTools/HHEd.c	/^                         TC , UT , MT , SH , SU , SW , SK ,$/;"	e	enum:__anon168	file:
TCTXT	HTKTools/HDMan.c	/^              TCTXT, APPSIL, REMSTRESS, REPLACEW, RAWMODE, $/;"	e	enum:__anon158	file:
TCTXT	HTKTools/HLEd.c	/^   RCTXT,   TCTXT,  SETLEV, DELLEV, SPLLEV, ISIL,$/;"	e	enum:__anon141	file:
TCtxtOp	HTKTools/HDMan.c	/^void TCtxtOp(WordBuf *wb, int nArgs,LabId *args)$/;"	f
TDistance	HTKTools/HHEd.c	/^float TDistance(StreamElem *s1, StreamElem *s2)$/;"	f
TEXT	HTKLib/HRNLM.h	/^enum FileTypeEnum {TEXT, BINARY, COMPRESSED};$/;"	e	enum:FileTypeEnum
TFuncX11	HTKLib/HGraf.c	/^static int   TFuncX11[4] = {$/;"	v	file:
THIRDWINDOW	HTKLib/HParm.c	/^   THIRDWINDOW,$/;"	e	enum:__anon77	file:
THREEACCS	HTKTools/HMMIRest.c	/^static Boolean THREEACCS = FALSE;  \/*  Set TRUE if 3 sets of accs need to be stored (for MPE, or possibly for MMI-MAP) *\/$/;"	v	file:
TI	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon168	file:
TIEDHS	HTKLib/HModel.h	/^enum _HSetKind {PLAINHS, SHAREDHS, TIEDHS, DISCRETEHS};$/;"	e	enum:_HSetKind
TIMES_LABELLED	HTKTools/HSLab.c	103;"	d	file:
TIMIT	HTKLib/HWave.h	/^        TIMIT,             \/* Prototype TIMIT database *\/$/;"	e	enum:__anon36
TIMIT Label Files	HTKBook/labels.tex	/^data structures cannot be saved using  \\ESPSwaves\\ format label files.$/;"	u
TIMIThdr	HTKLib/HWave.c	/^} TIMIThdr;$/;"	t	typeref:struct:__anon100	file:
TMAttachAccs	HTKLib/HTrain.c	/^void TMAttachAccs(HMMSet *hset, MemHeap *x, int nPara)$/;"	f
TMIX	HTKLib/HModel.c	/^   STATE, TMIX, MIXTURE, STREAM, SWEIGHTS,$/;"	e	enum:__anon40	file:
TMProb	HTKLib/HModel.h	/^}TMProb;$/;"	t	typeref:struct:__anon59
TMShowAccs	HTKLib/HTrain.c	/^void TMShowAccs(HMMSet *hset, int index)$/;"	f
TMZeroAccs	HTKLib/HTrain.c	/^void TMZeroAccs(HMMSet *hset, int start, int end)$/;"	f
TMixRec	HTKLib/HModel.h	/^} TMixRec;$/;"	t	typeref:struct:__anon60
TNODE	HTKLib/HModel.c	/^   RCLASS=110, REGTREE, NODE, TNODE,$/;"	e	enum:__anon40	file:
TPI	HTKLib/HMath.h	41;"	d
TR	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon168	file:
TRANSP	HTKLib/HModel.c	/^   DURATION, INVDIAGCOV, TRANSP, DPROB, LLTCOV, LLTCOVAR,$/;"	e	enum:__anon40	file:
TRANSP_KEY	HTKLib/HUtil.c	/^   TRANSP_KEY, STATE_KEY, DUR_KEY, WEIGHTS_KEY,$/;"	e	enum:__anon132	file:
TRCOMMA	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	e	enum:_TrSymbol	file:
TREE	HTKLib/HModel.h	/^enum _AdaptKind {TREE, BASE};$/;"	e	enum:_AdaptKind
TREOF	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	e	enum:_TrSymbol	file:
TREOL	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	e	enum:_TrSymbol	file:
TRINDEX	HLMLib/LModel.c	791;"	d	file:
TRIST	HTKTools/HLEd.c	/^   REPLACE, CHANGE, FIND,   MERGE,  EDOP_DELETE, DEFCON, TRIST,  $/;"	e	enum:__anon141	file:
TRI_UNDEF	HTKLib/HParm.h	/^   TRI_UNDEF=-1     \/* -1 *\/$/;"	e	enum:__anon119
TRLEV	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	e	enum:_TrSymbol	file:
TRNULL	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	e	enum:_TrSymbol	file:
TRNUM	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	e	enum:_TrSymbol	file:
TRSTR	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	e	enum:_TrSymbol	file:
TRUE	HTKLib/HShell.h	/^typedef enum {FALSE=0, TRUE=1} Boolean;$/;"	e	enum:__anon82
TRUE	HTKLib/HShell.h	90;"	d
TRUE	HTKLib/esignal.h	48;"	d
TRUE_dup	HTKLib/HParm.h	/^   TRUE_dup=TRUE,   \/*  1 *\/$/;"	e	enum:__anon119
TYPE_ORDER	HTKLib/esignal.h	97;"	d
T_ACC	HTKLib/HAdapt.c	58;"	d	file:
T_ADT	HTKLib/HAdapt.c	57;"	d	file:
T_ALD	HTKLib/HTrain.c	61;"	d	file:
T_ALF	HTKLib/HFB.c	59;"	d	file:
T_ALF	HTKTools/HRest.c	51;"	d	file:
T_ALL	HTKLib/HNet.c	55;"	d	file:
T_ALN	HTKTools/HInit.c	52;"	d	file:
T_ARC	HTKLib/HArc.c	56;"	d	file:
T_ARC2	HTKLib/HArc.c	57;"	d	file:
T_AUD	HTKLib/HAudio.c	37;"	d	file:
T_BAS	HTKTools/HHEd.c	64;"	d	file:
T_BAS	HTKTools/HLStats.c	48;"	d	file:
T_BAS	HTKTools/HResults.c	42;"	d	file:
T_BET	HTKTools/HRest.c	52;"	d	file:
T_BID	HTKTools/HHEd.c	87;"	d	file:
T_BIG	HTKTools/HLStats.c	50;"	d	file:
T_BOND	HLMTools/Cluster.c	59;"	d	file:
T_BTR	HTKLib/HModel.c	61;"	d	file:
T_BUF	HTKLib/HParm.c	57;"	d	file:
T_CAL	HTKLib/HTrain.c	58;"	d	file:
T_CDI	HTKLib/HTrain.c	59;"	d	file:
T_CGE	HTKLib/HTrain.c	55;"	d	file:
T_CHK	HTKLib/HModel.c	55;"	d	file:
T_CHOP	HTKTools/HLEd.c	47;"	d	file:
T_CHP	HTKLib/HMem.c	36;"	d	file:
T_CLC	HTKLib/HTrain.c	56;"	d	file:
T_CLUST	HTKTools/HQuant.c	48;"	d	file:
T_CLUSTERS	HTKTools/HHEd.c	75;"	d	file:
T_CMDX	HTKTools/HLEd.c	46;"	d	file:
T_CML	HLMLib/LCMap.c	48;"	d	file:
T_CMV	HTKTools/HCompV.c	71;"	d	file:
T_CNT	HTKTools/HInit.c	54;"	d	file:
T_COVS	HTKTools/HCompV.c	68;"	d	file:
T_CPX	HTKLib/HParm.c	58;"	d	file:
T_CST	HTKLib/HNet.c	53;"	d	file:
T_CXT	HTKLib/HNet.c	52;"	d	file:
T_DCM	HTKLib/HTrain.c	57;"	d	file:
T_DET	HTKLib/HAudio.c	36;"	d	file:
T_DET	HTKLib/HParm.c	62;"	d	file:
T_DET	HTKTools/HHEd.c	66;"	d	file:
T_DET	HTKTools/HSGen.c	43;"	d	file:
T_DIC	HTKLib/HDict.c	37;"	d	file:
T_DIC	HTKTools/HLEd.c	52;"	d	file:
T_DLEV	HTKTools/HLEd.c	49;"	d	file:
T_DSOP	HTKTools/HDMan.c	54;"	d	file:
T_DWOP	HTKTools/HDMan.c	55;"	d	file:
T_EDIN	HTKTools/HLEd.c	50;"	d	file:
T_EDW0	HTKTools/HDMan.c	50;"	d	file:
T_EDW1	HTKTools/HDMan.c	51;"	d	file:
T_EVN	HTKTools/HResults.c	43;"	d	file:
T_EXF	HTKLib/HShell.c	54;"	d	file:
T_EXP	HTKLib/HLat.c	60;"	d	file:
T_EXTRA	HLMTools/Cluster.c	58;"	d	file:
T_FB	HTKLib/HLat.c	59;"	d	file:
T_FIL	HTKTools/HLStats.c	51;"	d	file:
T_FILE	HLMTools/Cluster.c	57;"	d	file:
T_FOF	HLMLib/LGBase.c	53;"	d	file:
T_FOF	HLMLib/LPCalc.c	47;"	d	file:
T_FRS	HTKLib/HAdapt.c	64;"	d	file:
T_FRS	HTKTools/HVite.c	61;"	d	file:
T_GMX	HTKLib/HModel.c	62;"	d	file:
T_HASH	HLMLib/LUtil.c	47;"	d	file:
T_HASH	HTKLib/HLabel.c	39;"	d	file:
T_HDR	HLMLib/LUtil.c	46;"	d	file:
T_HPMEMSTAT	HTKTools/HParse.c	93;"	d	file:
T_HPNET	HTKTools/HParse.c	92;"	d	file:
T_HPREMGLUE	HTKTools/HParse.c	94;"	d	file:
T_HTKL	HTKLib/HLabel.c	38;"	d	file:
T_IND	HTKTools/HHEd.c	86;"	d	file:
T_INP	HLMTools/LAdapt.c	62;"	d	file:
T_INP	HLMTools/LGPrep.c	59;"	d	file:
T_INT	HTKTools/HHEd.c	65;"	d	file:
T_INT	HTKTools/HSmooth.c	43;"	d	file:
T_IOP	HTKLib/HShell.c	53;"	d	file:
T_IST	HLMLib/LGBase.c	52;"	d	file:
T_ITM	HTKLib/HUtil.c	53;"	d	file:
T_ITM	HTKTools/HHEd.c	67;"	d	file:
T_ITR	HLMLib/LGBase.c	50;"	d	file:
T_KINDS	HTKTools/HCopy.c	39;"	d	file:
T_LAT	HTKTools/HLRescore.c	61;"	d	file:
T_LD0	HTKTools/HInit.c	48;"	d	file:
T_LD0	HTKTools/HRest.c	48;"	d	file:
T_LD1	HTKTools/HInit.c	49;"	d	file:
T_LD1	HTKTools/HRest.c	49;"	d	file:
T_LGP	HTKTools/HRest.c	62;"	d	file:
T_LLF	HTKLib/HLat.c	63;"	d	file:
T_LOAD	HLMLib/LModel.c	51;"	d	file:
T_LOAD	HTKTools/HCompV.c	69;"	d	file:
T_LOAD	HTKTools/HQuant.c	46;"	d	file:
T_MAC	HTKLib/HModel.c	59;"	d	file:
T_MAC	HTKTools/HHEd.c	71;"	d	file:
T_MAC	HTKTools/HRest.c	55;"	d	file:
T_MAP	HTKTools/HERest.c	76;"	d	file:
T_MAPS	HLMLib/LModel.c	53;"	d	file:
T_MAT	HTKLib/HLabel.c	36;"	d	file:
T_MAT	HTKLib/HParm.c	63;"	d	file:
T_MD	HTKTools/HHEd.c	88;"	d	file:
T_MEAN	HTKTools/HQuant.c	45;"	d	file:
T_MEL	HTKLib/HSigP.c	51;"	d	file:
T_MEM	HLMTools/Cluster.c	60;"	d	file:
T_MEM	HLMTools/LGPrep.c	63;"	d	file:
T_MEM	HTKLib/HLat.c	61;"	d	file:
T_MEM	HTKTools/HCopy.c	41;"	d	file:
T_MEM	HTKTools/HHEd.c	68;"	d	file:
T_MEM	HTKTools/HLEd.c	51;"	d	file:
T_MEM	HTKTools/HLRescore.c	62;"	d	file:
T_MEM	HTKTools/HLStats.c	49;"	d	file:
T_MEM	HTKTools/HResults.c	47;"	d	file:
T_MEM	HTKTools/HVite.c	62;"	d	file:
T_MHASH	HTKLib/HLabel.c	35;"	d	file:
T_MHP	HTKLib/HMem.c	35;"	d	file:
T_MIX	HTKLib/HFB.c	62;"	d	file:
T_MIX	HTKTools/HInit.c	53;"	d	file:
T_MLF	HTKLib/HLabel.c	34;"	d	file:
T_MMU	HTKTools/HVite.c	63;"	d	file:
T_MOD	HTKLib/HNet.c	54;"	d	file:
T_MOP	HLMLib/LGBase.c	51;"	d	file:
T_MRE	HTKTools/HRest.c	60;"	d	file:
T_MRG	HTKLib/HLat.c	64;"	d	file:
T_NAC	HTKLib/HTrain.c	60;"	d	file:
T_NGEN	HTKLib/HRec.c	41;"	d	file:
T_NKY	HTKTools/HResults.c	45;"	d	file:
T_NPHN	HTKTools/HDMan.c	53;"	d	file:
T_OBC	HTKLib/HAdapt.c	62;"	d	file:
T_OBP	HTKTools/HInit.c	55;"	d	file:
T_OBS	HTKLib/HParm.c	61;"	d	file:
T_OBS	HTKTools/HVite.c	60;"	d	file:
T_OCC	HTKLib/HFB.c	60;"	d	file:
T_OCC	HTKLib/HUtil.c	54;"	d	file:
T_OCC	HTKTools/HRest.c	53;"	d	file:
T_OOV	HLMTools/LPlex.c	59;"	d	file:
T_OPEN	HTKLib/HWave.c	103;"	d	file:
T_OPT	HTKLib/HFB.c	57;"	d	file:
T_OPT	HTKTools/HSmooth.c	44;"	d	file:
T_ORP	HTKLib/HModel.c	60;"	d	file:
T_OTP	HTKTools/HRest.c	50;"	d	file:
T_OUT	HTKLib/HFB.c	63;"	d	file:
T_PAR	HTKLib/HModel.c	57;"	d	file:
T_PBS	HTKLib/HParm.c	59;"	d	file:
T_PMP	HTKLib/HModel.c	58;"	d	file:
T_PRO	HTKLib/HRNLM.c	49;"	d	file:
T_PROB	HLMLib/LModel.c	54;"	d	file:
T_PROB	HLMLib/LPMerge.c	48;"	d	file:
T_PROB	HLMTools/LPlex.c	60;"	d	file:
T_PRU	HTKLib/HFB.c	58;"	d	file:
T_PRUN	HTKLib/HLat.c	58;"	d	file:
T_QST	HTKTools/HHEd.c	76;"	d	file:
T_QUA	HTKLib/HParm.c	60;"	d	file:
T_RDSC	HTKTools/HLEd.c	45;"	d	file:
T_RIN	HLMTools/LGPrep.c	61;"	d	file:
T_RUL	HLMTools/LGPrep.c	62;"	d	file:
T_RUN	HTKLib/HAudio.c	38;"	d	file:
T_SAV	HLMTools/LAdapt.c	61;"	d	file:
T_SAV	HLMTools/LGCopy.c	58;"	d	file:
T_SAV	HLMTools/LGPrep.c	58;"	d	file:
T_SAV	HTKLib/HLabel.c	40;"	d	file:
T_SAVE	HLMLib/LModel.c	52;"	d	file:
T_SCPT	HTKTools/HDMan.c	52;"	d	file:
T_SEGMENT	HTKTools/HCopy.c	40;"	d	file:
T_SEGS	HTKTools/HCompV.c	70;"	d	file:
T_SEGS	HTKTools/HQuant.c	47;"	d	file:
T_SEL	HLMTools/LPlex.c	61;"	d	file:
T_SENT	HLMTools/LPlex.c	58;"	d	file:
T_SEQ	HTKLib/HTrain.c	54;"	d	file:
T_SHR	HLMTools/LAdapt.c	63;"	d	file:
T_SHR	HLMTools/LGPrep.c	60;"	d	file:
T_SIZ	HTKTools/HHEd.c	72;"	d	file:
T_SLEV	HTKTools/HLEd.c	48;"	d	file:
T_SPK	HTKTools/HResults.c	44;"	d	file:
T_SPT	HTKTools/HResults.c	46;"	d	file:
T_SQU	HLMLib/LGBase.c	48;"	d	file:
T_SRT	HLMLib/LGBase.c	49;"	d	file:
T_SRT	HLMLib/LWMap.c	48;"	d	file:
T_STC	HTKLib/HAudio.c	35;"	d	file:
T_STK	HTKLib/HMem.c	37;"	d	file:
T_SUBD	HTKLib/HLabel.c	37;"	d	file:
T_SWP	HTKLib/HAdapt.c	63;"	d	file:
T_SXF	HTKLib/HAdapt.c	61;"	d	file:
T_TAB	HTKTools/HQuant.c	49;"	d	file:
T_TAC	HTKTools/HRest.c	54;"	d	file:
T_TIM	HTKLib/HFB.c	66;"	d	file:
T_TIM	HTKLib/HFBLat.c	77;"	d	file:
T_TIM	HTKTools/HMMIRest.c	69;"	d	file:
T_TIO	HTKLib/HLM.c	49;"	d	file:
T_TIO	HTKLib/HNLM.c	46;"	d	file:
T_TIO	HTKLib/HRNLM.c	47;"	d	file:
T_TMX	HTKLib/HFB.c	65;"	d	file:
T_TOK	HTKLib/HModel.c	56;"	d	file:
T_TOP	HLMLib/LCMap.c	47;"	d	file:
T_TOP	HLMLib/LGBase.c	47;"	d	file:
T_TOP	HLMLib/LModel.c	50;"	d	file:
T_TOP	HLMLib/LPCalc.c	46;"	d	file:
T_TOP	HLMLib/LPMerge.c	47;"	d	file:
T_TOP	HLMLib/LPMerge.c	53;"	d	file:
T_TOP	HLMLib/LUtil.c	45;"	d	file:
T_TOP	HLMLib/LWMap.c	46;"	d	file:
T_TOP	HLMTools/Cluster.c	56;"	d	file:
T_TOP	HLMTools/HLMCopy.c	55;"	d	file:
T_TOP	HLMTools/LAdapt.c	60;"	d	file:
T_TOP	HLMTools/LBuild.c	49;"	d	file:
T_TOP	HLMTools/LFoF.c	57;"	d	file:
T_TOP	HLMTools/LGCopy.c	57;"	d	file:
T_TOP	HLMTools/LGList.c	47;"	d	file:
T_TOP	HLMTools/LGPrep.c	57;"	d	file:
T_TOP	HLMTools/LLink.c	42;"	d	file:
T_TOP	HLMTools/LMerge.c	56;"	d	file:
T_TOP	HLMTools/LNewMap.c	42;"	d	file:
T_TOP	HLMTools/LNorm.c	54;"	d	file:
T_TOP	HLMTools/LPlex.c	57;"	d	file:
T_TOP	HLMTools/LSubset.c	47;"	d	file:
T_TOP	HTKLib/HAdapt.c	56;"	d	file:
T_TOP	HTKLib/HAudio.c	34;"	d	file:
T_TOP	HTKLib/HDict.c	36;"	d	file:
T_TOP	HTKLib/HFB.c	56;"	d	file:
T_TOP	HTKLib/HFBLat.c	76;"	d	file:
T_TOP	HTKLib/HLat.c	57;"	d	file:
T_TOP	HTKLib/HMap.c	66;"	d	file:
T_TOP	HTKLib/HMem.c	34;"	d	file:
T_TOP	HTKLib/HModel.c	54;"	d	file:
T_TOP	HTKLib/HParm.c	56;"	d	file:
T_TOP	HTKLib/HRNLM.c	48;"	d	file:
T_TOP	HTKLib/HTrain.c	53;"	d	file:
T_TOP	HTKLib/HUtil.c	52;"	d	file:
T_TOP	HTKTools/HBuild.c	37;"	d	file:
T_TOP	HTKTools/HCompV.c	67;"	d	file:
T_TOP	HTKTools/HCopy.c	38;"	d	file:
T_TOP	HTKTools/HDMan.c	47;"	d	file:
T_TOP	HTKTools/HERest.c	75;"	d	file:
T_TOP	HTKTools/HInit.c	47;"	d	file:
T_TOP	HTKTools/HLEd.c	44;"	d	file:
T_TOP	HTKTools/HLRescore.c	59;"	d	file:
T_TOP	HTKTools/HList.c	53;"	d	file:
T_TOP	HTKTools/HMMIRest.c	68;"	d	file:
T_TOP	HTKTools/HParse.c	91;"	d	file:
T_TOP	HTKTools/HQuant.c	44;"	d	file:
T_TOP	HTKTools/HRest.c	47;"	d	file:
T_TOP	HTKTools/HSGen.c	42;"	d	file:
T_TOP	HTKTools/HSmooth.c	42;"	d	file:
T_TOP	HTKTools/HVite.c	59;"	d	file:
T_TRA	HTKLib/HFB.c	61;"	d	file:
T_TRAN	HTKLib/HLat.c	62;"	d	file:
T_TRAN	HTKTools/HLRescore.c	60;"	d	file:
T_TRE	HTKLib/HAdapt.c	59;"	d	file:
T_TRE	HTKTools/HRest.c	58;"	d	file:
T_TREE	HTKTools/HHEd.c	85;"	d	file:
T_TREE_ALLM	HTKTools/HHEd.c	82;"	d	file:
T_TREE_ALLQ	HTKTools/HHEd.c	81;"	d	file:
T_TREE_ANS	HTKTools/HHEd.c	77;"	d	file:
T_TREE_BESTM	HTKTools/HHEd.c	79;"	d	file:
T_TREE_BESTQ	HTKTools/HHEd.c	78;"	d	file:
T_TREE_OKQ	HTKTools/HHEd.c	80;"	d	file:
T_UNI	HTKTools/HInit.c	50;"	d	file:
T_UPD	HTKLib/HFB.c	64;"	d	file:
T_UPD	HTKLib/HMap.c	67;"	d	file:
T_UPD	HTKTools/HERest.c	77;"	d	file:
T_VAC	HTKTools/HRest.c	56;"	d	file:
T_VALI	HTKTools/HDMan.c	49;"	d	file:
T_VIT	HTKTools/HInit.c	51;"	d	file:
T_VRE	HTKTools/HRest.c	61;"	d	file:
T_WAC	HTKTools/HRest.c	57;"	d	file:
T_WBUF	HTKTools/HDMan.c	48;"	d	file:
T_WMP	HLMLib/LWMap.c	47;"	d	file:
T_WRE	HTKTools/HRest.c	59;"	d	file:
T_XFD	HTKLib/HModel.c	64;"	d	file:
T_XFM	HTKLib/HAdapt.c	60;"	d	file:
T_XFM	HTKLib/HModel.c	63;"	d	file:
TailMerge	HTKTools/HParse.c	/^void TailMerge(Link a, Link b)$/;"	f
TargetPKStr	HTKTools/HCompV.c	/^static char TargetPKStr[MAXSTRLEN];      \/* target parm kind string *\/$/;"	v	file:
TermHGraf	HTKLib/HGraf.c	/^void TermHGraf()$/;"	f
TermHGraf	HTKLib/HGraf.null.c	/^void TermHGraf()$/;"	f
TermHGraf	HTKLib/HGraf_WIN32.c	/^void TermHGraf()$/;"	f
TermScanner	HTKLib/HModel.c	/^static void TermScanner(Source *src)$/;"	f	file:
TidyBaseAccs	HTKLib/HAdapt.c	/^void TidyBaseAccs()$/;"	f
TieCommand	HTKTools/HHEd.c	/^void TieCommand(void)$/;"	f
TieDur	HTKTools/HHEd.c	/^void TieDur(ILink ilist, LabId macId)$/;"	f
TieHMMs	HTKTools/HHEd.c	/^void TieHMMs(ILink ilist,LabId macId)$/;"	f
TieInv	HTKTools/HHEd.c	/^void TieInv(ILink ilist, LabId macId)$/;"	f
TieLeafNodes	HTKTools/HHEd.c	/^void TieLeafNodes(Tree *tree, char *macRoot)$/;"	f
TieMean	HTKTools/HHEd.c	/^void TieMean(ILink ilist, LabId macId)$/;"	f
TieMix	HTKTools/HHEd.c	/^void TieMix(ILink ilist, LabId macId)$/;"	f
TiePDF	HTKTools/HHEd.c	/^void TiePDF(ILink ilist, LabId macId)$/;"	f
TieState	HTKTools/HHEd.c	/^void TieState(ILink ilist, LabId macId)$/;"	f
TieTrans	HTKTools/HHEd.c	/^void TieTrans(ILink ilist, LabId macId)$/;"	f
TieVar	HTKTools/HHEd.c	/^void TieVar(ILink ilist, LabId macId)$/;"	f
TieWeights	HTKTools/HHEd.c	/^void TieWeights(ILink ilist, LabId macId)$/;"	f
TieXform	HTKTools/HHEd.c	/^void TieXform(ILink ilist, LabId macId)$/;"	f
TimeToNFrames	HTKLib/HArc.c	/^int TimeToNFrames(float time, ArcInfo *aInfo){$/;"	f
Timer	HTKLib/HGraf.c	/^static void Timer(int n)$/;"	f	file:
TimesLabelled	HTKTools/HSLab.c	/^int TimesLabelled(LabList *ll, long pos)$/;"	f
ToMergeLatNodesBackw	HTKLib/HLat.c	/^Boolean ToMergeLatNodesBackw(Lattice *lat, LNode *ln)$/;"	f
ToMergeLatNodesForw	HTKLib/HLat.c	/^Boolean ToMergeLatNodesForw(Lattice *lat, LNode *ln)$/;"	f
TokSetMerge	HTKLib/HRec.c	/^static void TokSetMerge(TokenSet *res,Token *cmp,TokenSet *src)$/;"	f	file:
Token	HTKLib/HModel.c	/^} Token;$/;"	t	typeref:struct:__anon42	file:
Token	HTKLib/HRec.h	/^Token;$/;"	t	typeref:struct:token
TokenSet	HTKLib/HRec.c	/^TokenSet;$/;"	t	typeref:struct:tokenset	file:
TotMixInSet	HTKLib/HMap.c	/^static int TotMixInSet(HMMSet *hset)$/;"	f	file:
TotalComps	HTKLib/HParm.c	/^static int TotalComps(int nStatic, ParmKind pk)$/;"	f	file:
TotalCorr	HTKTools/HMMIRest.c	/^static double TotalCorr=0;$/;"	v	file:
TotalNWords	HTKTools/HMMIRest.c	/^static int TotalNWords=0;$/;"	v	file:
Touch	HTKLib/HModel.c	/^void Touch(int *flag)$/;"	f
TouchV	HTKLib/HMem.c	/^void TouchV(Ptr m)$/;"	f
TrAcc	HTKLib/HTrain.h	/^} TrAcc;$/;"	t	typeref:struct:__anon111
TrL	HTKTools/HCopy.c	/^} TrL;$/;"	t	typeref:struct:_TrList	file:
TrOpEntry	HTKTools/HLEd.c	/^void TrOpEntry(char *name)$/;"	f
TrOpExit	HTKTools/HLEd.c	/^void TrOpExit(int count)$/;"	f
TrPtr	HTKTools/HCopy.c	/^typedef struct _TrList *TrPtr;  \/* simple linked list for trace info *\/$/;"	t	typeref:struct:_TrList	file:
TrSymbol	HTKLib/HLabel.c	/^typedef enum _TrSymbol TrSymbol;$/;"	t	typeref:enum:_TrSymbol	file:
Trace Output	HTKBook/HTKRef/HCopy.tex	/^invocation of \\htool{HCopy}.$/;"	u
TraceAlphaBeta	HTKLib/HFB.c	/^static void TraceAlphaBeta(AlphaBeta *ab, int t, int startq, int endq, LogDouble pr)$/;"	f	file:
TraceOcc	HTKLib/HFB.c	/^static void TraceOcc(AlphaBeta *ab, UttInfo *utt, int t)$/;"	f	file:
TracePath	HTKLib/HRec.c	/^void TracePath(FILE *file,Path *path)$/;"	f
TraceQuestion	HTKTools/HHEd.c	/^void TraceQuestion(char *cmd, QLink q)$/;"	f
Tracing	HTKBook/HTKRef/HHEd.tex	/^\\stdopts{HHEd}$/;"	u
TrackButtons	HTKLib/HGraf.c	/^ButtonId TrackButtons(HButton *btnlist, HEventRec hev)$/;"	f
TrackButtons	HTKLib/HGraf.null.c	/^ButtonId TrackButtons(HButton *btnlist, HEventRec hev)$/;"	f
TrackButtons	HTKLib/HGraf_WIN32.c	/^ButtonId TrackButtons(HButton *btnlist, HEventRec hev)$/;"	f
TrackWPtr	HTKTools/HSLab.c	/^void TrackWPtr(void)$/;"	f
Training Tools	HTKBook/htkoview.tex	/^VQ codebook in preparation for building  discrete probability HMM system.$/;"	u
Transcription	HTKLib/HLabel.h	/^}Transcription;$/;"	t	typeref:struct:__anon116
TranscriptionFromLattice	HTKLib/HRec.c	/^Transcription *TranscriptionFromLattice(MemHeap *heap,Lattice *lat,int N)$/;"	f
Tree	HTKTools/HHEd.c	/^}Tree;$/;"	t	typeref:struct:_Tree	file:
TreeBuildCommand	HTKTools/HHEd.c	/^void TreeBuildCommand(void)$/;"	f
TreeCluster	HTKLib/HTrain.c	/^ClusterSet *TreeCluster(MemHeap *x, Sequence vpool, int nc, $/;"	f
TreeFilter	HTKTools/HHEd.c	/^void TreeFilter(HMMSet *newSet)$/;"	f
TreeType	HTKLib/HVQ.h	/^} TreeType;$/;"	t	typeref:enum:__anon35
Tri2DMat	HTKLib/HAdapt.c	/^static void Tri2DMat (DMatrix m1, DMatrix m2)$/;"	f	file:
Tri2Mat	HTKLib/HMath.c	/^void Tri2Mat (TriMat m1, Matrix m2)$/;"	f
TriDiag2Vector	HTKTools/HCompV.c	/^void TriDiag2Vector(TriMat m, Vector v)$/;"	f
TriMat	HTKLib/HMem.h	/^typedef Matrix TriMat;     \/* matrix[1..nrows][1..i] (lower triangular) *\/$/;"	t
TriMatElemSize	HTKLib/HMem.c	/^size_t TriMatElemSize(int size)$/;"	f
TriMatSize	HTKLib/HMem.c	/^int TriMatSize(TriMat m)$/;"	f
TriPhon	HTKTools/HDMan.c	/^void TriPhon(Pronunciation *p, Boolean left, Boolean right, $/;"	f
TriPhonise	HTKTools/HLEd.c	/^int TriPhonise(LabList *ll,Boolean left, Boolean right, LabId stId, $/;"	f
TriRec	HTKTools/HHEd.c	/^}TriRec;$/;"	t	typeref:struct:__anon166	file:
TriState	HTKLib/HParm.h	/^TriState;$/;"	t	typeref:enum:__anon119
TriStrip	HTKLib/HLabel.c	/^void TriStrip(char *s)$/;"	f
TrimSampFreq	HTKLib/HAudio.c	/^static int TrimSampFreq(int f)$/;"	f	file:
Triphonise	HTKTools/HDMan.c	/^void Triphonise(WordBuf *wb,  Boolean left, Boolean right, $/;"	f
TuringGoodInfo	HLMLib/LModel.h	/^} TuringGoodInfo;$/;"	t	typeref:struct:__anon11
Tutorial Overview	HTKBook/htkbook-pdf.tex	/^\\pagenumbering{arabic}$/;"	p
Tutorial Overview	HTKBook/htkbook.tex	/^\\pagenumbering{arabic}$/;"	p
TypeCode	HTKLib/esignal.c	/^TypeCode(char *name)$/;"	f
TypeName	HTKLib/esignal.c	/^TypeName(int type    \/* numeric data-type code *\/ )$/;"	f
TypeOrder	HTKLib/esignal.c	/^TypeOrder(FieldList list)$/;"	f
Types	HTKLib/esignal.c	/^static short    Types[] =$/;"	v	file:
TypicalState	HTKTools/HHEd.c	/^ILink TypicalState(ILink ilist, LabId macId)$/;"	f
U	HTKLib/HRNLM.h	/^    float *U, *W;$/;"	m	struct:_Layer
UCHAR	HTKLib/esignal.h	73;"	d
UCH_FMT	HTKLib/esig_asc.c	71;"	d	file:
UCH_W	HTKLib/esig_asc.c	70;"	d	file:
UCH_WFMT	HTKLib/esig_asc.c	72;"	d	file:
UCPHONE	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon158	file:
UCPhoneOp	HTKTools/HDMan.c	/^void UCPhoneOp(WordBuf *wb)$/;"	f
UCWORD	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon158	file:
UCase	HTKTools/HDMan.c	/^LabId UCase(LabId id)$/;"	f
UCollectData	HTKTools/HInit.c	/^void UCollectData(Sequence **seqMat)$/;"	f
UF	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon168	file:
UInt	HLMLib/LGBase.h	/^typedef unsigned int   UInt;$/;"	t
UInt	HLMLib/LModel.h	/^typedef unsigned int   UInt;$/;"	t
ULN_FMT	HTKLib/esig_asc.c	55;"	d	file:
ULN_W	HTKLib/esig_asc.c	54;"	d	file:
ULN_WFMT	HTKLib/esig_asc.c	56;"	d	file:
ULONG	HTKLib/esignal.h	69;"	d
UNDEFF	HTKLib/HWave.h	/^        UNDEFF$/;"	e	enum:__anon36
UNIX	HTKLib/HShell.h	66;"	d
UNKNOWN	HTKLib/esignal.h	102;"	d
UNKNOWNSO	HTKLib/HWave.c	/^   UNKNOWNSO   \/* unknown source byte order *\/$/;"	e	enum:_SrcOrder	file:
UNK_FIELD	HTKLib/HNet.c	/^typedef enum {UNK_FIELD, STR_FIELD, INT_FIELD, FLT_FIELD} LatFieldType;$/;"	e	enum:__anon55	file:
UNLOG_NATURAL	HLMLib/LModel.h	64;"	d
UNLOG_NATURAL	HTKLib/HLM.h	50;"	d
UNUSED	HTKLib/HWave.h	/^        UNUSED,$/;"	e	enum:__anon36
UPDSet	HTKLib/HTrain.h	/^typedef enum _UPDSet UPDSet;$/;"	t	typeref:enum:_UPDSet
UPMAP	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	e	enum:_UPDSet
UPMEANS	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	e	enum:_UPDSet
UPMIXES	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	e	enum:_UPDSet
UPMODE_BOTH	HTKTools/HERest.c	83;"	d	file:
UPMODE_BOTH	HTKTools/HMMIRest.c	74;"	d	file:
UPMODE_DUMP	HTKTools/HERest.c	81;"	d	file:
UPMODE_DUMP	HTKTools/HMMIRest.c	72;"	d	file:
UPMODE_UPDATE	HTKTools/HERest.c	82;"	d	file:
UPMODE_UPDATE	HTKTools/HMMIRest.c	73;"	d	file:
UPSEMIT	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	e	enum:_UPDSet
UPTRANS	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	e	enum:_UPDSet
UPVARS	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	e	enum:_UPDSet
UPXFORM	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	e	enum:_UPDSet
USEHAMMING	HTKLib/HParm.c	/^   USEHAMMING,    \/* Apply Hamming Window *\/$/;"	e	enum:__anon77	file:
USEMAC	HTKLib/HModel.c	/^   BEGINHMM, USEMAC, ENDHMM, NUMMIXES, $/;"	e	enum:__anon40	file:
USEPOWER	HTKLib/HParm.c	/^   USEPOWER,      \/* Use power instead of magnitude *\/$/;"	e	enum:__anon77	file:
USER	HTKLib/HParm.h	/^      USER,                            \/* Arbitrary user specified data *\/$/;"	e	enum:_BaseParmKind
USESILDET	HTKLib/HParm.c	/^   USESILDET,     \/* Enable speech\/silence detection *\/$/;"	e	enum:__anon77	file:
USE_STAT	HTKTools/HSLab.c	59;"	d	file:
USHORT	HTKLib/esignal.h	71;"	d
USH_FMT	HTKLib/esig_asc.c	63;"	d	file:
USH_W	HTKLib/esig_asc.c	62;"	d	file:
USH_WFMT	HTKLib/esig_asc.c	64;"	d	file:
UShort	HLMLib/LGBase.h	/^typedef unsigned short UShort;$/;"	t
UShort	HLMLib/LModel.h	/^typedef unsigned short UShort;$/;"	t
UT	HTKTools/HHEd.c	/^                         TC , UT , MT , SH , SU , SW , SK ,$/;"	e	enum:__anon168	file:
Uchar	HTKLib/esignal.h	/^typedef unsigned char			Uchar;$/;"	t
Uf	HTKLib/HRNLM.h	/^    float *Ui, *Uf, *Uo, *Wi, *Wf, *Wo;$/;"	m	struct:_Layer
Uh	HTKLib/HRNLM.h	/^    float *Wr, *Wz, *Wh, *Ur, *Uz, *Uh;$/;"	m	struct:_Layer
Uhw	HTKLib/HRNLM.h	/^    float *Uhw, *Whw;$/;"	m	struct:_Layer
Ui	HTKLib/HRNLM.h	/^    float *Ui, *Uf, *Uo, *Wi, *Wf, *Wo;$/;"	m	struct:_Layer
Ulong	HTKLib/esignal.h	/^typedef unsigned long			Ulong;$/;"	t
UnGetCh	HTKLib/HShell.c	/^void UnGetCh(int c, Source *src)$/;"	f
UnRecordHeap	HTKLib/HMem.c	/^static void UnRecordHeap(MemHeap *x)$/;"	f	file:
UnWeightCepstrum	HTKLib/HSigP.c	/^void UnWeightCepstrum(Vector c, int start, int count, int cepLiftering)$/;"	f
UndoOp	HTKTools/HSLab.c	/^void UndoOp(void)$/;"	f
UndoRecord	HTKTools/HSLab.c	/^} UndoRecord; $/;"	t	typeref:struct:__anon147	file:
UniformSegment	HTKTools/HInit.c	/^void UniformSegment(void)$/;"	f
UnlinkAlign	HTKLib/HRec.c	/^static void UnlinkAlign(Align *align)$/;"	f	file:
UnlinkPath	HTKLib/HRec.c	/^static void UnlinkPath(Path *path)$/;"	f	file:
UntieCommand	HTKTools/HHEd.c	/^void UntieCommand(void)$/;"	f
UntieInv	HTKTools/HHEd.c	/^void UntieInv(ILink ilist)$/;"	f
UntieMean	HTKTools/HHEd.c	/^void UntieMean(ILink ilist)$/;"	f
UntieMix	HTKTools/HHEd.c	/^void UntieMix(ILink ilist)$/;"	f
UntieState	HTKTools/HHEd.c	/^void UntieState(ILink ilist)$/;"	f
UntieTrans	HTKTools/HHEd.c	/^void UntieTrans(ILink ilist)$/;"	f
UntieVar	HTKTools/HHEd.c	/^void UntieVar(ILink ilist)$/;"	f
UntieXform	HTKTools/HHEd.c	/^void UntieXform(ILink ilist)$/;"	f
Untouch	HTKLib/HModel.c	/^void Untouch(int *flag)$/;"	f
UntouchV	HTKLib/HMem.c	/^void UntouchV(Ptr m)$/;"	f
Uo	HTKLib/HRNLM.h	/^    float *Ui, *Uf, *Uo, *Wi, *Wf, *Wo;$/;"	m	struct:_Layer
UpDProbs	HTKTools/HInit.c	/^void UpDProbs(int i, int s, int M, WtAcc *wa, ShortVec dw)$/;"	f
UpMeans	HTKTools/HInit.c	/^void UpMeans(int i, int s, int m, int size, MuAcc *ma, Vector mean)$/;"	f
UpMix	HTKTools/HHEd.c	/^void UpMix(char *hname, StreamElem *ste, int oldM, int newM)$/;"	f
UpMixParms	HTKLib/HFB.c	/^static void UpMixParms(FBInfo *fbInfo, int q, HLink hmm, HLink al_hmm,$/;"	f	file:
UpMixParms	HTKLib/HFBLat.c	/^static double UpMixParms(int q, HLink hmm, int t, DVector aqt, $/;"	f	file:
UpPDFCounts	HTKTools/HRest.c	/^void UpPDFCounts(LogDouble pr, int seg)$/;"	f
UpSkipTranParms	HTKLib/HFBLat.c	/^void UpSkipTranParms(int q, int t){$/;"	f
UpStreamCounts	HTKTools/HRest.c	/^void UpStreamCounts(int j, int s, StreamElem *se, int vSize, LogDouble pr, int seg,$/;"	f
UpTranCounts	HTKTools/HRest.c	/^void UpTranCounts(LogDouble pr,int seg)$/;"	f
UpTranParms	HTKLib/HFB.c	/^static void UpTranParms(FBInfo *fbInfo, HLink hmm, int t, int q,$/;"	f	file:
UpTranParms	HTKLib/HFBLat.c	/^static void UpTranParms(int t, int q){ $/;"	f	file:
UpTrans	HTKTools/HInit.c	/^void UpTrans(TrAcc *ta, Matrix tr)$/;"	f
UpVars	HTKTools/HInit.c	/^void UpVars(int i, int s, int m, int size, VaAcc *va, Vector oldMean,$/;"	f
UpWeights	HTKTools/HInit.c	/^void UpWeights(int i, int s, int M, WtAcc *wa, StreamElem *ste)$/;"	f
UpdateAccCache	HTKLib/HAdapt.c	/^void UpdateAccCache(double Lr, Vector svec, MixPDF *mp)$/;"	f
UpdateBaseAccs	HTKLib/HAdapt.c	/^void UpdateBaseAccs(Vector svec)$/;"	f
UpdateBaseAccsWithPaac	HTKLib/HAdapt.c	/^void UpdateBaseAccsWithPaac(void)$/;"	f
UpdateCRCC	HTKLib/HParm.c	/^unsigned int UpdateCRCC(void *data,int n,int s,Boolean bSwap,unsigned int crcc)$/;"	f
UpdateCounters	HTKTools/HRest.c	/^void UpdateCounters(LogDouble pr, int seg)$/;"	f
UpdateCounts	HTKTools/HInit.c	/^void UpdateCounts(int segNum, int segLen, IntVec states,IntVec *mixes)$/;"	f
UpdateGauss	HTKTools/HMMIRest.c	/^Boolean UpdateGauss(int stream, MixPDF *mp){$/;"	f
UpdateHLDAModel	HTKLib/HAdapt.c	/^void UpdateHLDAModel(HMMSet *hset)$/;"	f
UpdateMInfo	HTKLib/HAdapt.c	/^static void UpdateMInfo(HMMSet *hset, AdaptXForm *xform)$/;"	f	file:
UpdateMLPLMCache	HTKLib/HLM.c	/^float UpdateMLPLMCache(LModel *lm, char **hist, NNLM *mlp, char *word, int N, Boolean useCache)$/;"	f
UpdateMeanVar	HTKTools/HCompV.c	/^void UpdateMeanVar(SpkrAccListItem *sal)$/;"	f
UpdateMeanVariance	HTKLib/HRNLM.c	/^void UpdateMeanVariance (RNNLM* lm)$/;"	f
UpdateMeans	HTKLib/HMap.c	/^static int UpdateMeans(HMMSet *hset, int px, HLink hmm)$/;"	f	file:
UpdateMeans	HTKTools/HERest.c	/^void UpdateMeans(HMMSet *hset, int px, HLink hmm)$/;"	f
UpdateModel	HLMLib/LPCalc.c	/^BackOffLM *UpdateModel(BackOffLM *lm, BuildInfo *bi)$/;"	f
UpdateModels	HTKTools/HERest.c	/^void UpdateModels(HMMSet *hset, ParmBuf pbuf2)$/;"	f
UpdateModels	HTKTools/HMMIRest.c	/^void UpdateModels(void)$/;"	f
UpdateModels	HTKTools/HSmooth.c	/^void UpdateModels(void)$/;"	f
UpdateObsCache	HTKLib/HAdapt.c	/^static void UpdateObsCache( ObsCache *oc, Vector svec, LogFloat det, int t)  $/;"	f	file:
UpdateOccSums	HTKTools/HHEd.c	/^void UpdateOccSums(int i, int j, Vector occSum, int N)$/;"	f
UpdateParameters	HTKTools/HInit.c	/^void UpdateParameters(void)$/;"	f
UpdateProjectModels	HTKLib/HAdapt.c	/^void UpdateProjectModels(HMMSet *hset, char *dir)$/;"	f
UpdateRNNLMCache	HTKLib/HLM-RNNLM.c	/^float UpdateRNNLMCache(LModel *lm, char **hist, RNNLM *rnnlm, int wdID, char *word, int N, int shift, Boolean useCache, char succword[NSIZE][100], int succwdID[NSIZE])$/;"	f
UpdateSemiTiedAccs	HTKLib/HAdapt.c	/^static void UpdateSemiTiedAccs(AdaptXForm *xform, AccStruct *accs, IntVec classes, TriMat totCov)$/;"	f	file:
UpdateSemiTiedMeans	HTKLib/HAdapt.c	/^static void UpdateSemiTiedMeans(HMMSet *hset, LinXForm *xf, BaseClass *bclass, IntVec classes, Vector totMean)$/;"	f	file:
UpdateSemiTiedModels	HTKLib/HAdapt.c	/^void UpdateSemiTiedModels(HMMSet *hset, XFInfo *xfinfo)$/;"	f
UpdateSemiTiedVFloor	HTKLib/HAdapt.c	/^static void UpdateSemiTiedVFloor(HMMSet *hset, LinXForm *xf, TriMat avCov, SVector vFloor)$/;"	f	file:
UpdateSemiTiedVars	HTKLib/HAdapt.c	/^static double UpdateSemiTiedVars(HMMSet *hset, LinXForm *xf, BaseClass *bclass, IntVec classes, Vector vFloor, TriMat totCov)$/;"	f	file:
UpdateSemiTiedXForm	HTKLib/HAdapt.c	/^static void UpdateSemiTiedXForm(AccStruct *accs, LinXForm *xf, LinXForm *ixf)$/;"	f	file:
UpdateSpkrAccList	HTKTools/HCompV.c	/^SpkrAccListItem *UpdateSpkrAccList(SpkrAccListItem *sal, SpkrAcc *sa)$/;"	f
UpdateSpkrStats	HTKLib/HAdapt.c	/^Boolean UpdateSpkrStats(HMMSet *hset, XFInfo *xfinfo, char *datafn)$/;"	f
UpdateTMMeans	HTKTools/HERest.c	/^void UpdateTMMeans(HMMSet *hset)$/;"	f
UpdateTMMeans	HTKTools/HSmooth.c	/^void UpdateTMMeans(void)$/;"	f
UpdateTMVars	HTKTools/HERest.c	/^void UpdateTMVars(HMMSet *hset)$/;"	f
UpdateTMVars	HTKTools/HSmooth.c	/^void UpdateTMVars(void)$/;"	f
UpdateTheModel	HTKTools/HRest.c	/^void UpdateTheModel(void)$/;"	f
UpdateTrans	HTKTools/HERest.c	/^void UpdateTrans(HMMSet *hset, int px, HLink hmm)$/;"	f
UpdateTrans	HTKTools/HMMIRest.c	/^void UpdateTrans(int px, HLink hmm)$/;"	f
UpdateTrans	HTKTools/HSmooth.c	/^void UpdateTrans(HLink hmm)$/;"	f
UpdateVars	HTKLib/HMap.c	/^static void UpdateVars(HMMSet *hset, int px, HLink hmm)$/;"	f	file:
UpdateVars	HTKTools/HERest.c	/^void UpdateVars(HMMSet *hset, int px, HLink hmm)$/;"	f
UpdateWeight	HTKTools/HMMIRest.c	/^void UpdateWeight(int s, StreamElem *ste){$/;"	f
UpdateWeights	HTKLib/HMap.c	/^static void UpdateWeights(HMMSet *hset, int px, HLink hmm)$/;"	f	file:
UpdateWeights	HTKTools/HERest.c	/^void UpdateWeights(HMMSet *hset, int px, HLink hmm)$/;"	f
UpdateWeights	HTKTools/HSmooth.c	/^void UpdateWeights(HLink hmm)$/;"	f
UpdateWeightsAndTrans	HTKTools/HMMIRest.c	/^void UpdateWeightsAndTrans(void){$/;"	f
UpdateWeightsOrTrans	HTKTools/HMMIRest.c	/^void UpdateWeightsOrTrans(int M, float *acc1, float *acc2, float *mixes, float *oldMixes, float C){ $/;"	f
UpperCase	HLMLib/LUtil.c	/^void UpperCase(char *s)$/;"	f
Ur	HTKLib/HRNLM.h	/^    float *Wr, *Wz, *Wh, *Ur, *Uz, *Uh;$/;"	m	struct:_Layer
Use	HTKBook/HTKRef/HCopy.tex	/^Not all possible conversions can actually be performed; see Table~\\href{t:validcons} for a list of valid conversions. Conversions must be specified via a configuration file as described in chapter~\\ref{c:speechio}. Note also that the parameterisation qualifier \\texttt{\\_N} cannot be used when saving files to disk, and is meant only for on-the-fly parameterisation. $/;"	u
Use	HTKBook/HTKRef/HHEd.tex	/^Sets the input transform of the model-set to be filename.$/;"	u
UseAlignHMMSet	HTKLib/HFB.c	/^void UseAlignHMMSet(FBInfo* fbInfo, MemHeap* x, HMMSet *al_hset)$/;"	f
UseCommand	HTKTools/HHEd.c	/^void UseCommand(void)$/;"	f
UseOldXFormCVN	HTKLib/HParm.c	/^static Boolean UseOldXFormCVN = FALSE;  \/* this allows us to go back to the old version with broken CVN *\/$/;"	v	file:
Ushort	HTKLib/esignal.h	/^typedef unsigned short			Ushort;$/;"	t
UttInfo	HTKLib/HFB.h	/^} UttInfo;$/;"	t	typeref:struct:__anon136
Uz	HTKLib/HRNLM.h	/^    float *Wr, *Wz, *Wh, *Ur, *Uz, *Uh;$/;"	m	struct:_Layer
V1COMPAT	HTKLib/HParm.c	/^   V1COMPAT,      \/* Set Version 1 compatibility mode *\/$/;"	e	enum:__anon77	file:
VARATSYM	HTKTools/HParse.c	/^enum _Symbol{NAMESYM, VARSYM, VARATSYM, LPARSYM, RPARSYM, LBRACESYM, $/;"	e	enum:_Symbol	file:
VARIANCE	HTKLib/HModel.c	/^   MEAN, VARIANCE, INVCOVAR, XFORM, GCONST,$/;"	e	enum:__anon40	file:
VARSCALEDIR	HTKLib/HParm.c	/^   VARSCALEDIR,  \/* dir to find the variance estimate files *\/$/;"	e	enum:__anon77	file:
VARSCALEFN	HTKLib/HParm.c	/^   VARSCALEFN,$/;"	e	enum:__anon77	file:
VARSCALEMASK	HTKLib/HParm.c	/^   VARSCALEMASK, \/* label mask to idenitfy the variance estimate files *\/$/;"	e	enum:__anon77	file:
VARSCALEPATHMASK	HTKLib/HParm.c	/^   VARSCALEPATHMASK, \/* label mask to idenitfy the path of the variance estimate files *\/$/;"	e	enum:__anon77	file:
VARSYM	HTKTools/HParse.c	/^enum _Symbol{NAMESYM, VARSYM, VARATSYM, LPARSYM, RPARSYM, LBRACESYM, $/;"	e	enum:_Symbol	file:
VAXSO	HTKLib/HWave.c	/^   VAXSO,      \/* little-endian ie low byte first *\/$/;"	e	enum:_SrcOrder	file:
VAdd	HTKTools/HHEd.c	/^void VAdd(Vector a, Vector b)$/;"	f
VBDEF	HTKTools/HLEd.c	/^   SBDEF,   EXPAND, IFILL,  SORT,   WBDEF,  VBDEF,  LCTXT,  $/;"	e	enum:__anon141	file:
VECSIZE	HTKLib/HModel.c	/^   NUMSTATES, STREAMINFO, VECSIZE, $/;"	e	enum:__anon40	file:
VERSION	HLMTools/LPlex.c	55;"	d	file:
VERSION	HTKLib/esignal.h	55;"	d
VERT	HTKTools/HResults.c	/^enum _Direction{DIAG,VERT,HOR,NIL};$/;"	e	enum:_Direction	file:
VGetLabelList	HTKTools/HLEd.c	/^LabList* VGetLabelList(Transcription *t, int n)$/;"	f
VHASHSIZE	HTKLib/HDict.h	32;"	d
VIRTUAL	HTKLib/esignal.h	92;"	d
VMax	HTKTools/HHEd.c	/^void VMax(Vector a, Vector b)$/;"	f
VNorm	HTKTools/HHEd.c	/^void VNorm(Vector a, int n)$/;"	f
VOLUME_STEPS	HTKTools/HSLab.c	102;"	d	file:
VQNode	HTKLib/HVQ.h	/^typedef struct _VQNodeRec *VQNode;$/;"	t	typeref:struct:_VQNodeRec
VQNodeRec	HTKLib/HVQ.h	/^}VQNodeRec;$/;"	t	typeref:struct:_VQNodeRec
VQNodeScore	HTKLib/HVQ.c	/^float VQNodeScore(VQNode n, Vector v, int size, CovKind ck)$/;"	f
VQTABLE	HTKLib/HParm.c	/^   VQTABLE,       \/* Name of file holding VQ table *\/$/;"	e	enum:__anon77	file:
VQTabRec	HTKLib/HVQ.h	/^}VQTabRec;$/;"	t	typeref:struct:_VQTabRec
VQTable	HTKLib/HVQ.h	/^typedef struct _VQTabRec *VQTable;$/;"	t	typeref:struct:_VQTabRec
VQbased	HTKLib/HParm.c	/^typedef enum { FFTbased, LPCbased, VQbased} CodeStyle;$/;"	e	enum:__anon75	file:
VRecInfo	HTKLib/HRec.h	/^typedef struct vrecinfo VRecInfo; \/* Visible recognition information *\/$/;"	t	typeref:struct:vrecinfo
VSetLabelList	HTKTools/HLEd.c	/^void VSetLabelList(int n)$/;"	f
VaAcc	HTKLib/HTrain.h	/^} VaAcc;$/;"	t	typeref:struct:__anon114
ValidCodeParms	HTKLib/HParm.c	/^static void ValidCodeParms(IOConfig cf)$/;"	f	file:
ValidConversion	HTKLib/HParm.c	/^Boolean ValidConversion (ParmKind src, ParmKind tgt)$/;"	f
ValidProbNode	HTKTools/HHEd.c	/^void ValidProbNode(Node *node,float thresh)$/;"	f
ValidType	HTKLib/esignal.c	/^ValidType(int type    \/* numeric data-type code *\/ )$/;"	f
Vector	HTKLib/HMem.h	/^typedef float *Vector;     \/* vector[1..size]   *\/$/;"	t
VectorElemSize	HTKLib/HMem.c	/^size_t VectorElemSize(int size) { return (size+1)*sizeof(float); }$/;"	f
VectorSize	HTKLib/HMem.c	/^int VectorSize(Vector v)$/;"	f
VersionEntry	HTKLib/HShell.c	/^}VersionEntry;$/;"	t	typeref:struct:_VersionEntry	file:
ViterbiAlign	HTKTools/HInit.c	/^LogFloat ViterbiAlign(int segNum,int segLen, IntVec states, IntVec *mixes)$/;"	f
Vocab	HTKLib/HDict.h	/^} Vocab;$/;"	t	typeref:struct:__anon74
VocabHash	HTKLib/HDict.c	/^static int VocabHash(LabId name)$/;"	f	file:
VolType	HTKLib/HAudio.c	/^} VolType;$/;"	t	typeref:enum:__anon51	file:
W	HLMTools/Cluster.c	/^static int         W = 0;     		    \/* Number of words *\/$/;"	v	file:
W	HTKLib/HRNLM.h	/^    float *U, *W;$/;"	m	struct:_Layer
WALink	HTKTools/HSmooth.c	/^typedef struct _ChWtAcc *WALink;$/;"	t	typeref:struct:_ChWtAcc	file:
WARPFREQ	HTKLib/HParm.c	/^   WARPFREQ,      \/* Vocal tract length compensation by frequency warping *\/$/;"	e	enum:__anon77	file:
WARPLCUTOFF	HTKLib/HParm.c	/^   WARPLCUTOFF,   \/* VTL warping cutoff frequencies for smoothing *\/$/;"	e	enum:__anon77	file:
WARPUCUTOFF	HTKLib/HParm.c	/^   WARPUCUTOFF,$/;"	e	enum:__anon77	file:
WAV	HTKLib/HWave.h	/^	WAV,               \/* Microsoft WAVE format *\/$/;"	e	enum:__anon36
WAVEFORM	HTKLib/HParm.h	/^      WAVEFORM,            \/* Raw speech waveform (handled by HWave) *\/$/;"	e	enum:_BaseParmKind
WAVEFORM	HTKLib/HWave.c	1398;"	d	file:
WAVEFORM	HTKLib/HWave.c	47;"	d	file:
WAVE_FORMAT_ALAW	HTKLib/HWave.c	52;"	d	file:
WAVE_FORMAT_MULAW	HTKLib/HWave.c	53;"	d	file:
WAVE_FORMAT_PCM	HTKLib/HWave.c	50;"	d	file:
WAVE_WIN	HTKTools/HSLab.c	/^   WAVE_WIN, LAB_WIN, IO_WIN, NO_WIN $/;"	e	enum:__anon143	file:
WBDEF	HTKTools/HLEd.c	/^   SBDEF,   EXPAND, IFILL,  SORT,   WBDEF,  VBDEF,  LCTXT,  $/;"	e	enum:__anon141	file:
WCHAR	HTKLib/esignal.h	81;"	d
WCH_W	HTKLib/esig_asc.c	96;"	d	file:
WDPEN	HTKLib/HArc.c	/^static float WDPEN = 0;$/;"	v	file:
WEIGHTS_KEY	HTKLib/HUtil.c	/^   TRANSP_KEY, STATE_KEY, DUR_KEY, WEIGHTS_KEY,$/;"	e	enum:__anon132	file:
WHITE	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	e	enum:_HColour
WIDTH	HTKTools/HSLab.c	78;"	d	file:
WINDOWSIZE	HTKLib/HParm.c	/^   WINDOWSIZE,    \/* Window size in 100ns *\/ $/;"	e	enum:__anon77	file:
WINNAME	HTKTools/HSLab.c	70;"	d	file:
WMAP_HDR	HLMLib/LUtil.h	/^   NO_HDR, WMAP_HDR, CMAP_HDR, GRAM_HDR, LFOF_HDR$/;"	e	enum:__anon22
WNHASHSIZE	HTKLib/HNet.c	1753;"	d	file:
WORDFIELDWIDTH	HTKLib/HDict.c	348;"	d	file:
WPGrammar	HTKTools/HBuild.c	/^}WPGrammar;$/;"	t	typeref:struct:__anon164	file:
WPtrOff	HTKTools/HSLab.c	/^void WPtrOff(void)$/;"	f
WPtrOn	HTKTools/HSLab.c	/^void WPtrOn(void)$/;"	f
WarpFreq	HTKLib/HSigP.c	/^float WarpFreq (float fcl, float fcu, float freq, float minFreq, float maxFreq , float alpha)$/;"	f
Wave	HTKLib/HWave.h	/^typedef struct _Wave *Wave;  \/* Abstract type representing waveform file *\/$/;"	t	typeref:struct:_Wave
Wave2FBank	HTKLib/HSigP.c	/^void Wave2FBank(Vector s, Vector fbank, float *te, FBankInfo info)$/;"	f
Wave2LPC	HTKLib/HSigP.c	/^void Wave2LPC (Vector s, Vector a, Vector k, float *re, float *te)$/;"	f
WaveFilter	HTKLib/HShell.h	/^   WaveFilter,      \/* waveforms input via HWave *\/$/;"	e	enum:__anon83
WaveFormat	HTKLib/HWave.c	/^FileFormat WaveFormat(Wave w)$/;"	f
WaveOFilter	HTKLib/HShell.h	/^   WaveOFilter,     \/* waveforms output via HWave *\/$/;"	e	enum:__anon83
WaveRec	HTKLib/HWave.c	/^}WaveRec;$/;"	t	typeref:struct:_Wave	file:
Wchar	HTKLib/esignal.h	/^typedef unsigned short			Wchar;$/;"	t
Wd_Cmp	HTKLib/HDict.c	/^static int Wd_Cmp(const void *v1,const void *v2)$/;"	f	file:
WeightCepstrum	HTKLib/HSigP.c	/^void WeightCepstrum (Vector c, int start, int count, int cepLiftering)$/;"	f
Wf	HTKLib/HRNLM.h	/^    float *Ui, *Uf, *Uo, *Wi, *Wf, *Wo;$/;"	m	struct:_Layer
Wh	HTKLib/HRNLM.h	/^    float *Wr, *Wz, *Wh, *Ur, *Uz, *Uh;$/;"	m	struct:_Layer
Whw	HTKLib/HRNLM.h	/^    float *Uhw, *Whw;$/;"	m	struct:_Layer
Wi	HTKLib/HRNLM.h	/^    float *Ui, *Uf, *Uo, *Wi, *Wf, *Wo;$/;"	m	struct:_Layer
WinKind	HTKTools/HSLab.c	/^} WinKind;$/;"	t	typeref:enum:__anon143	file:
Wo	HTKLib/HRNLM.h	/^    float *Ui, *Uf, *Uo, *Wi, *Wf, *Wo;$/;"	m	struct:_Layer
Word	HTKLib/HDict.h	/^typedef struct _DictEntry *Word;$/;"	t	typeref:struct:_DictEntry
WordBuf	HTKTools/HDMan.c	/^}WordBuf;$/;"	t	typeref:struct:__anon161	file:
WordClass	HLMLib/LCMap.c	/^int WordClass(ClassMap *c, int wdndx)$/;"	f
WordFllr	HTKTools/HBuild.c	/^}WordFllr;$/;"	t	typeref:struct:_WordFllr	file:
WordInfo	HTKTools/HLStats.c	/^} WordInfo;$/;"	t	typeref:struct:wordinfo	file:
WordLMCmp	HLMLib/LWMap.c	/^int WordLMCmp(int ndx1, int ndx2, WordMap *wm)$/;"	f
WordLMCount	HLMLib/LWMap.c	/^int WordLMCount(LabId id)$/;"	f
WordLMIndex	HLMLib/LWMap.c	/^int WordLMIndex(LabId id)$/;"	f
WordLMName	HLMLib/LWMap.c	/^LabId WordLMName(int ndx, WordMap *wm)$/;"	f
WordMap	HLMLib/LWMap.h	/^} WordMap;$/;"	t	typeref:struct:__anon20
WordMatch	HTKLib/HRec.c	/^static Boolean WordMatch(NBestEntry *cmp,NBestEntry *ans)$/;"	f	file:
WordProb	HLMLib/LModel.h	/^} WordProb;$/;"	t	typeref:struct:__anon15
WordPron	HTKLib/HDict.h	/^} WordPron;$/;"	t	typeref:struct:_WordPron
Wr	HTKLib/HRNLM.h	/^    float *Wr, *Wz, *Wh, *Ur, *Uz, *Uh;$/;"	m	struct:_Layer
WriteAsciiArray	HTKLib/esig_asc.c	/^WriteAsciiArray(Array *array, FILE *file, Annot *annotate)$/;"	f	file:
WriteAsciiData	HTKLib/esig_asc.c	/^WriteAsciiData(FieldSpec *field,$/;"	f	file:
WriteAsciiFieldList	HTKLib/esig_asc.c	/^WriteAsciiFieldList(FieldList list,$/;"	f
WriteAsciiFieldSpec	HTKLib/esig_asc.c	/^WriteAsciiFieldSpec(FieldSpec *field,$/;"	f	file:
WriteAsciiRecord	HTKLib/esig_asc.c	/^WriteAsciiRecord(FieldSpec **fields,    \/* linear array of fields *\/$/;"	f
WriteAsciiSamples	HTKLib/esig_asc.c	/^WriteAsciiSamples(void      *data,$/;"	f
WriteAsciiString	HTKLib/esig_asc.c	/^WriteAsciiString(char *data,$/;"	f	file:
WriteBoNGram	HTKLib/HLM.c	/^static void WriteBoNGram(LModel *lm,char *fn,int flags)$/;"	f	file:
WriteClassMap	HLMLib/LCMap.c	/^static void WriteClassMap(FILE *f, ClassMap *cm, Boolean debug)$/;"	f	file:
WriteDict	HTKLib/HDict.c	/^ReturnStatus WriteDict(char *dictFn, Vocab *voc)$/;"	f
WriteDictWord	HTKTools/HDMan.c	/^void WriteDictWord(DBuffer *db, FILE *f, int margin, Boolean findNew)$/;"	f
WriteESIGPHeader	HTKLib/HParm.c	/^void WriteESIGPHeader(FILE *f, IOConfig cf, HTime sampPeriod, short sampSize, short pKind)$/;"	f
WriteEdrArray	HTKLib/esig_edr.c	/^WriteEdrArray(Array *array,$/;"	f	file:
WriteEdrData	HTKLib/esig_edr.c	/^WriteEdrData(FieldSpec  *field,$/;"	f	file:
WriteEdrFieldList	HTKLib/esig_edr.c	/^WriteEdrFieldList(FieldList list,   \/* field list *\/$/;"	f
WriteEdrFieldSpec	HTKLib/esig_edr.c	/^WriteEdrFieldSpec(FieldSpec *field,$/;"	f	file:
WriteEdrRecord	HTKLib/esig_edr.c	/^WriteEdrRecord(FieldSpec    **fields,$/;"	f
WriteEdrSamples	HTKLib/esig_edr.c	/^WriteEdrSamples(void        *data,$/;"	f
WriteEdrString	HTKLib/esig_edr.c	/^WriteEdrString(char     *string,$/;"	f	file:
WriteEntry	HTKTools/HDMan.c	/^void WriteEntry(FILE *f, LabId word, LabId outsym, Pronunciation *p, int margin, Boolean findNew)$/;"	f
WriteFieldList	HTKLib/esignal.c	/^WriteFieldList(FieldList list,$/;"	f
WriteFloat	HTKLib/HShell.c	/^void WriteFloat (FILE *f, float *x, int n, Boolean binary)$/;"	f
WriteFoFHeader	HLMLib/LGBase.c	/^static void WriteFoFHeader(FILE *f, FoFTab *tab, char *source)$/;"	f	file:
WriteFoFTab	HLMLib/LGBase.c	/^void WriteFoFTab(char *fn, FoFTab *tab, char *source)$/;"	f
WriteHTKHeader	HTKLib/HWave.c	/^void WriteHTKHeader(FILE *f, long nSamp, long sampP, short sampS, $/;"	f
WriteHeader	HTKLib/esignal.c	/^WriteHeader(FieldList  list,$/;"	f
WriteHeaderInfo	HLMLib/LModel.c	/^void WriteHeaderInfo(FILE *f, BackOffLM *lm)$/;"	f
WriteInt	HTKLib/HShell.c	/^void WriteInt(FILE *f, int *i, int n, Boolean binary)$/;"	f
WriteIntVec	HTKLib/HMath.c	/^void WriteIntVec(FILE *f, IntVec v, Boolean binary)$/;"	f
WriteLModel	HTKLib/HLM.c	/^void WriteLModel(LModel *lm,char *fn,int flags)$/;"	f
WriteLattice	HTKLib/HNet.c	/^ReturnStatus WriteLattice(Lattice *lat,FILE *file,LatFormat format)$/;"	f
WriteMapHeader	HLMLib/LCMap.c	/^static void WriteMapHeader(FILE *f, ClassMap *cm)$/;"	f	file:
WriteMapHeader	HLMLib/LWMap.c	/^static void WriteMapHeader(FILE *f, WordMap *w)$/;"	f	file:
WriteMatBigram	HTKLib/HLM.c	/^static void WriteMatBigram(LModel *lm,char *fn,int flags)$/;"	f	file:
WriteMatrix	HTKLib/HMath.c	/^void WriteMatrix(FILE *f, Matrix m, Boolean binary)$/;"	f
WriteNEntry	HLMLib/LModel.c	/^static int WriteNEntry(FILE *f, BackOffLM *lm, int lev, FLEntry **feBuf,$/;"	f	file:
WriteNGBuffer	HLMLib/LGBase.c	/^void WriteNGBuffer(NGBuffer *ngb, char *source)$/;"	f
WriteNGHeader	HLMLib/LGBase.c	/^static void WriteNGHeader(FILE *f, NGBuffer *ngb, char *source)$/;"	f	file:
WriteNGram	HLMLib/LGBase.c	/^int WriteNGram(FILE *f, int N, NGram ng)$/;"	f
WriteNGram	HLMLib/LModel.c	/^static int WriteNGram(FILE *f, BackOffLM *lm, FLEntry **feStack,$/;"	f	file:
WriteNGrams	HTKLib/HLM.c	/^static int WriteNGrams(FILE *file,NGramLM *nglm,int n,float scale)$/;"	f	file:
WriteNativeArray	HTKLib/esig_nat.c	/^WriteNativeArray(Array *array,$/;"	f	file:
WriteNativeData	HTKLib/esig_nat.c	/^WriteNativeData(FieldSpec *field,$/;"	f	file:
WriteNativeFieldList	HTKLib/esig_nat.c	/^WriteNativeFieldList(FieldList list,$/;"	f
WriteNativeFieldSpec	HTKLib/esig_nat.c	/^WriteNativeFieldSpec(FieldSpec  *field,$/;"	f	file:
WriteNativeRecord	HTKLib/esig_nat.c	/^WriteNativeRecord(FieldSpec **fields,$/;"	f
WriteNativeSamples	HTKLib/esig_nat.c	/^WriteNativeSamples(void     *data,$/;"	f
WriteNativeString	HTKLib/esig_nat.c	/^WriteNativeString(char *string,$/;"	f	file:
WriteOneLattice	HTKLib/HNet.c	/^ReturnStatus WriteOneLattice(Lattice *lat,FILE *file,LatFormat format)$/;"	f
WritePreamble	HTKLib/esignal.c	/^WritePreamble(char  *arch,$/;"	f
WriteRawHGram	HLMLib/LGBase.c	/^void WriteRawHGram(FILE *f, char *name, int N, NGram ng, WordMap *wm)$/;"	f
WriteRecord	HTKLib/esignal.c	/^WriteRecord(FieldSpec   **fields,$/;"	f
WriteSEntry	HLMLib/LModel.c	/^static int WriteSEntry(FILE *f,BackOffLM *lm,FLEntry **feTab, int fetCount)$/;"	f	file:
WriteSamples	HTKLib/esignal.c	/^WriteSamples(void       *data,$/;"	f
WriteShort	HTKLib/HShell.c	/^void WriteShort (FILE *f, short *s, int n, Boolean binary)$/;"	f
WriteShortVec	HTKLib/HMath.c	/^void WriteShortVec(FILE *f, ShortVec v, Boolean binary)$/;"	f
WriteString	HTKLib/HShell.c	/^void WriteString(FILE *f,char *s,char q)$/;"	f
WriteTriMat	HTKLib/HMath.c	/^void WriteTriMat(FILE *f, TriMat m, Boolean binary)$/;"	f
WriteTxtHGram	HLMLib/LGBase.c	/^static void WriteTxtHGram(FILE *f, char *name, int N, LabId *ng)$/;"	f	file:
WriteVQTable	HTKTools/HQuant.c	/^void WriteVQTable(ClusterSet *cs[], char *fn)$/;"	f
WriteVector	HTKLib/HMath.c	/^void WriteVector(FILE *f, Vector v, Boolean binary)$/;"	f
WriteWordMap	HLMLib/LWMap.c	/^static void WriteWordMap(FILE *f, WordMap *w, Boolean noHeader, Boolean debug)$/;"	f	file:
WritingToMeta	HTKLib/HGraf_WIN32.c	/^static Boolean WritingToMeta = FALSE;               \/* TRUE if spooling to a metafile *\/$/;"	v	file:
WtAcc	HTKLib/HTrain.h	/^} WtAcc;$/;"	t	typeref:struct:__anon112
Wz	HTKLib/HRNLM.h	/^    float *Wr, *Wz, *Wh, *Ur, *Uz, *Uh;$/;"	m	struct:_Layer
XColArray	HTKLib/HGraf.c	/^static char  *XColArray[] = {$/;"	v	file:
XF	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon168	file:
XFDirInfo	HTKLib/HModel.c	/^} XFDirInfo;$/;"	t	typeref:struct:_XFDirInfo	file:
XFDirLink	HTKLib/HModel.c	/^typedef struct _XFDirInfo *XFDirLink;$/;"	t	typeref:struct:_XFDirInfo	file:
XFInfo	HTKLib/HAdapt.h	/^} XFInfo;$/;"	t	typeref:struct:__anon37
XFORM	HTKLib/HModel.c	/^   MEAN, VARIANCE, INVCOVAR, XFORM, GCONST,$/;"	e	enum:__anon40	file:
XFORM	HTKLib/HModel.h	62;"	d
XFORMC	HTKLib/HMath.h	/^   XFORMC,        \/* arbitrary rectangular transform *\/$/;"	e	enum:__anon43
XFORMCOV	HTKLib/HModel.c	/^   DIAGCOV,  FULLCOV, XFORMCOV,$/;"	e	enum:__anon40	file:
XFORMKIND	HTKLib/HModel.c	/^   XFORMKIND=90, PARENTXFORM, NUMXFORMS, XFORMSET,$/;"	e	enum:__anon40	file:
XFORMSET	HTKLib/HModel.c	/^   XFORMKIND=90, PARENTXFORM, NUMXFORMS, XFORMSET,$/;"	e	enum:__anon40	file:
XFORMWGTSET	HTKLib/HModel.c	/^   CLASS, XFORMWGTSET, CLASSXFORM, MMFIDMASK, PARAMETERS,$/;"	e	enum:__anon40	file:
XFormAccInfo	HTKLib/HModel.h	/^} XFormAccInfo;$/;"	t	typeref:struct:__anon66
XFormInfo	HTKLib/HAdapt.c	/^} XFormInfo;$/;"	t	typeref:struct:__anon95	file:
XFormKind	HTKLib/HModel.h	/^typedef enum _XFormKind XFormKind;$/;"	t	typeref:enum:_XFormKind
XFormKind2Str	HTKLib/HModel.c	/^char *XFormKind2Str(XFormKind xkind, char *buf)$/;"	f
XFormModCovar	HTKLib/HAdapt.c	/^static Boolean XFormModCovar(AdaptXForm *xform)$/;"	f	file:
XFormSet	HTKLib/HModel.h	/^} XFormSet;$/;"	t	typeref:struct:__anon69
XK_MISCELLANY	HTKLib/HGraf.c	76;"	d	file:
XOutP	HTKLib/HModel.c	/^static LogFloat XOutP(Vector x, int vecSize, MixPDF *mp)$/;"	f	file:
X_	HTKTools/Makefile	/^	if [ X_ = X_yes ] ; then $(INSTALL) -m 755 $@ $(bindir)  ; fi$/;"	m
XferMode	HTKLib/HGraf.h	/^typedef enum _XferMode XferMode;$/;"	t	typeref:enum:_XferMode
XformBase	HTKLib/HParm.c	/^static void XformBase(float *data, IOConfig cf)$/;"	f	file:
XformFBANK2MELSPEC	HTKLib/HParm.c	/^static void XformFBANK2MELSPEC(float *data,int d)$/;"	f	file:
XformFBANK2MFCC	HTKLib/HParm.c	/^static void XformFBANK2MFCC(float *data,int d,int dnew,int lifter)$/;"	f	file:
XformLPC2LPCEPSTRA	HTKLib/HParm.c	/^static void XformLPC2LPCEPSTRA(float *data,int d,int dnew,int lifter)$/;"	f	file:
XformLPC2LPREFC	HTKLib/HParm.c	/^static void XformLPC2LPREFC(float *data,int d)$/;"	f	file:
XformLPCEPSTRA2LPC	HTKLib/HParm.c	/^static void XformLPCEPSTRA2LPC(float *data,int d,int lifter)$/;"	f	file:
XformLPREFC2LPC	HTKLib/HParm.c	/^static void XformLPREFC2LPC(float *data,int d)$/;"	f	file:
XformMELSPEC2FBANK	HTKLib/HParm.c	/^static void XformMELSPEC2FBANK(float *data,int d)$/;"	f	file:
XrmInitialize	configure	/^XrmInitialize ()$/;"	f
YELLOW	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	e	enum:_HColour
ZMEANSOURCE	HTKLib/HParm.c	/^   ZMEANSOURCE,   \/* Zero Mean (Wave only) *\/$/;"	e	enum:__anon77	file:
ZapAliases	HTKTools/HHEd.c	/^void ZapAliases(void)$/;"	f
ZeroAccSum	HTKTools/HHEd.c	/^void ZeroAccSum(AccSum *acc)$/;"	f
ZeroAccs	HTKLib/HTrain.c	/^void ZeroAccs(HMMSet *hset, UPDSet uFlags){ ZeroAccsParallel(hset,uFlags,1); }$/;"	f
ZeroAccsParallel	HTKLib/HTrain.c	/^void ZeroAccsParallel(HMMSet *hset, UPDSet uFlags, int nPara)$/;"	f
ZeroAdaptAccs	HTKLib/HAdapt.c	/^void ZeroAdaptAccs(HMMSet *hset, AdaptXForm *xform)$/;"	f
ZeroAlpha	HTKLib/HFB.c	/^static void ZeroAlpha(AlphaBeta *ab, int qlo, int qhi)$/;"	f	file:
ZeroAlpha	HTKLib/HFBLat.c	/^static void ZeroAlpha(int sq, int eq)$/;"	f	file:
ZeroBaseTriMat	HTKLib/HAdapt.c	/^static void ZeroBaseTriMat(TriMat *bTriMat)$/;"	f	file:
ZeroBlockTriMat	HTKLib/HAdapt.c	/^static void ZeroBlockTriMat(TriMat *bTriMat)$/;"	f	file:
ZeroDMatrix	HTKLib/HMath.c	/^void ZeroDMatrix(DMatrix m)$/;"	f
ZeroDVector	HTKLib/HMath.c	/^void ZeroDVector(DVector v)$/;"	f
ZeroHooks	HTKLib/HArc.c	/^void ZeroHooks(Lattice *lat){ \/*Checks that the hooks are zero.*\/$/;"	f
ZeroIntVec	HTKLib/HMath.c	/^void ZeroIntVec(IntVec v)$/;"	f
ZeroMatrix	HTKLib/HMath.c	/^void ZeroMatrix(Matrix m)$/;"	f
ZeroMean	HTKLib/HSigP.c	/^void ZeroMean(short *data, long nSamples)$/;"	f
ZeroMeanFrame	HTKLib/HParm.c	/^void ZeroMeanFrame(Vector v)$/;"	f
ZeroMeanWave	HTKLib/HWave.c	/^void ZeroMeanWave(Wave w)$/;"	f
ZeroShortVec	HTKLib/HMath.c	/^void ZeroShortVec(ShortVec v)$/;"	f
ZeroStats	HLMTools/LPlex.c	/^static void ZeroStats(PStats *ps)$/;"	f	file:
ZeroStreamWidths	HTKLib/HParm.c	/^void ZeroStreamWidths(int numS, short *swidth)$/;"	f
ZeroTriMat	HTKLib/HMath.c	/^void ZeroTriMat(TriMat m)$/;"	f
ZeroVector	HTKLib/HMath.c	/^void ZeroVector(Vector v)$/;"	f
ZoomRecord	HTKTools/HSLab.c	/^} ZoomRecord;$/;"	t	typeref:struct:__anon145	file:
_AInfo	HTKLib/HAdapt.c	/^typedef struct _AInfo {$/;"	s	file:
_AccCache	HTKLib/HAdapt.c	/^typedef struct _AccCache{$/;"	s	file:
_AccSum	HTKTools/HHEd.c	/^typedef struct _AccSum {        \/* Accumulator Record for storing *\/$/;"	s	file:
_AccessInfo	HLMLib/LModel.c	/^typedef struct _AccessInfo{$/;"	s	file:
_Acoustic	HTKLib/HArc.h	/^typedef struct _Acoustic{$/;"	s
_AdaptKind	HTKLib/HModel.h	/^enum _AdaptKind {TREE, BASE};$/;"	g
_AdaptXForm	HTKLib/HModel.h	/^typedef struct _AdaptXForm {$/;"	s
_AltState	HTKLib/HGraf_WIN32.c	/^enum _AltState {ALT_UP,ALT_DOWN}; \/* keep track of Alt key *\/$/;"	g	file:
_Arc	HTKLib/HArc.h	/^struct _Arc{$/;"	s
_ArcList	HTKLib/HArc.c	/^typedef struct _ArcList{$/;"	s	file:
_ArcTrans	HTKLib/HArc.h	/^struct _ArcTrans{$/;"	s
_AudioIn	HTKLib/HAudio.c	/^typedef struct _AudioIn {$/;"	s	file:
_AudioOut	HTKLib/HAudio.c	/^typedef struct _AudioOut {$/;"	s	file:
_BSD_SIGNALS	HTKLib/HGraf.c	69;"	d	file:
_BaseClassKind	HTKLib/HModel.h	/^enum _BaseClassKind {MIXBASE, MEANBASE, COVBASE};$/;"	g
_BaseParmKind	HTKLib/HParm.h	/^enum _BaseParmKind{$/;"	g
_Block	HTKLib/HMem.h	/^typedef struct _Block{  \/*      MHEAP                     MSTAK           *\/$/;"	s
_CRec	HTKTools/HHEd.c	/^typedef struct _CRec{$/;"	s	file:
_Cell	HTKTools/HResults.c	/^typedef struct _Cell{           \/* used in DP routines below *\/$/;"	s	file:
_ChWtAcc	HTKTools/HSmooth.c	/^typedef struct _ChWtAcc{     \/* attached to StreamElem *\/$/;"	s	file:
_CoList	HTKTools/HHEd.c	/^typedef struct _CoList {$/;"	s	file:
_CompressType	HTKLib/HWave.c	/^enum _CompressType{$/;"	g	file:
_ConfigEntry	HTKLib/HShell.c	/^typedef struct _ConfigEntry{$/;"	s	file:
_Context	HTKTools/HLEd.c	/^typedef struct _Context{$/;"	s	file:
_CorrA	HTKLib/HArc.h	/^struct _CorrA{$/;"	s
_CorrN	HTKLib/HArc.h	/^struct _CorrN{$/;"	s
_CorrectArcList	HTKLib/HFBLat.c	/^typedef struct _CorrectArcList{$/;"	s	file:
_DictEntry	HTKLib/HDict.h	/^typedef struct _DictEntry{$/;"	s
_Direction	HTKTools/HResults.c	/^enum _Direction{DIAG,VERT,HOR,NIL};$/;"	g	file:
_DurKind	HTKLib/HModel.h	/^enum _DurKind {NULLD, POISSOND, GAMMAD, RELD, GEND};$/;"	g
_ESIGNAL_H_	HTKLib/esignal.h	31;"	d
_Equiv	HLMTools/LPlex.c	/^struct _Equiv{$/;"	s	file:
_Equiv	HTKTools/HResults.c	/^struct _Equiv{$/;"	s	file:
_FLEntry	HLMLib/LModel.h	/^typedef struct _FLEntry {   \/* Full LM entry, single level of context *\/$/;"	s
_FindAcc	HTKTools/HLEd.c	/^typedef struct _FindAcc{$/;"	s	file:
_FixHMMForICrit	HTKTools/HMMIRest.c	/^static void _FixHMMForICrit(float Tau, Boolean THREEACCS){$/;"	f	file:
_GramEntry	HTKTools/HBuild.c	/^typedef struct _GramEntry{$/;"	s	file:
_HADAPT_H_	HTKLib/HAdapt.h	32;"	d
_HAUDIO_H_	HTKLib/HAudio.h	25;"	d
_HButton	HTKLib/HGraf.h	/^typedef struct _HButton { $/;"	s
_HColour	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	g
_HDICT_H_	HTKLib/HDict.h	25;"	d
_HEvent	HTKLib/HGraf.h	/^enum _HEvent {HMOUSEDOWN,  \/* (left) mouse button pressed *\/$/;"	g
_HFB_H_	HTKLib/HFB.h	25;"	d
_HGRAF_H_	HTKLib/HGraf.h	44;"	d
_HLABEL_H_	HTKLib/HLabel.h	54;"	d
_HLAT_H_	HTKLib/HLat.h	33;"	d
_HLM_H_	HTKLib/HLM.h	38;"	d
_HMATH_H_	HTKLib/HMath.h	25;"	d
_HMEM_H_	HTKLib/HMem.h	51;"	d
_HMMSet	HTKLib/HModel.h	/^typedef struct _HMMSet{$/;"	s
_HMODEL_H_	HTKLib/HModel.h	38;"	d
_HNET_H_	HTKLib/HNet.h	52;"	d
_HNLM_H_	HTKLib/HNLM.h	38;"	d
_HPARM_H_	HTKLib/HParm.h	38;"	d
_HREC_H_	HTKLib/HRec.h	25;"	d
_HRNLM_H	HTKLib/HRNLM.h	37;"	d
_HSHELL_H_	HTKLib/HShell.h	38;"	d
_HSIGP_H_	HTKLib/HSigP.h	38;"	d
_HSetKind	HTKLib/HModel.h	/^enum _HSetKind {PLAINHS, SHAREDHS, TIEDHS, DISCRETEHS};$/;"	g
_HTRAIN_H_	HTKLib/HTrain.h	38;"	d
_HUTIL_H_	HTKLib/HUtil.h	25;"	d
_HVQ_H_	HTKLib/HVQ.h	50;"	d
_HWAVE_H_	HTKLib/HWave.h	36;"	d
_HashSlot	HTKLib/HRNLM.h	/^typedef struct _HashSlot {$/;"	s
_IPat	HTKTools/HHEd.c	/^typedef struct _IPat{$/;"	s	file:
_ItemBlock	HTKLib/HTrain.h	/^typedef struct _ItemBlock{$/;"	s
_ItemRec	HTKLib/HModel.h	/^typedef struct _ItemRec {$/;"	s
_KeyType	HTKLib/HGraf.h	/^enum _KeyType {NORMALKEY, SHIFTKEY, COMMANDKEY, CONTROLKEY, $/;"	g
_LCMAP_H	HLMLib/LCMap.h	35;"	d
_LGBASE_H_	HLMLib/LGBase.h	35;"	d
_LLFInfo	HTKLib/HLat.c	/^struct _LLFInfo {$/;"	s	file:
_LMODEL_H	HLMLib/LModel.h	41;"	d
_LPCALC_H	HLMLib/LPCalc.h	35;"	d
_LPMERGE_H	HLMLib/LPMerge.h	37;"	d
_LUTIL_H	HLMLib/LUtil.h	35;"	d
_LWMAP_H	HLMLib/LWMap.h	36;"	d
_LabList	HTKLib/HLabel.h	/^typedef struct _LabList{$/;"	s
_Label	HTKLib/HLabel.h	/^typedef struct _Label{     \/* Information for each label *\/$/;"	s
_Layer	HTKLib/HRNLM.h	/^typedef struct _Layer$/;"	s
_MLFDefType	HTKLib/HLabel.h	/^enum _MLFDefType {$/;"	g
_MLFEntry	HTKLib/HLabel.h	/^typedef struct _MLFEntry{$/;"	s
_MLFPatType	HTKLib/HLabel.h	/^enum _MLFPatType {$/;"	g
_MMFInfo	HTKLib/HModel.h	/^typedef struct _MMFInfo{$/;"	s
_MPEStruct	HTKLib/HArc.h	/^typedef struct _MPEStruct{$/;"	s
_MacroDef	HTKLib/HModel.h	/^typedef struct _MacroDef{$/;"	s
_MemHeapRec	HTKLib/HMem.c	/^typedef struct _MemHeapRec {$/;"	s	file:
_NameCell	HTKLib/HLabel.h	/^typedef struct _NameCell{  \/* Hash Table Linked List Item *\/$/;"	s
_NameHolder	HLMLib/LUtil.h	/^typedef struct _NameHolder{    \/* Hash Table Linked List Item *\/$/;"	s
_NetInst	HTKLib/HRec.c	/^struct _NetInst$/;"	s	file:
_NetLink	HTKLib/HNet.h	/^struct _NetLink{$/;"	s
_NetNode	HTKLib/HNet.h	/^struct _NetNode {$/;"	s
_Node	HTKTools/HHEd.c	/^typedef struct _Node {          \/* Tree Node *\/$/;"	s	file:
_Node	HTKTools/HParse.c	/^typedef struct _Node{$/;"	s	file:
_NodeInfo	HTKTools/HParse.c	/^typedef struct _NodeInfo{$/;"	s	file:
_ObsCache	HTKLib/HAdapt.c	/^typedef struct _ObsCache{$/;"	s	file:
_ParmBuf	HTKLib/HParm.c	/^typedef struct _ParmBuf {$/;"	s	file:
_PtrMap	HTKLib/HModel.h	/^typedef struct _PtrMap {   \/* used for finding macros via ptr's *\/$/;"	s
_QEnt	HTKTools/HHEd.c	/^typedef struct _QEnt{           \/* each question stored as both pattern and  *\/$/;"	s	file:
_RNNLM	HTKLib/HRNLM.h	/^typedef struct _RNNLM{$/;"	s
_RegNode	HTKLib/HModel.h	/^typedef struct _RegNode {$/;"	s
_SMEntry	HLMLib/LModel.h	/^typedef struct _SMEntry {$/;"	s
_STRARR_H_	HTKLib/strarr.h	21;"	d
_ScribeLab	HTKLib/HLabel.c	/^enum _ScribeLab {$/;"	g	file:
_ScriptItem	HTKTools/HDMan.c	/^typedef struct _ScriptItem{     \/* internal rep of a complete edit script *\/$/;"	s	file:
_ScriptItem	HTKTools/HLEd.c	/^typedef struct _ScriptItem{$/;"	s	file:
_SegStoreRec	HTKLib/HTrain.h	/^typedef struct _SegStoreRec{$/;"	s
_Spkr	HTKTools/HResults.c	/^typedef struct _Spkr{           \/* list of spkr records *\/$/;"	s	file:
_SpotRec	HTKTools/HResults.c	/^typedef struct _SpotRec{$/;"	s	file:
_SrcOrder	HTKLib/HWave.c	/^typedef enum _SrcOrder{$/;"	g	file:
_StatsInfo	HTKLib/HLat.c	/^typedef struct _StatsInfo {$/;"	s	file:
_SubLArc	HTKLib/HLat.c	/^struct _SubLArc {$/;"	s	file:
_SubLNode	HTKLib/HLat.c	/^struct _SubLNode {$/;"	s	file:
_SubNetDef	HTKTools/HParse.c	/^typedef struct _SubNetDef{$/;"	s	file:
_Symbol	HTKTools/HParse.c	/^enum _Symbol{NAMESYM, VARSYM, VARATSYM, LPARSYM, RPARSYM, LBRACESYM, $/;"	g	file:
_TrList	HTKTools/HCopy.c	/^typedef struct _TrList {      $/;"	s	file:
_TrSymbol	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	g	file:
_Tree	HTKTools/HHEd.c	/^typedef struct _Tree{           \/* A tree *\/$/;"	s	file:
_UPDSet	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	g
_VQNodeRec	HTKLib/HVQ.h	/^typedef struct _VQNodeRec{$/;"	s
_VQTabRec	HTKLib/HVQ.h	/^typedef struct _VQTabRec {$/;"	s
_VersionEntry	HTKLib/HShell.c	/^typedef struct _VersionEntry{$/;"	s	file:
_Wave	HTKLib/HWave.c	/^typedef struct _Wave{   \/* Internal wave file representation *\/$/;"	s	file:
_WordFllr	HTKTools/HBuild.c	/^typedef struct _WordFllr{   \/* storage for word followers *\/$/;"	s	file:
_WordPron	HTKLib/HDict.h	/^typedef struct _WordPron{   \/* storage for each pronunciation *\/$/;"	s
_XFDirInfo	HTKLib/HModel.c	/^typedef struct _XFDirInfo {$/;"	s	file:
_XFormKind	HTKLib/HModel.h	/^enum _XFormKind {MLLRMEAN, MLLRCOV, MLLRVAR, CMLLR, SEMIT};$/;"	g
_XferMode	HTKLib/HGraf.h	/^enum _XferMode {GCOPY, GOR, GXOR, GINVERT};$/;"	g
_layers	HTKLib/HRNLM.h	/^    Layer* _layers;$/;"	m	struct:_RNNLM
a	HTKLib/HParm.c	/^      AudioIn a;        \/* the audio source *\/$/;"	m	union:_ParmBuf::__anon78	file:
a	HTKLib/HParm.c	/^   Vector a,k;        \/* lpc and refc vectors *\/$/;"	m	struct:__anon76	file:
a	HTKLib/HParm.h	/^   AudioIn a;                 \/* the audio source - if any *\/$/;"	m	struct:__anon122
a2l	HTKLib/HWave.c	/^static short a2l[]={$/;"	v	file:
aCollThresh	HTKLib/HRec.h	/^   int aCollThresh;         \/* Max align records created before collection *\/$/;"	m	struct:vrecinfo
aInfo	HLMLib/LModel.h	/^   AccessInfo *aInfo;       \/* access statistics information *\/$/;"	m	struct:__anon14
aInfo	HTKLib/HAdapt.c	/^   AInfo *aInfo;         \/* current transform information *\/$/;"	m	struct:__anon95	file:
aInfo	HTKLib/HFBLat.h	/^  ArcInfo  *aInfo;$/;"	m	struct:__anon54
aNoRef	HTKLib/HRec.c	/^   Align aNoRef;            \/* Head of AlignNoRef linked list *\/$/;"	m	struct:precinfo	file:
aNoTail	HTKLib/HRec.c	/^   Align aNoTail;           \/* Tail of AlignNoRef linked list *\/$/;"	m	struct:precinfo	file:
aSet	HTKTools/HSmooth.c	/^static HLink *aSet;          \/* array[1..aSize]of allophone *\/$/;"	v	file:
aSetStack	HTKTools/HSmooth.c	/^static MemHeap aSetStack;$/;"	v	file:
aSize	HTKTools/HSmooth.c	/^static int aSize;            \/* size of current aSet *\/$/;"	v	file:
aYesRef	HTKLib/HRec.c	/^   Align aYesRef;           \/* Head of AlignYesRef linked list *\/$/;"	m	struct:precinfo	file:
aYesTail	HTKLib/HRec.c	/^   Align aYesTail;          \/* Tail of AlignYesRef linked list *\/$/;"	m	struct:precinfo	file:
a_layer_units	HTKLib/HNLM.h	/^    int a_layer_units[QN_MAX_LAYERS];$/;"	m	struct:mlpweightfile
a_layers	HTKLib/HNLM.c	/^static int a_layers = 4;          \/* number of layers and network size *\/$/;"	v	file:
a_layers	HTKLib/HNLM.h	/^    int a_layers;$/;"	m	struct:mlpweightfile
ab	HTKLib/HFB.h	/^  AlphaBeta *ab;      \/* Alpha-beta structure for this model *\/$/;"	m	struct:__anon139
abMem	HTKLib/HFB.h	/^  MemHeap abMem;      \/* alpha beta memory heap *\/$/;"	m	struct:__anon138
abortOnError	HTKLib/HShell.c	/^static Boolean abortOnError = FALSE;     \/* causes HError to abort *\/$/;"	v	file:
ac	HTKLib/HArc.h	/^  Acoustic *ac; $/;"	m	struct:_Arc
ac	HTKLib/HArc.h	/^  Acoustic *ac; \/* 1..Q *\/$/;"	m	struct:ArcInfoStruct
ac	HTKLib/HParm.c	/^   Vector as, ac, lp; \/* Auditory, autocorrelation an lp vectors for PLP *\/ $/;"	m	struct:__anon76	file:
ac	HTKLib/HRNLM.h	/^    real ac;$/;"	m	struct:neuron
acScale	HTKTools/HLRescore.c	/^static double acScale = 1.0;    \/* acoustic scale factor *\/$/;"	v	file:
acc	HTKTools/HLEd.c	/^   int acc;             \/* num of matches *\/$/;"	m	struct:_FindAcc	file:
accBTriMat	HTKLib/HModel.h	/^  Boolean accBTriMat;  \/* accumulate weighted outer-product of observations *\/$/;"	m	struct:__anon66
accStack	HTKTools/HERest.c	/^static MemHeap accStack;$/;"	v	file:
accStack	HTKTools/HMMIRest.c	/^static MemHeap accStack;           \/* accumulated statistics *\/$/;"	v	file:
accSum	HTKLib/HModel.h	/^  Boolean accSum;      \/* accumulate the sum of the observations *\/$/;"	m	struct:__anon66
accSumSq	HTKLib/HModel.h	/^  Boolean accSumSq;    \/* accumulate sum-squared (diag) of the observations *\/$/;"	m	struct:__anon66
accWin	HTKLib/HParm.c	/^   int accWin;                \/* Accel window halfsize *\/$/;"	m	struct:__anon76	file:
acccaStack	HTKLib/HAdapt.c	/^static MemHeap acccaStack;$/;"	v	file:
accessinfo	HLMLib/LModel.c	/^} accessinfo;$/;"	t	typeref:struct:_AccessInfo	file:
accs	HTKTools/HCompV.c	/^static CovAcc accs[SMAX];           \/* one CovAcc for each stream *\/$/;"	v	file:
accsStack	HTKTools/HRest.c	/^static MemHeap accsStack;        \/* For storage of accumulators *\/$/;"	v	file:
aclike	HTKLib/HArc.h	/^  LogDouble aclike; \/* [unscaled] acoustic likelihood from beginning to end of model. *\/$/;"	m	struct:_Acoustic
aclike	HTKLib/HNet.h	/^   LogFloat aclike;    \/* Acoustic likelihood of word *\/$/;"	m	struct:larc
acscale	HTKLib/HNet.h	/^   float acscale;               \/* Acoustic scale factor *\/$/;"	m	struct:lattice
actfile	HTKLib/HShell.c	/^   char actfile[1024];                  \/* actual file name *\/$/;"	m	struct:__anon140	file:
action	HTKLib/HGraf.h	/^   void (*action)(void);      \/* ptr to function to call whilst button is down *\/$/;"	m	struct:_HButton
active	HTKLib/HGraf.h	/^   Boolean active;            \/* if false, stipple gray *\/$/;"	m	struct:_HButton
adapt	HTKBook/htkbook-pdf.tex	/^\\include{train}$/;"	i
adapt	HTKBook/htkbook.tex	/^\\include{train}$/;"	i
adapt_ot	HTKLib/HFBLat.h	/^  Observation adapt_ot;   \/* for parent XForm *\/$/;"	m	struct:__anon54
add	HTKLib/HRNLM.c	/^void add (float *arr1, float *arr2, int num)$/;"	f
addDither	HTKLib/HParm.c	/^   float addDither;           \/* Additional dither added to file *\/$/;"	m	struct:__anon76	file:
add_index	HTKLib/HFBLat.c	/^static int add_index = 999;   \/* additional index for discriminative training: 3 for MPE with MMI prior *\/$/;"	v	file:
adddotmultiply	HTKLib/HRNLM.c	/^void adddotmultiply (float *arr1, float *arr2, float *wgt, int num)$/;"	f
adevin	HTKLib/HAudio.c	/^   UMSBAUDDevice adevin;$/;"	m	struct:_AudioIn	file:
adevout	HTKLib/HAudio.c	/^   UMSBAUDDevice adevout;$/;"	m	struct:_AudioOut	file:
adpLM	HLMTools/LAdapt.c	/^static BackOffLM *adpLM;            \/* the adapted final LM *\/$/;"	v	file:
aentry	HTKTools/HLStats.c	/^typedef struct aentry {          \/* Storage for counts *\/$/;"	s	file:
aetab	HTKTools/HLStats.c	/^static AEntry **aetab;           \/* Hash table for bigram accumulators  *\/$/;"	v	file:
aetabsize	HTKTools/HLStats.c	/^static int aetabsize=0;          \/* Size of hash table selected from .. *\/$/;"	v	file:
aiStatMap	HTKLib/HAudio.c	/^static char * aiStatMap[] = { "AI_CLEARED","AI_WAITSIG",$/;"	v	file:
akind	HTKLib/HModel.h	/^  AdaptKind akind;                  \/* adaptation kind *\/$/;"	m	struct:_AdaptXForm
alCompLevel	HTKLib/HFB.c	/^static Boolean alCompLevel = FALSE;   \/* align model at component level *\/$/;"	v	file:
alXFormDir	HTKLib/HAdapt.h	/^  char *alXFormDir;$/;"	m	struct:__anon37
alXFormExt	HTKLib/HAdapt.h	/^  char *alXFormExt;$/;"	m	struct:__anon37
al_dataStack	HTKLib/HFBLat.h	/^  MemHeap al_dataStack;$/;"	m	struct:__anon54
al_hmmDir	HTKTools/HERest.c	/^static char al_hmmDir[MAXFNAMELEN];  \/* dir to look for alignment hmm defs *\/$/;"	v	file:
al_hmmExt	HTKTools/HERest.c	/^static char al_hmmExt[MAXSTRLEN];  	 \/* alignment hmm def file extension *\/$/;"	v	file:
al_hmmLst	HTKTools/HERest.c	/^static char al_hmmLst[MAXFNAMELEN];  \/* alignment hmm list *\/$/;"	v	file:
al_hmmMMF	HTKTools/HERest.c	/^static char al_hmmMMF[MAXFNAMELEN];  \/* alignment hmm MMF *\/$/;"	v	file:
al_hmmUsed	HTKTools/HERest.c	/^static Boolean al_hmmUsed = FALSE;   \/* Set for 2-model ReEstimation *\/$/;"	v	file:
al_hset	HTKLib/HAdapt.h	/^  HMMSet *al_hset;$/;"	m	struct:__anon37
al_hset	HTKLib/HFB.h	/^  HMMSet *al_hset;    \/* HMMs to use for alignment *\/$/;"	m	struct:__anon139
al_hset	HTKTools/HERest.c	/^static HMMSet al_hset ;      	 \/* Option 2nd set of models for alignment *\/$/;"	v	file:
al_inXForm	HTKLib/HAdapt.h	/^  AdaptXForm *al_inXForm;$/;"	m	struct:__anon37
al_inXForm	HTKLib/HFB.h	/^  AdaptXForm *al_inXForm;\/* current input transform for al_hset (if any) *\/$/;"	m	struct:__anon139
al_info	HTKLib/HFBLat.h	/^  BufferInfo al_info;             \/* info from buffer on second data file *\/$/;"	m	struct:__anon54
al_ot	HTKLib/HFBLat.h	/^  Observation al_ot;$/;"	m	struct:__anon54
al_pbuf	HTKLib/HFBLat.h	/^  ParmBuf al_pbuf;$/;"	m	struct:__anon54
al_qList	HTKLib/HFB.h	/^  HLink *al_qList;    \/* array[1..Q] of active align HMM defs *\/$/;"	m	struct:__anon138
align	HTKLib/HArc.h	/^  short int align; $/;"	m	struct:_CorrN
align	HTKLib/HRec.c	/^  Align *align;$/;"	m	struct:nxtpath	file:
align	HTKLib/HRec.c	/^  Align *align;$/;"	m	struct:reltoken	file:
align	HTKLib/HRec.c	/^struct align$/;"	s	file:
align	HTKLib/HRec.h	/^   Align *align;        \/* Route (state\/model level) through network *\/$/;"	m	struct:token
align	HTKLib/HRec.h	/^   Align *align;        \/* State\/model traceback for this word *\/$/;"	m	struct:path
alignHeap	HTKLib/HRec.c	/^   MemHeap alignHeap;       \/* Align heap *\/$/;"	m	struct:precinfo	file:
alignpsi	HTKTools/HVite.c	/^static PSetInfo *alignpsi;        \/* Private data used by HRec *\/$/;"	v	file:
alignvri	HTKTools/HVite.c	/^static VRecInfo *alignvri;        \/* Visible HRec Info *\/$/;"	v	file:
allocMem	HTKLib/HRNLM.c	/^void allocMem (RNNLM* rnnlmodel)$/;"	f
allowCxtExp	HTKLib/HNet.c	/^Boolean allowCxtExp=TRUE;$/;"	v
allowOthers	HTKLib/HModel.c	/^static Boolean allowOthers=TRUE;        \/* allow unseen models in files *\/$/;"	v	file:
allowTMods	HTKLib/HModel.h	/^   Boolean allowTMods;     \/* true if HMMs can have Tee Models *\/$/;"	m	struct:_HMMSet
allowXWrdExp	HTKLib/HNet.c	/^Boolean allowXWrdExp=FALSE;$/;"	v
alpha	HTKLib/HArc.h	/^  double alpha; \/*alpha and betaPlus are for user's use.  *\/$/;"	m	struct:_Arc
alpha	HTKLib/HArc.h	/^  double alpha;$/;"	m	struct:_CorrN
alpha	HTKLib/HRNLM.h	/^    real alpha;$/;"	m	struct:_RNNLM
alpha	HTKTools/HRest.c	/^static DMatrix alpha;      \/* array[1..nStates][1..maxT] of forward prob *\/$/;"	v	file:
alphaBetaStack	HTKTools/HRest.c	/^static MemHeap alphaBetaStack;   \/* For storage of alpha and beta probs *\/$/;"	v	file:
alphaCorr	HTKLib/HArc.h	/^  float *alphaCorr; \/* [starti..endi]. *\/$/;"	m	struct:_CorrN
alphaError	HTKLib/HArc.h	/^  float alphaError, betaPlusError; \/*for MPE training.*\/$/;"	m	struct:_MPEStruct
alpha_divide	HTKLib/HRNLM.h	/^    int alpha_divide;$/;"	m	struct:_RNNLM
alpha_set	HTKLib/HRNLM.h	/^    int alpha_set, train_file_set;$/;"	m	struct:_RNNLM
alphat	HTKLib/HArc.h	/^  DVector alphat; \/* 1..Nq *\/$/;"	m	struct:_Acoustic
alphat	HTKLib/HFB.h	/^  DVector *alphat;    \/* array[1..Q][1..Nq] of prob *\/$/;"	m	struct:__anon138
alphat1	HTKLib/HArc.h	/^  DVector alphat1; \/* 1..Nq  [for time t-1] *\/$/;"	m	struct:_Acoustic
alphat1	HTKLib/HFB.h	/^  DVector *alphat1;   \/* alpha[t-1] *\/$/;"	m	struct:__anon138
alreadyFilling	HTKLib/HAudio.c	/^static volatile Boolean alreadyFilling;$/;"	v	file:
alt	HLMLib/LGBase.h	/^   GFLink alt;             \/* ... alt files to open *\/$/;"	m	struct:gramfile
anlen	HTKLib/HRec.c	/^   int anlen;               \/* Number of AlignNoRef list *\/$/;"	m	struct:precinfo	file:
ans	HTKTools/HHEd.c	/^   Boolean ans;                 \/* TRUE = yes, FALSE = no *\/$/;"	m	struct:_Node	file:
ans	HTKTools/HHEd.c	/^   Boolean ans;                 \/* answer to current question *\/$/;"	m	struct:_CRec	file:
ans	HTKTools/HResults.c	/^static Transcription *ans;            \/* the full set of answers *\/$/;"	v	file:
ansHeap	HTKTools/HVite.c	/^static MemHeap ansHeap;$/;"	v	file:
anti_k	HTKLib/HRNLM.h	/^    int anti_k;$/;"	m	struct:_RNNLM
applyVFloor	HTKTools/HHEd.c	/^static Boolean applyVFloor = TRUE; \/* apply modfied varFloors to vars in model set *\/ $/;"	v	file:
arcStack	HTKLib/HFBLat.h	/^  MemHeap arcStack;$/;"	m	struct:__anon54
arc_compare	HTKLib/HArc.c	/^int arc_compare( const void* a , const void* b )$/;"	f
arc_vc_id	HTKLib/HArc.c	/^char *arc_vc_id = "$Id: HArc.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
arc_version	HTKLib/HArc.c	/^char *arc_version = "!HVER!HArc:   3.4.1 [CUED 12\/03\/09]";$/;"	v
argcount	HTKLib/HShell.c	/^static int argcount;          \/* total args = argc *\/$/;"	v	file:
arglist	HTKLib/HShell.c	/^static char **arglist=defargs;\/* actual arg list *\/$/;"	v	file:
args	HTKTools/HDMan.c	/^   LabId args[MAXARGS];$/;"	m	struct:__anon159	file:
args	HTKTools/HLEd.c	/^   LabId args[MAXARGS];$/;"	m	struct:__anon142	file:
as	HTKLib/HParm.c	/^   Vector as, ac, lp; \/* Auditory, autocorrelation an lp vectors for PLP *\/ $/;"	m	struct:__anon76	file:
as_func_failure	configure	/^as_func_failure () {$/;"	f
as_func_ret_failure	configure	/^as_func_ret_failure () {$/;"	f
as_func_ret_success	configure	/^as_func_ret_success () {$/;"	f
as_func_success	configure	/^as_func_success () {$/;"	f
assign	HTKLib/HModel.h	/^   IntVec assign;        \/* for hard assignments  *\/$/;"	m	union:__anon67
asterix	HTKTools/HDMan.c	/^static LabId asterix;                \/* LabId of a "*" *\/$/;"	v	file:
asterix	HTKTools/HLEd.c	/^static LabId asterix;               \/* id of an asterix *\/$/;"	v	file:
attMInfo	HTKLib/HModel.h	/^   Boolean attMInfo;     \/* have the set of adapt info been attached *\/$/;"	m	struct:_HMMSet
attRegAccs	HTKLib/HModel.h	/^   Boolean attRegAccs;   \/* have the set of accumulates been attached *\/$/;"	m	struct:_HMMSet
attXFormInfo	HTKLib/HModel.h	/^   Boolean attXFormInfo; \/* have the set of adapt info been attached *\/$/;"	m	struct:_HMMSet
attr	HTKLib/HAudio.c	/^   AudioAttributes attr;$/;"	m	struct:_AudioIn	file:
attr	HTKLib/HAudio.c	/^   AudioAttributes attr;$/;"	m	struct:_AudioOut	file:
audSignal	HTKLib/HParm.c	/^   int audSignal;             \/* Signal Number for Audio Control *\/$/;"	m	struct:__anon76	file:
audSignal	HTKLib/HParm.h	/^   int audSignal;             \/* Signal Number for Audio Control *\/$/;"	m	struct:__anon122
audSignal	HTKTools/HList.c	/^static int audSignal;$/;"	v	file:
audStack	HTKTools/HSLab.c	/^static MemHeap audStack;$/;"	v	file:
audio	HTKLib/HAudio.c	/^   Audio *audio;$/;"	m	struct:_AudioIn	file:
audio	HTKLib/HAudio.c	/^   Audio *audio;$/;"	m	struct:_AudioOut	file:
audio_cnt	HTKLib/HAudio.c	/^static int audio_cnt=0;$/;"	v	file:
audio_ctld	HTKLib/HAudio.c	/^   int audio_ctld;$/;"	m	struct:_AudioIn	file:
audio_ctld	HTKLib/HAudio.c	/^   int audio_ctld;$/;"	m	struct:_AudioOut	file:
audio_dev	HTKLib/HAudio.c	/^static Audio *audio_dev=NULL;$/;"	v	file:
audio_fd	HTKLib/HAudio.c	/^static int audio_fd;$/;"	v	file:
audio_info	HTKLib/HAudio.c	/^   audio_info_t audio_info;$/;"	m	struct:_AudioIn	file:
audio_info	HTKLib/HAudio.c	/^   audio_info_t audio_info;$/;"	m	struct:_AudioOut	file:
audio_info	HTKLib/HAudio.c	/^static audio_buf_info audio_info;$/;"	v	file:
audio_io	HTKLib/HAudio.c	/^static unsigned short audio_io = 0x00;$/;"	v	file:
aux	HLMLib/LUtil.h	/^   int aux;                    \/* User flags etc*\/$/;"	m	struct:_NameHolder
aux	HLMLib/LWMap.h	/^   }aux;$/;"	m	struct:MAPENTRY	typeref:union:MAPENTRY::__anon18
aux	HTKLib/HDict.h	/^   void *aux;       \/* hook used by HTK library modules for temp info *\/$/;"	m	struct:_DictEntry
aux	HTKLib/HDict.h	/^   void *aux;      \/* hook for temp info *\/$/;"	m	struct:_WordPron
aux	HTKLib/HLabel.h	/^   Ptr aux;                 \/* User pointer *\/$/;"	m	struct:_NameCell
aux	HTKLib/HNet.h	/^   int aux;$/;"	m	struct:_NetNode
aux	HTKLib/HVQ.h	/^   void * aux;          \/* available to 'user' *\/$/;"	m	struct:_VQNodeRec
auxLab	HTKLib/HLabel.h	/^   LabId *auxLab;           \/* array [1..maxAuxLab] OF LabId *\/$/;"	m	struct:_Label
auxLab	HTKTools/HCopy.c	/^static int auxLab = 0;          \/* auxiliary label to use (0==primary) *\/$/;"	v	file:
auxScore	HTKLib/HLabel.h	/^   float *auxScore;         \/* array [1..maxAuxLab] OF float *\/$/;"	m	struct:_Label
auxflt	HLMLib/LWMap.h	/^      float auxflt;$/;"	m	union:MAPENTRY::__anon18
auxint	HLMLib/LWMap.h	/^      int  auxint;$/;"	m	union:MAPENTRY::__anon18
auxptr	HLMLib/LWMap.h	/^      Ptr auxptr;$/;"	m	union:MAPENTRY::__anon18
avCov	HTKLib/HAdapt.c	/^static TriMat *avCov = NULL;$/;"	v	file:
aveCost	HTKLib/HTrain.h	/^   float aveCost;  \/* average cost of cluster *\/$/;"	m	struct:__anon109
aveCovar	HTKTools/HHEd.c	/^   Vector aveCovar;          \/* node cluster variance *\/$/;"	m	struct:__anon167	file:
aveMean	HTKTools/HHEd.c	/^   Vector aveMean;           \/* node cluster mean *\/$/;"	m	struct:__anon167	file:
axis_names	HTKLib/esignal.h	/^    char        **axis_names;   \/* optional strings identifying axes *\/$/;"	m	struct:FieldSpec
aylen	HTKLib/HRec.c	/^   int aylen;               \/* Number of AlignYesRef list *\/$/;"	m	struct:precinfo	file:
b	HTKLib/HShell.h	/^   Boolean b;$/;"	m	union:__anon86
bCoef	HLMLib/LModel.h	/^   double bCoef;            \/* absolute discounting b coef *\/$/;"	m	union:__anon12
bDiagMat	HTKLib/HAdapt.c	/^   TriMat *bDiagMat;$/;"	m	struct:__anon94	file:
bEndId	HTKTools/HBuild.c	/^static LabId bEndId=NULL;           \/* id of end bracket *\/$/;"	v	file:
bStartId	HTKTools/HBuild.c	/^static LabId bStartId=NULL;         \/* id of start bracket *\/$/;"	v	file:
bSwap	HTKLib/HParm.c	/^   Boolean bSwap;     \/* TRUE if source needs byte swapping *\/$/;"	m	struct:__anon76	file:
bTriMat	HTKLib/HAdapt.c	/^   TriMat  *bTriMat;$/;"	m	struct:_AccCache	file:
bTriMat	HTKLib/HAdapt.c	/^   TriMat *bTriMat;$/;"	m	struct:__anon94	file:
bVector	HTKLib/HAdapt.c	/^   DVector bVector;$/;"	m	struct:_AccCache	file:
bVector	HTKLib/HAdapt.c	/^   DVector bVector;$/;"	m	struct:__anon94	file:
backward	HLMTools/Cluster.c	/^static bigrams     *forward=0, *backward;    \/* Forward and backward bigram tables *\/$/;"	v	file:
backward	HLMTools/Cluster.c	/^static bigrams    *forward, *backward;      \/* Forward and backward bigram tables *\/$/;"	v	file:
badGC	HTKTools/HHEd.c	/^static Boolean badGC = FALSE;          \/* set TRUE if gConst out of date *\/$/;"	v	file:
barc	HTKTools/HList.c	/^static char barc = '-';          \/* bar character *\/$/;"	v	file:
barwidth	HTKTools/HList.c	/^static int barwidth;             \/* width of printed bars *\/$/;"	v	file:
baseClass	HTKLib/HAdapt.c	/^   int baseClass;$/;"	m	struct:_AInfo	file:
baseClasses	HTKLib/HModel.h	/^  IntVec baseClasses;       \/* if a terminal node the set of baseclasses else NULL *\/$/;"	m	struct:_RegNode
baseId	HTKTools/HHEd.c	/^   LabId baseId;                \/* base phone name *\/$/;"	m	struct:_Tree	file:
baseLeft	HTKTools/HHEd.c	/^typedef enum { baseNorm=0, baseLeft, baseRight, baseMono } baseType;$/;"	e	enum:__anon165	file:
baseMono	HTKTools/HHEd.c	/^typedef enum { baseNorm=0, baseLeft, baseRight, baseMono } baseType;$/;"	e	enum:__anon165	file:
baseNorm	HTKTools/HHEd.c	/^typedef enum { baseNorm=0, baseLeft, baseRight, baseMono } baseType;$/;"	e	enum:__anon165	file:
baseRight	HTKTools/HHEd.c	/^typedef enum { baseNorm=0, baseLeft, baseRight, baseMono } baseType;$/;"	e	enum:__anon165	file:
baseTriMatTime	HTKLib/HAdapt.c	/^static int baseTriMatTime=-1;  $/;"	v	file:
baseType	HTKTools/HHEd.c	/^typedef enum { baseNorm=0, baseLeft, baseRight, baseMono } baseType;$/;"	t	typeref:enum:__anon165	file:
baseclass	HTKLib/HAdapt.c	/^   int     baseclass;$/;"	m	struct:_AccCache	file:
bclass	HTKLib/HModel.h	/^  BaseClass *bclass;                \/* base class for which transform applicable *\/$/;"	m	struct:_AdaptXForm
bclass	HTKLib/HModel.h	/^  BaseClass *bclass;   \/* baseclass associated with this regression tree *\/$/;"	m	struct:RegTree
beamPruneArcs	HTKLib/HLat.c	/^static Boolean beamPruneArcs = TRUE; \/* apply beam pruning to arcs (rather than just nodes) *\/$/;"	v	file:
beta	HTKLib/HArc.h	/^  double *beta; \/* [starti..endi]. *\/$/;"	m	struct:_CorrN
beta	HTKLib/HFB.h	/^  DVector **beta;     \/* array[1..T][1..Q][1..Nq] of prob *\/$/;"	m	struct:__anon138
beta	HTKLib/HRNLM.h	/^    real beta;$/;"	m	struct:_RNNLM
beta	HTKTools/HRest.c	/^static DMatrix beta;       \/* array[1..nStates][1..maxT] of backward prob *\/$/;"	v	file:
betaCorr	HTKLib/HArc.h	/^  float *betaCorr; \/* [starti..endi]. *\/$/;"	m	struct:_CorrN
betaPlus	HTKLib/HArc.h	/^  DVector *betaPlus;  \/* [myArc->t_start..myArc->t_end][1..Nq] *\/$/;"	m	struct:_Acoustic
betaPlus	HTKLib/HArc.h	/^  double betaPlus;$/;"	m	struct:_Arc
betaPlusError	HTKLib/HArc.h	/^  float alphaError, betaPlusError; \/*for MPE training.*\/$/;"	m	struct:_MPEStruct
bg	HTKLib/HGraf.h	/^   HColour fg, bg;            \/* colors *\/$/;"	m	struct:_HButton
bg	HTKTools/HSLab.c	/^   HColour fg, bg;$/;"	m	struct:__anon148	file:
bi	HLMTools/Cluster.c	/^   bi_count *bi;   \/* Array of counts *\/$/;"	m	struct:__anon31	file:
bi_count	HLMTools/Cluster.c	/^bi_count;$/;"	t	typeref:struct:__anon30	file:
bias	HTKLib/HModel.h	/^  SVector bias;        \/* bias vector, if no bias equals NULL *\/$/;"	m	struct:__anon68
bias2	HTKLib/HNLM.h	/^    float *bias2;$/;"	m	struct:mlpweightfile
bias3	HTKLib/HNLM.h	/^    float *bias3;$/;"	m	struct:mlpweightfile
bias4	HTKLib/HNLM.h	/^    float *bias4;$/;"	m	struct:mlpweightfile
bias5	HTKLib/HNLM.h	/^    float *bias5;$/;"	m	struct:mlpweightfile
bigFile	HTKTools/HLStats.c	/^static char *bigFile    = NULL;     \/* file for bigram *\/$/;"	v	file:
bigFloor	HTKTools/HLStats.c	/^static float bigFloor   = 0.0;      \/* floor for matrix bigram probs *\/$/;"	v	file:
bigMat	HTKLib/HLM.h	/^   Matrix bigMat;               \/* Actual probs *\/$/;"	m	struct:matbilm
bigThresh	HTKTools/HLStats.c	/^static int bigThresh    = 0;        \/* threshold for including bigram probs *\/$/;"	v	file:
bigram_add	HLMTools/Cluster.c	/^void bigram_add(NGram ng, int count)$/;"	f
bigram_added_all	HLMTools/Cluster.c	/^void bigram_added_all(void)$/;"	f
bigram_buffer_grow	HLMTools/Cluster.c	75;"	d	file:
bigram_init	HLMTools/Cluster.c	/^void bigram_init(int words) \/* Pass ->used field from word-map *\/$/;"	f
bigrams	HLMTools/Cluster.c	/^bigrams;$/;"	t	typeref:struct:__anon31	file:
binForm	HTKLib/HModel.c	/^   Boolean binForm;     \/* binary form of keyword symbol *\/$/;"	m	struct:__anon42	file:
binMap	HLMLib/LModel.h	/^   NameId  *binMap;          \/* NameId array for decoding binary LMs *\/$/;"	m	struct:__anon16
binTree	HTKLib/HVQ.h	/^   binTree     \/* binary tree - every node has 0 or 2 offspring *\/$/;"	e	enum:__anon35
bindir	HTKLib/Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bindir	HTKTools/Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
binfo	HLMTools/LAdapt.c	/^static BuildInfo  binfo;             \/* build parameters *\/$/;"	v	file:
binfo	HLMTools/LBuild.c	/^static BuildInfo  binfo;$/;"	v	file:
binformat	HTKLib/HRNLM.h	/^    Boolean binformat;$/;"	m	struct:_RNNLM
binsearch	HTKLib/HNLM.c	/^static int binsearch(char *str[], int max, char *value) {$/;"	f	file:
bipair	HLMTools/Cluster.c	/^static int        *bipair;                  \/* Array of word bigrams (w,w) *\/$/;"	v	file:
bitValue	HTKLib/HWave.c	/^static const unsigned char bitValue[8] = {1,2,4,8,16,32,64,128};$/;"	v	file:
bits	HTKLib/HAudio.c	/^   long bits ;$/;"	m	struct:_AudioIn	file:
bits	HTKLib/HAudio.c	/^   long bits ;$/;"	m	struct:_AudioOut	file:
bk	HTKLib/HParm.h	/^   ParmKind bk;          \/* parm kind of the parm buffer *\/$/;"	m	struct:__anon120
bkind	HTKLib/HModel.h	/^  BaseClassKind bkind; \/* type of parameters applicable to *\/$/;"	m	struct:__anon65
black	HTKLib/HGraf.c	/^static unsigned long black, white;$/;"	v	file:
blkSize	HTKLib/HTrain.h	/^   int blkSize;      \/* size of an item block *\/$/;"	m	struct:__anon108
block	HLMTools/Cluster.c	/^static void        *block=0;                \/* First word of free memory we have *\/$/;"	v	file:
blockSize	HTKLib/HAdapt.c	/^   IntVec blockSize;$/;"	m	struct:__anon92	file:
blockSize	HTKLib/HModel.h	/^  IntVec blockSize;    \/* block sizes in the linear transform *\/$/;"	m	struct:__anon68
block_cut_off	HLMTools/Cluster.c	70;"	d	file:
block_end	HLMTools/Cluster.c	/^static void        *block_end=0;            \/* First byte after current block *\/$/;"	v	file:
block_grab_size	HLMTools/Cluster.c	67;"	d	file:
bndId	HTKTools/HVite.c	/^static LabId bndId = NULL;        \/* Boundary word for alignment *\/$/;"	v	file:
boBiGram	HTKTools/HBuild.c	/^typedef enum {unknown, wordLoop, boBiGram, matBiGram, multiLat, wordPair} BuildType;$/;"	e	enum:__anon163	file:
boInfo	HLMLib/LModel.h	/^   BackOffInfo *boInfo;     \/* discounting type *\/$/;"	m	struct:__anon14
boNGram	HTKLib/HLM.h	/^typedef enum { boNGram=1, matBigram, mlpLM, intpltLM, rnnLM, hlmModel } LMType;$/;"	e	enum:__anon123
bobcaStack	HTKLib/HAdapt.c	/^static MemHeap bobcaStack; \/* base obscache *\/$/;"	v	file:
bowt	HLMLib/LModel.h	/^   float bowt;              \/* LOG10 backoff weight *\/$/;"	m	struct:_FLEntry
bowt	HTKLib/HLM.h	/^   float bowt;                  \/* Back-off weight *\/$/;"	m	struct:nentry
bptt	HTKLib/HRNLM.h	/^    int bptt;$/;"	m	struct:_RNNLM
bptt_block	HTKLib/HRNLM.h	/^    int bptt_block;$/;"	m	struct:_RNNLM
bptt_hidden	HTKLib/HRNLM.h	/^    struct neuron *bptt_hidden;$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::neuron
bptt_history	HTKLib/HRNLM.h	/^    int *bptt_history;$/;"	m	struct:_RNNLM
bptt_syn0	HTKLib/HRNLM.h	/^    struct synapse *bptt_syn0;$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::synapse
btnHeap	HTKLib/HGraf.c	/^static MemHeap btnHeap;      \/* heap for HButton structures *\/$/;"	v	file:
btnHeap	HTKLib/HGraf_WIN32.c	/^static MemHeap btnHeap;           \/* heap for HButton structures *\/$/;"	v	file:
btnList	HTKTools/HSLab.c	/^static HButton *btnList;     \/* the list of buttons displayed on the HSLab window *\/$/;"	v	file:
btn_h	HTKTools/HSLab.c	/^static int btn_h;            \/* calculated button height *\/$/;"	v	file:
btn_h_spc	HTKTools/HSLab.c	/^static int btn_h_spc;        \/* calculated button horizontal spacing *\/$/;"	v	file:
btn_v_spc	HTKTools/HSLab.c	/^static int btn_v_spc;        \/* calculated button vertical spacing *\/$/;"	v	file:
btn_w	HTKTools/HSLab.c	/^static int btn_w;            \/* calculated button width *\/$/;"	v	file:
buf	HLMLib/LGBase.h	/^   Byte buf[GSIZE];         \/* next compressed N-gram to read *\/$/;"	m	struct:__anon4
buf1	HTKLib/HFBLat.c	/^static  char buf1[255];$/;"	v	file:
bufHeap	HTKTools/HVite.c	/^static MemHeap bufHeap;$/;"	v	file:
bufSize	HTKLib/HAudio.c	/^   int bufSize;             \/* Block size for each buffer *\/$/;"	m	struct:_AudioIn	file:
buffer	HTKLib/HAudio.c	/^   short buffer[AUDBUFSIZE];$/;"	m	struct:_AudioIn	file:
bufferSize	HTKLib/HAudio.c	/^   int bufferSize;           \/* Size of audio buffer *\/$/;"	m	struct:_AudioIn	file:
bufferStack	HTKTools/HInit.c	/^static MemHeap bufferStack;      \/* For storage of buffer *\/$/;"	v	file:
bufferStack	HTKTools/HRest.c	/^static MemHeap bufferStack;      \/* For storage of buffer *\/$/;"	v	file:
buildStack	HTKTools/HBuild.c	/^MemHeap buildStack;$/;"	v
bw	HTKTools/HSLab.c	/^   int x, y, w, h, bw;    \/* x-pos, y-pos, width, height, fg and bg colours *\/$/;"	m	struct:__anon148	file:
bwlike	HTKLib/HLat.h	/^   LogDouble bwlike;     \/* backward likelihood *\/$/;"	m	struct:FBlnodeInfo
c	HTKLib/HAudio.c	/^   CRITICAL_SECTION c;$/;"	m	struct:_AudioIn	file:
c	HTKLib/HAudio.c	/^   CRITICAL_SECTION c;$/;"	m	struct:_AudioOut	file:
c	HTKLib/HGraf.h	/^   unsigned char c;  \/* keypress char *\/$/;"	m	struct:__anon96
c	HTKLib/HParm.c	/^   Vector c;          \/* cepstral vector *\/$/;"	m	struct:__anon76	file:
c	HTKLib/HRNLM.h	/^    float *r, *z, *c, *h_;$/;"	m	struct:_Layer
c	HTKLib/HTrain.h	/^   Vector c;         \/* array[1..M] of mixture weight *\/$/;"	m	struct:__anon112
c	HTKTools/HSmooth.c	/^   Vector c;         \/* array[1..M] of mixture weight *\/$/;"	m	struct:_ChWtAcc	file:
cCount	HTKLib/HWave.c	/^static int cCount;   \/* num bytes read *\/$/;"	v	file:
cMeanDN	HTKLib/HParm.c	/^   char* cMeanDN;             \/* dir to find cepstral mean files *\/$/;"	m	struct:__anon76	file:
cMeanMask	HTKLib/HParm.c	/^   char* cMeanMask;           \/* cepstral mean selection mask *\/$/;"	m	struct:__anon76	file:
cMeanPathMask	HTKLib/HParm.c	/^   char* cMeanPathMask;       \/* cepstral mean path selection mask *\/$/;"	m	struct:__anon76	file:
cMeanVector	HTKLib/HParm.c	/^   Vector cMeanVector;   \/* vector loaded from cmean dir *\/$/;"	m	struct:__anon76	file:
cNIST	HTKLib/HWave.c	/^static int cNIST;    \/* current input char *\/$/;"	v	file:
cPOutP	HTKLib/HRec.c	/^static LogFloat cPOutP(PSetInfo *psi,Observation *obs,StateInfo *si,int id)$/;"	f	file:
cParm	HLMLib/LCMap.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HLMLib/LGBase.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HLMLib/LModel.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HLMLib/LPCalc.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMLib/LPMerge.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMLib/LUtil.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HLMLib/LWMap.c	/^static ConfParam *cParm[MAXGLOBS];   \/* config parameters *\/$/;"	v	file:
cParm	HLMTools/Cluster.c	/^static ConfParam   *cParm[MAXGLOBS];        \/* configuration script parameters *\/$/;"	v	file:
cParm	HLMTools/HLMCopy.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LAdapt.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LBuild.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LFoF.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LGCopy.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LGList.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LGPrep.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LLink.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LMerge.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LNewMap.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LNorm.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LPlex.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LSubset.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKLib/HAdapt.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HArc.c	/^static ConfParam *cParm[MAXGLOBS];  \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HAudio.c	/^static ConfParam *cParm[MAXGLOBS];       \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HDict.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HExactMPE.c	/^static ConfParam *cParm[MAXGLOBS];  \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HFB.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HFBLat.c	/^static ConfParam *cParm[MAXGLOBS];  \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HGraf.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HGraf.null.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HGraf_WIN32.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HLM.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HLabel.c	/^static ConfParam *cParm[MAXGLOBS];        \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HLat.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HMap.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HMath.c	/^static ConfParam *cParm[MAXGLOBS];       \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HMem.c	/^static ConfParam *cParm[MAXGLOBS];       \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HModel.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HNLM.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKLib/HNet.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HParm.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HRNLM.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKLib/HRec.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HShell.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HSigP.c	/^static ConfParam *cParm[MAXGLOBS];       \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HTrain.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HUtil.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HVQ.c	/^static ConfParam *cParm[MAXGLOBS];       \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HWave.c	/^static ConfParam *cParm[MAXGLOBS];       \/* config parameters *\/$/;"	v	file:
cParm	HTKTools/HBuild.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HCompV.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HCopy.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HDMan.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HERest.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HHEd.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HInit.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HLEd.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HLRescore.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HLStats.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HList.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HMMIRest.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HParse.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HQuant.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HRest.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HResults.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HSGen.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HSLab.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HSmooth.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HVite.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cSOutP	HTKLib/HRec.c	/^static LogFloat cSOutP(HMMSet *hset, int s, Observation *x, StreamElem *se,$/;"	f	file:
cStack	HTKTools/HCopy.c	/^static MemHeap cStack;          \/* chop stack *\/$/;"	v	file:
cStack	HTKTools/HQuant.c	/^static MemHeap cStack;             \/* cluster stack *\/$/;"	v	file:
c_hw	HTKLib/HRNLM.h	/^    float *c_hw, *s, *sc;$/;"	m	struct:_Layer
cache	HTKLib/HLM.h	/^   Ptr *cache;                  \/* Full span N-gram cache model w.r.t. MLP vocab *\/$/;"	m	struct:mlplm
cache	HTKLib/HLM.h	/^   Ptr *cache;                  \/* Full span N-gram cache model w.r.t. RNN vocab *\/$/;"	m	struct:__anon124
cacheMixoccHeap	HTKLib/HFBLat.c	/^MemHeap cacheMixoccHeap;$/;"	v
calcArc	HTKLib/HArc.h	/^  HArc *calcArc; \/*An identical arc (in hmm, start, end), which we use for purposes of forward-backward alignment [only if id==0].*\/$/;"	m	struct:_Arc
calcProbCache	HTKLib/HRNLM.c	/^static Boolean calcProbCache = TRUE;$/;"	v	file:
calcStats	HTKTools/HLRescore.c	/^static Boolean calcStats = FALSE;   \/* -c *\/$/;"	v	file:
calgruop	HTKLib/HRNLM.c	/^void calgruop (float *h_ac, float *h_, float *z, int num)$/;"	f
calign	HTKLib/HRec.c	/^   int calign;              \/* Number of align records after last collection *\/$/;"	m	struct:precinfo	file:
callBackEvent	HTKLib/HAudio.c	/^   HANDLE callBackEvent;$/;"	m	struct:_AudioIn	file:
callBackEvent	HTKLib/HAudio.c	/^   HANDLE callBackEvent;$/;"	m	struct:_AudioOut	file:
callBackIn	HTKLib/HAudio.c	/^void CALLBACK callBackIn(HWAVE hwaveIn, UINT msg, DWORD magic, $/;"	f
callBackOut	HTKLib/HAudio.c	/^void CALLBACK callBackOut(HWAVE hwaveIn, UINT msg, $/;"	f
cbSizes	HTKTools/HQuant.c	/^static int cbSizes[SMAX];           \/* codebook sizes, per stream *\/$/;"	v	file:
ccs	HTKLib/HTrain.c	/^static ClusterSet *ccs; \/* current cluster set *\/$/;"	v	file:
cdef	HTKTools/HLEd.c	/^   LabId cdef[MAXARGS];$/;"	m	struct:_Context	file:
cepLifter	HTKLib/HParm.c	/^   int cepLifter;             \/* Cepstral liftering coef *\/$/;"	m	struct:__anon76	file:
cepScale	HTKLib/HParm.c	/^   float cepScale;            \/* Scaling factor to avoid arithmetic problems *\/$/;"	m	struct:__anon76	file:
cepWin	HTKLib/HSigP.c	/^static Vector cepWin = NULL;        \/* Current cepstral weight window *\/$/;"	v	file:
cepWinL	HTKLib/HSigP.c	/^static int cepWinL=0;               \/* Current liftering coeff *\/$/;"	v	file:
cepWinSize	HTKLib/HSigP.c	/^static int cepWinSize=0;            \/* Size of current cepstral weight window *\/$/;"	v	file:
cf	HTKLib/HParm.c	/^   IOConfig cf;        \/* configuration for this channel *\/$/;"	m	struct:_ParmBuf	file:
cf	HTKLib/HParm.c	/^   IOConfigRec cf;        \/* Channel configuration *\/$/;"	m	struct:channelinfo	file:
cf	HTKLib/HSigP.h	/^   Vector cf;           \/* array[1..pOrder+1] of centre freqs *\/$/;"	m	struct:__anon129
cfHSKind	HTKLib/HModel.c	/^static HSetKind cfHSKind;$/;"	v	file:
cfWordBoundary	HTKLib/HNet.c	/^Boolean cfWordBoundary=TRUE;$/;"	v
cfkmap	HTKLib/HShell.c	/^static char *cfkmap[] = { $/;"	v	file:
cfs	HTKLib/HNet.h	/^   LabId *cfs;     \/* Sorted array of context free labids *\/$/;"	m	struct:hmmsetcxtinfo
ch	HTKLib/HUtil.c	/^static int ch;                 \/* Current character from source *\/$/;"	v	file:
ch	HTKTools/HParse.c	/^static char ch;                     \/* Current character *\/$/;"	v	file:
chClear	HTKLib/HParm.c	/^   Boolean chClear;    \/* End of channel reached *\/$/;"	m	struct:_ParmBuf	file:
chOffset	HTKLib/HParm.c	/^   float chOffset;        \/* Average sample offset (-32768..32767) *\/$/;"	m	struct:channelinfo	file:
chPeak	HTKLib/HParm.c	/^   float chPeak;          \/* Scaled peak-to-peak range 0.0-1.0 *\/$/;"	m	struct:channelinfo	file:
chPeak	HTKLib/HParm.h	/^   float chPeak;              \/* Peak-to-peak input level for channel *\/$/;"	m	struct:__anon122
chType	HTKLib/HParm.c	/^   ChannelType chType; \/* type of input channel *\/$/;"	m	struct:_ParmBuf	file:
ch_ext_parm	HTKLib/HParm.c	/^   ch_ext_parm    \/* Externally defined parameterised source *\/$/;"	e	enum:channeltype	file:
ch_ext_wave	HTKLib/HParm.c	/^   ch_ext_wave,   \/* Externally defined waveform source *\/$/;"	e	enum:channeltype	file:
ch_haudio	HTKLib/HParm.c	/^   ch_haudio=4,   \/* The HAudio interface *\/$/;"	e	enum:channeltype	file:
ch_hparm	HTKLib/HParm.c	/^   ch_hparm,      \/* A parmeterised file *\/$/;"	e	enum:channeltype	file:
ch_hrfe	HTKLib/HParm.c	/^   ch_hrfe,       \/* The RFE is not yet reimplemented *\/$/;"	e	enum:channeltype	file:
ch_hwave	HTKLib/HParm.c	/^   ch_hwave,      \/* A waveform file *\/$/;"	e	enum:channeltype	file:
chain	HLMLib/LGBase.h	/^   GFLink chain;           \/* linked list of all files *\/$/;"	m	struct:gramfile
chain	HTKLib/HNet.c	/^   NetNode *chain;  \/* Chain of other nodes in word *\/$/;"	m	struct:pronholder	file:
chain	HTKLib/HNet.h	/^   NetNode *chain;$/;"	m	struct:_NetNode
chain	HTKLib/HNet.h	/^   NetNode *chain;$/;"	m	struct:__anon128
chain	HTKLib/HNet.h	/^   struct lattice *chain;       \/* Linked list used for various jobs *\/$/;"	m	struct:lattice	typeref:struct:lattice::lattice
chain	HTKLib/HNet.h	/^   struct sublatdef *chain; \/* Next sublat referring to lat *\/$/;"	m	struct:sublatdef	typeref:struct:sublatdef::sublatdef
chain	HTKLib/HRec.c	/^   NxtPath *chain;      \/* Next of NBest Paths *\/$/;"	m	struct:nxtpath	file:
chain	HTKLib/HRec.h	/^   NxtPath *chain;      \/* Next of NBest Paths *\/$/;"	m	struct:path
chain	HTKTools/HParse.c	/^   Link chain;       \/* simple linked list of all nodes *\/  $/;"	m	struct:_Node	file:
chain	HTKTools/HParse.c	/^   Link chain;$/;"	m	struct:__anon155	file:
chan	HTKLib/HParm.c	/^   ChannelInfo *chan;  \/* input channel for this buffer *\/$/;"	m	struct:_ParmBuf	file:
channelinfo	HTKLib/HParm.c	/^typedef struct channelinfo {$/;"	s	file:
channels	HTKLib/HAudio.c	/^   long channels ;$/;"	m	struct:_AudioIn	file:
channels	HTKLib/HAudio.c	/^   long channels ;$/;"	m	struct:_AudioOut	file:
channeltype	HTKLib/HParm.c	/^typedef enum channeltype {$/;"	g	file:
chcount	HTKLib/HShell.h	/^   int chcount;         \/* num chars from start *\/$/;"	m	struct:__anon84
checkOrder	HLMLib/LGBase.c	/^static Boolean checkOrder = FALSE;      \/* Check n-gram ordering *\/$/;"	v	file:
check_counts_sum	HLMTools/Cluster.c	/^void check_counts_sum(void)$/;"	f
check_file	HLMTools/Cluster.c	/^void check_file(FILE *file, char *fname, char *function)$/;"	f
check_file	HLMTools/LLink.c	/^FILE *check_file(FILE *file, char *fname)$/;"	f
checking	HTKLib/HModel.c	/^static Boolean checking   = TRUE;       \/* check HMM defs *\/$/;"	v	file:
child	HTKLib/HModel.h	/^  struct _RegNode **child;  \/* children of this node NULL if terminal *\/$/;"	m	struct:_RegNode	typeref:struct:_RegNode::_RegNode
choose_class	HLMTools/Cluster.c	/^static int choose_class(UInt w)$/;"	f	file:
chopF	HTKTools/HCopy.c	/^static Boolean chopF = FALSE;   \/* set if we should truncate files\/trans *\/$/;"	v	file:
ci	HLMLib/LUtil.c	/^const static int ci[28]={ 28,0,0,2,1,0,0,1,2,3,0,0,3,0,$/;"	v	file:
cis	HTKLib/HNet.h	/^   LabId *cis;     \/* Sorted array of context independent labids *\/$/;"	m	struct:hmmsetcxtinfo
ck	HTKLib/HTrain.h	/^   CovKind ck;     \/* type of covariance if any *\/$/;"	m	struct:__anon110
ck	HTKTools/HQuant.c	/^CovKind ck = NULLC;                \/* determines distance metric *\/$/;"	v
ckUsage	HTKLib/HModel.h	/^   int ckUsage[NUMCKIND];  \/* Number of components using given ckind *\/$/;"	m	struct:_HMMSet
ckind	HTKLib/HModel.h	/^   CovKind ckind;          \/* cov kind - only global in V1.X *\/$/;"	m	struct:_HMMSet
ckind	HTKLib/HModel.h	/^   CovKind ckind;       \/* kind of covariance *\/$/;"	m	struct:__anon56
ckind	HTKLib/HVQ.h	/^   CovKind ckind;       \/* kind of covariance used, if any*\/$/;"	m	struct:_VQTabRec
cl	HTKLib/HTrain.h	/^   Cluster *cl;    \/* array[1..numClust]of Cluster *\/$/;"	m	struct:__anon110
clCnt	HLMTools/Cluster.c	/^static int       **clCnt=NULL;              \/* Array of arrays; index with count[c1][c2]$/;"	v	file:
clEntry	HLMLib/LCMap.h	/^typedef struct clEntry { \/* class map entry *\/$/;"	s
clMemb	HLMTools/Cluster.c	/^static int	  *clMemb=NULL;             \/* Class membership [words]$/;"	v	file:
clSum	HLMTools/Cluster.c	/^static int        *clSum=NULL;              \/* Class unigram [classes]$/;"	v	file:
classBM	HLMLib/LModel.h	/^   NameId *classBM;          \/* Hash table (similar to binMap) *\/$/;"	m	struct:__anon16
classCounts	HLMLib/LModel.h	/^   Boolean classCounts;      \/* TRUE if LM file gives class counts not probs *\/$/;"	m	struct:__anon16
classH	HLMLib/LModel.h	/^   HashTab *classH;          \/* If a class-based LM then use this hash table *\/$/;"	m	struct:__anon16
classId	HLMTools/LPlex.c	/^   LabId classId;$/;"	m	struct:_Equiv	file:
classId	HTKTools/HResults.c	/^   LabId classId;$/;"	m	struct:_Equiv	file:
classLM	HLMLib/LModel.h	/^   Boolean classLM;          \/* TRUE if a class-based LM (toggle on backoff) *\/$/;"	m	struct:__anon16
classW	HLMLib/LModel.h	/^   int classW;               \/* Number of words *\/$/;"	m	struct:__anon16
class_cn	HTKLib/HRNLM.h	/^    int *class_cn;      \/* class_cn[0...class_size-1]; class_cn[i] records #words in i-th class *\/$/;"	m	struct:_RNNLM
class_index	HTKLib/HRNLM.h	/^    int class_index;$/;"	m	struct:vocab_word
class_max_cn	HTKLib/HRNLM.h	/^    int *class_max_cn;$/;"	m	struct:_RNNLM
class_size	HTKLib/HRNLM.h	/^    int class_size;$/;"	m	struct:_RNNLM
class_sort	HLMTools/Cluster.c	/^static UInt        *class_sort;	            \/* Used to sort output alphabetically *\/$/;"	v	file:
class_words	HTKLib/HRNLM.h	/^    int **class_words;  \/* class_words[0...class_size-1] ; class_words[i] holds the id-vector of words in i-th class  *\/$/;"	m	struct:_RNNLM
classes_change	HLMTools/Cluster.c	/^static void classes_change(UInt w, int g)$/;"	f	file:
classes_get_default	HLMTools/Cluster.c	/^int classes_get_default(void)$/;"	f
classes_init	HLMTools/Cluster.c	/^void classes_init(int numb_words)$/;"	f
classes_keep_unk_separate	HLMTools/Cluster.c	/^void classes_keep_unk_separate(int keep_separate)$/;"	f
classes_set_number	HLMTools/Cluster.c	/^void classes_set_number(int numb)$/;"	f
classes_showMLV	HLMTools/Cluster.c	/^void classes_showMLV(int on)$/;"	f
classinfo	HTKLib/HRNLM.h	/^    int *layersizes, *classinfo, *word2class;$/;"	m	struct:_RNNLM
clen	HTKLib/HNet.c	/^   int clen;        \/* Number of non-cf phones in pronunciation *\/$/;"	m	struct:pronholder	file:
clist	HTKTools/HHEd.c	/^   CLink clist;                 \/* list of cluster items *\/$/;"	m	struct:_Node	file:
clt	HLMLib/LWMap.h	/^   LookupTable *clt;     \/* class lookup table *\/$/;"	m	struct:__anon20
clustAcc	HTKTools/HHEd.c	/^   float  clustAcc;          \/* accumulates in this cluster *\/$/;"	m	struct:__anon167	file:
clustSetStack	HTKTools/HInit.c	/^static MemHeap clustSetStack;    \/* For storage of cluster sets *\/$/;"	v	file:
clusterScore	HTKTools/HHEd.c	/^   float  clusterScore;      \/* node cluster score *\/$/;"	m	struct:__anon167	file:
cluster_words	HLMTools/Cluster.c	/^void cluster_words(int iterations)$/;"	f
cm	HTKLib/HParm.c	/^   DMatrix cm;        \/* Cosine matrix for IDFT *\/ $/;"	m	struct:__anon76	file:
cmDir	HTKTools/HCompV.c	/^static char cmDir[MAXSTRLEN];            \/* directory to export CMV *\/$/;"	v	file:
cmap	HLMTools/LGCopy.c	/^static ClassMap   cmap;             \/* word list for OOV mapping *\/$/;"	v	file:
cmap	HLMTools/LSubset.c	/^static ClassMap cmap;            \/* class map *\/$/;"	v	file:
cmap	HTKLib/HTrain.c	/^static ShortVec cmap;   \/* array[1..cvp->nItems]of cluster index *\/$/;"	v	file:
cmapFN	HLMTools/LGCopy.c	/^static char *cmapFN  = NULL;        \/* word list file name *\/$/;"	v	file:
cmd	HTKTools/HDMan.c	/^   EditCmd cmd;$/;"	m	struct:_ScriptItem	file:
cmd	HTKTools/HLEd.c	/^   EditCmd cmd;$/;"	m	struct:_ScriptItem	file:
cmdMap	HTKTools/HDMan.c	/^static char *cmdMap[] = { "UW","UP","LW","LP","DW","DD","FW","DC",$/;"	v	file:
cmdNum	HTKTools/HHEd.c	/^cmdNum;$/;"	t	typeref:enum:__anon168	file:
cmdTrace	HTKTools/HHEd.c	/^static int  cmdTrace    = 0;     \/* trace level from command line *\/$/;"	v	file:
cmdmap	HTKTools/HHEd.c	/^static char *cmdmap[] = {"AT","RT","SS","CL","CO","JO","MU","TI","UF","NC",$/;"	v	file:
cmdmap	HTKTools/HLEd.c	/^static char *cmdmap[] = {"","RE","CH","FI","ME","DE","DC","IT",$/;"	v	file:
cmllrAdaptKind	HTKLib/HAdapt.c	/^static AdaptKind cmllrAdaptKind = BASE;$/;"	v	file:
cmllrBaseClass	HTKLib/HAdapt.c	/^static char *cmllrBaseClass = NULL;$/;"	v	file:
cmllrBlockSize	HTKLib/HAdapt.c	/^static IntVec cmllrBlockSize = NULL;$/;"	v	file:
cmllrRegTree	HTKLib/HAdapt.c	/^static char *cmllrRegTree = NULL;$/;"	v	file:
cmllrSplitThresh	HTKLib/HAdapt.c	/^static float cmllrSplitThresh = 1000.0;$/;"	v	file:
cmpMix	HTKTools/HHEd.c	/^static int cmpMix(const void *v1,const void *v2)$/;"	f	file:
cmuId	HTKTools/HDMan.c	/^static LabId cmuId;                  \/* "cmu" *\/$/;"	v	file:
cn	HTKLib/HArc.h	/^  CorrN *cn; \/* if doing dynamic MPE. *\/$/;"	m	struct:_MPEStruct
cn	HTKLib/HRNLM.h	/^    int cn;$/;"	m	struct:vocab_word
cname	HTKTools/HLEd.c	/^   LabId cname;$/;"	m	struct:_Context	file:
cntr	HTKTools/HLStats.c	/^typedef struct cntr{             \/* Physical Label Occurrence Counters *\/$/;"	s	file:
coef	HLMLib/LModel.h	/^   float *coef;             \/* discounting coefs *\/$/;"	m	struct:__anon11
colours	HTKLib/HGraf.c	/^static int colours[MAX_COLOURS];$/;"	v	file:
colours	HTKLib/HGraf_WIN32.c	/^static unsigned char colours[MAX_COLOURS][3];    \/* r,g,b *\/$/;"	v	file:
cols	HTKLib/HNLM.h	/^    int cols;            \/* Number of columns.*\/$/;"	m	struct:matinfo
command_map	HTKTools/HSLab.c	/^static char *command_map[] = {$/;"	v	file:
commentChars	HTKTools/HDMan.c	/^static char commentChars[10] = "#";  \/* default dictionary comment char *\/$/;"	v	file:
compatMode	HTKLib/HLabel.c	/^static Boolean compatMode = FALSE;  \/* Allow spaces around . or \/\/\/ *\/$/;"	v	file:
compressFact	HTKLib/HParm.c	/^   float compressFact;        \/* Compression factor for PLP *\/  $/;"	m	struct:__anon76	file:
compressMerge	HTKLib/HLat.c	/^static Boolean compressMerge = TRUE; \/* compressing lattice scores when merging duplicates *\/$/;"	v	file:
conDel	HTKTools/HResults.c	/^static ShortVec conDel,conIns; \/* corresponding deletion and insertion counts *\/$/;"	v	file:
conIns	HTKTools/HResults.c	/^static ShortVec conDel,conIns; \/* corresponding deletion and insertion counts *\/$/;"	v	file:
conMat	HTKTools/HResults.c	/^static ShortVec *conMat;  \/* confusion matrix, conMat[i][j] is the number of$/;"	v	file:
confList	HTKLib/HShell.c	/^static ConfigEntry *confList = NULL;$/;"	v	file:
confName	HTKLib/HParm.c	/^   char *confName;        \/* Configuration name associated with mean *\/$/;"	m	struct:channelinfo	file:
config	HTKBook/htkbook-pdf.tex	/^\\include{HTKRef\/LSubset}$/;"	i
config	HTKBook/htkbook.tex	/^\\include{HTKRef\/LSubset}$/;"	i
config	HTKLib/HAudio.c	/^   ALconfig config;          \/* configuration record *\/$/;"	m	struct:_AudioIn	file:
config	HTKLib/HAudio.c	/^   ALconfig config;          \/* configuration record *\/$/;"	m	struct:_AudioOut	file:
contexts	HTKTools/HDMan.c	/^   EditCmd contexts[MAXCONS];   \/* array of context defs *\/$/;"	m	struct:__anon162	file:
copyHiddenLayerToInput	HTKLib/HRNLM.c	/^void copyHiddenLayerToInput(RNNLM* rnnlm)$/;"	f
copy_vf_vf	HTKLib/HNLM.c	/^void copy_vf_vf(int vec_len, const float* vec, float* o_vec)$/;"	f
correctness	HTKLib/HArc.h	/^  float correctness;  \/* for inexact MPE. *\/$/;"	m	struct:_MPEStruct
count	HLMLib/LModel.c	/^   int count;           \/* count for access *\/$/;"	m	struct:_AccessInfo	file:
count	HLMLib/LWMap.h	/^   int count;              \/* word frequency count *\/$/;"	m	struct:MAPENTRY
count	HLMTools/Cluster.c	/^   int  count;	  \/* Bigram count *\/$/;"	m	struct:__anon30	file:
count	HLMTools/LPlex.c	/^   int count;$/;"	m	struct:__anon32	file:
count	HTKTools/HLStats.c	/^   int count;                    \/* Count *\/$/;"	m	struct:aentry	file:
count	HTKTools/HLStats.c	/^   int count;                    \/* Times seen *\/$/;"	m	struct:cntr	file:
count	HTKTools/HLStats.c	/^   int count;                    \/* Times seen *\/$/;"	m	struct:wordinfo	file:
counter	HTKLib/HRNLM.h	/^    int counter;$/;"	m	struct:_RNNLM
counts	HTKLib/HLM.h	/^   int counts[NSIZE+1];         \/* Number of [n]grams *\/$/;"	m	struct:ngramlm
cov	HTKLib/HAdapt.c	/^   Covariance cov;$/;"	m	struct:__anon93	file:
cov	HTKLib/HModel.h	/^   Covariance cov;      \/* covariance matrix or vector *\/$/;"	m	struct:__anon56
cov	HTKLib/HTrain.h	/^   Covariance cov;   \/* covariance counts *\/$/;"	m	struct:__anon114
cov	HTKLib/HTrain.h	/^   Covariance cov; \/* covariance of cluster *\/$/;"	m	struct:__anon109
cov	HTKLib/HVQ.h	/^   Covariance cov;      \/* null or inverse variance or covariance *\/$/;"	m	struct:_VQNodeRec
cov	HTKTools/HQuant.c	/^Covariance cov[SMAX];              \/* Global stream covariance  *\/$/;"	v
covarChanged	HTKLib/HAdapt.c	/^static Boolean covarChanged = FALSE;$/;"	v	file:
covarPChanged	HTKLib/HAdapt.c	/^static Boolean covarPChanged = FALSE;$/;"	v	file:
cpdf	HTKLib/HModel.h	/^   MixtureElem *cpdf;    \/* PLAINHS or SHAREDHS *\/$/;"	m	union:__anon58
cprob	HTKTools/HHEd.c	/^static float  cprob;            \/* complete likelihood at current node *\/$/;"	v	file:
cpth	HTKLib/HRec.c	/^   int cpth;                \/* Number of path records after last collection *\/$/;"	m	struct:precinfo	file:
crcc	HTKLib/HParm.c	/^   unsigned short crcc; \/* Running CRCC *\/$/;"	m	struct:__anon76	file:
crcc	HTKLib/HParm.c	/^   unsigned short crcc;\/* Put crcc here when we read it !! *\/$/;"	m	struct:_ParmBuf	file:
cs	HTKTools/HQuant.c	/^ClusterSet *cs[SMAX];              \/* stores vector clusters *\/$/;"	v
csize	HTKLib/HTrain.h	/^   int csize;      \/* num items in this cluster *\/$/;"	m	struct:__anon109
cuedversion	HTKLib/HRNLM.h	/^    real cuedversion, reluratio, lognormconst;$/;"	m	struct:_RNNLM
cur	HTKLib/HAudio.c	/^   int cur;               \/* Current sample index *\/$/;"	m	struct:mmapibuf	file:
curChain	HTKTools/HParse.c	/^static Link curChain;       \/* current network being built *\/$/;"	v	file:
curChan	HTKLib/HParm.c	/^static ChannelInfo *curChan=NULL;$/;"	v	file:
curElem	HTKLib/HMem.h	/^   size_t curElem;      \/*  current #elems per blk   curr #bytes per blk  *\/$/;"	m	struct:__anon73
curId	HTKTools/HParse.c	/^LabId curId;         \/* name of current variable def, if any *\/$/;"	v
curMeanVec	HTKLib/HParm.c	/^   Vector curMeanVec;     \/* Current mean *\/$/;"	m	struct:meanrec	file:
curNumCl	HTKLib/HTrain.c	/^static int curNumCl;    \/* num clust currently created *\/$/;"	v	file:
curPK	HTKLib/HParm.c	/^   ParmKind curPK;    \/* Used to track conversion from srcPK to tgtPK *\/$/;"	m	struct:__anon76	file:
curVol	HTKLib/HAudio.c	/^   float curVol;             \/* Current volume of input speech *\/$/;"	m	struct:_AudioIn	file:
curVol	HTKLib/HParm.c	/^   float curVol;      \/* current volume dB (0.0-100.0) *\/$/;"	m	struct:__anon76	file:
curVol	HTKLib/HParm.h	/^   float curVol;              \/* Volume level of last frame (0.0-100.0dB) *\/$/;"	m	struct:__anon122
curXForm	HTKLib/HModel.h	/^   AdaptXForm *curXForm;$/;"	m	struct:_HMMSet
curch	HTKLib/HLabel.c	/^static int curch = ' ';$/;"	v	file:
curenidx	HTKTools/HCopy.c	/^static int curenidx=0;          \/* label end index (if set) *\/$/;"	v	file:
curlen	HTKTools/HParse.c	/^static int curlen;                  \/* Current length of input line *\/$/;"	v	file:
curlmste	HTKLib/HLM.h	/^   NEntry *curlmste;            \/* current LM state - updated after prob. computation *\/$/;"	m	struct:__anon124
curpos	HTKTools/HParse.c	/^static int curpos;                  \/* Current position in input line *\/$/;"	v	file:
curr_MLV	HLMTools/Cluster.c	/^static double      curr_MLV=0;              \/* ...and its current value *\/$/;"	v	file:
curr_bistore_size	HLMTools/Cluster.c	/^static int          curr_bistore_size;      \/* Current size of bigram buffer store *\/$/;"	v	file:
curr_class	HLMTools/Cluster.c	/^static int         curr_class;              \/* Temporary value, saves passing *\/$/;"	v	file:
current	HTKLib/HAudio.c	/^   int current;             \/* Index of current buffer *\/$/;"	m	struct:_AudioIn	file:
current	HTKLib/HAudio.c	/^   int current;             \/* Index of current buffer *\/$/;"	m	struct:_AudioOut	file:
curstidx	HTKTools/HCopy.c	/^static int curstidx=0;          \/* label start index (if set) *\/$/;"	v	file:
cutOff	HLMLib/LModel.h	/^   int cutOff;              \/* cut-off *\/$/;"	m	struct:__anon13
cutOff	HLMLib/LPCalc.h	/^   int          cutOff[LM_NSIZE+1];   \/* n-gram cut-off array *\/$/;"	m	struct:__anon2
cutOff	HLMTools/HLMCopy.c	/^static int       cutOff[LM_NSIZE+1];     \/* new cutoffs *\/$/;"	v	file:
cutOff	HLMTools/LNorm.c	/^static int       cutOff[LM_NSIZE+1];     \/* new cutoff's *\/$/;"	v	file:
cutOff	HLMTools/LPlex.c	/^static int cutOff[LM_NSIZE+1];      \/* new cutoffs for COUNT-models *\/$/;"	v	file:
cvp	HTKLib/HTrain.c	/^static Sequence cvp;    \/* current vector pool being clustered *\/$/;"	v	file:
cxs	HTKLib/HNet.h	/^   LabId *cxs;     \/* Sorted array of labids indexed by context *\/$/;"	m	struct:hmmsetcxtinfo
d	HTKLib/HRNLM.c	/^    double d;$/;"	m	union:__anon130	file:
d2i	HTKLib/HRNLM.c	/^} d2i;$/;"	v	typeref:union:__anon130	file:
dList	HLMTools/HLMCopy.c	/^static dictList  *dList = NULL;          \/* list of dictionaries *\/$/;"	v	file:
dSeq	HTKTools/HQuant.c	/^Sequence dSeq[SMAX];               \/* main data pools; one per stream *\/$/;"	v
dShort	HTKLib/HParm.c	/^   Boolean dShort;     \/* data is array of shorts not floats (DISCRETE) *\/$/;"	m	struct:_ParmBuf	file:
dStack	HTKTools/HQuant.c	/^static MemHeap dStack;             \/* sequence stack *\/$/;"	v	file:
datFN	HTKTools/HVite.c	/^static char *datFN;               \/* Speech file *\/$/;"	v	file:
data	HTKLib/HAudio.c	/^   short *data;          \/* actual data buffer *\/$/;"	m	struct:__anon53	file:
data	HTKLib/HLM.h	/^   data;$/;"	m	struct:lmodel	typeref:union:lmodel::__anon125
data	HTKLib/HLat.c	/^   } data;$/;"	m	struct:_SubLNode	typeref:union:_SubLNode::__anon45	file:
data	HTKLib/HMem.h	/^   Ptr   data;          \/*        actual data for this block              *\/$/;"	m	struct:_Block
data	HTKLib/HParm.c	/^   void *data;       \/* parameterised data for this block *\/$/;"	m	struct:pblock	file:
data	HTKLib/HWave.c	/^   short *data;         \/* Actual data (always short once loaded) *\/$/;"	m	struct:_Wave	file:
data	HTKLib/esignal.h	/^    void        *data;          \/* GLOBAL data area *\/$/;"	m	struct:FieldSpec
data	HTKLib/esignal.h	/^    void        *data;          \/* storage area for data *\/$/;"	m	struct:Array
data	HTKTools/HSLab.c	/^static short *data;          \/* the data samples *\/$/;"	v	file:
dataFormat	HTKLib/HWave.c	/^   int32 dataFormat;     \/* format code *\/$/;"	m	struct:__anon103	file:
dataLocation	HTKLib/HWave.c	/^   int32 dataLocation;   \/* offset to start of data *\/$/;"	m	struct:__anon103	file:
dataSize	HTKLib/HWave.c	/^   int32 dataSize;       \/* number of bytes of data *\/$/;"	m	struct:__anon103	file:
dataStack	HTKLib/HFB.h	/^  MemHeap dataStack;  \/* utterance data information heap *\/$/;"	m	struct:__anon136
dataStack2	HTKLib/HFB.h	/^  MemHeap dataStack2; \/* utterance data2 information heap *\/$/;"	m	struct:__anon136
datadir	HTKLib/Makefile	/^datadir = ${prefix}\/share$/;"	m
datadir	HTKTools/Makefile	/^datadir = ${prefix}\/share$/;"	m
dbsDir	HLMTools/LAdapt.c	/^static char *dbsDir  = NULL;        \/* directory to store gbase files *\/$/;"	v	file:
dbsDir	HLMTools/LGCopy.c	/^static char *dbsDir  = NULL;        \/* directory to store gbase files *\/$/;"	v	file:
dbsDir	HLMTools/LGPrep.c	/^static char *dbsDir  = NULL;        \/* directory to store gbase files *\/$/;"	v	file:
dcInfo	HLMLib/LModel.h	/^   DiscountInfo dcInfo;     \/* discounting coefficients, etc *\/$/;"	m	struct:__anon13
dcType	HLMLib/LModel.h	/^   DiscountType dcType;     \/* discounting type *\/$/;"	m	struct:__anon13
dcTypeName	HLMLib/LModel.c	/^static char *dcTypeName[] = {$/;"	v	file:
dck	HTKLib/HTrain.c	/^static CovKind dck;     \/* defines type of distance calc *\/$/;"	v	file:
dcov	HTKLib/HTrain.c	/^static Covariance dcov; \/* covariance to use in distance calc *\/$/;"	v	file:
dctype	HLMLib/LPCalc.h	/^   DiscountType dctype;               \/* discount type *\/$/;"	m	struct:__anon2
debug	HTKLib/HArc.c	/^static int debug=0;$/;"	v	file:
debug_bestcorr	HTKLib/HExactMPE.c	/^static int debug_bestcorr = 1000;$/;"	v	file:
debug_level	HTKLib/HMem.c	/^int debug_level = 0;               \/* For esps linking *\/$/;"	v
debug_mode	HTKLib/HRNLM.h	/^    int debug_mode;$/;"	m	struct:_RNNLM
decode	HTKBook/htkbook-pdf.tex	/^\\include{netdict}$/;"	i
decode	HTKBook/htkbook.tex	/^\\include{netdict}$/;"	i
def	HTKLib/HLabel.h	/^   MLFDef def;          \/* the actual def *\/$/;"	m	struct:_MLFEntry
defChan	HTKLib/HParm.c	/^static ChannelInfo *defChan=NULL;$/;"	v	file:
defConf	HTKLib/HParm.c	/^static const IOConfigRec defConf = {$/;"	v	file:
defIntID	HLMLib/LModel.c	/^static Boolean defIntID = FALSE;        \/* Don't use 4-byte IDs *\/$/;"	v	file:
defList	HTKTools/HDMan.c	/^static LabId defList[MAXPVOC];       \/* list of predefined phones *\/$/;"	v	file:
defMapName	HLMTools/LAdapt.c	/^static char *defMapName = "LAdapt";   \/* map name *\/$/;"	v	file:
defMeanVec	HTKLib/HParm.c	/^   Vector defMeanVec;     \/* Default mean vector for reset *\/$/;"	m	struct:meanrec	file:
defargs	HTKLib/HShell.c	/^static char *defargs[2]={ "<Uninitialised>", "" };$/;"	v	file:
defs	HTKTools/HParse.c	/^static SubNetDef *defs;$/;"	v	file:
del	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Cell	file:
del	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Spkr	file:
del	HTKTools/HResults.c	/^static long del   = 0;     \/* Total deletions *\/$/;"	v	file:
delPen	HTKTools/HResults.c	/^static const int delPen = 7;$/;"	v	file:
delPenNIST	HTKTools/HResults.c	/^static const int delPenNIST = 3;$/;"	v	file:
delWin	HTKLib/HParm.c	/^   int delWin;                \/* Delta window halfsize *\/$/;"	m	struct:__anon76	file:
denLatDir	HTKTools/HMMIRest.c	/^static char *denLatDir [MAXLATS];  \/*MMI lattices.*\/$/;"	v	file:
denLatSubDirPat	HTKTools/HMMIRest.c	/^static char denLatSubDirPat[MAXSTRLEN] = "\\0";  \/* path mask of denominator lattices *\/$/;"	v	file:
den_index	HTKLib/HFBLat.h	/^  float den_index; \/*only for MPE. *\/ \/*make sure set. *\/$/;"	m	struct:__anon54
description	HLMLib/LUtil.h	/^  char *description;           \/* hash table description *\/$/;"	m	struct:__anon23
det	HTKLib/HAdapt.c	/^   float det;$/;"	m	struct:_ObsCache	file:
det	HTKLib/HModel.h	/^  float det;           \/* determinant of linxform *\/$/;"	m	struct:__anon68
dff	HTKTools/HCompV.c	/^static FileFormat dff=UNDEFF;       \/* data file format *\/$/;"	v	file:
dff	HTKTools/HERest.c	/^static FileFormat dff=UNDEFF;       \/* data file format *\/$/;"	v	file:
dff	HTKTools/HInit.c	/^static FileFormat dff=UNDEFF;       \/* data file format *\/$/;"	v	file:
dff	HTKTools/HMMIRest.c	/^static FileFormat dff=UNDEFF;       \/* data file format *\/$/;"	v	file:
dff	HTKTools/HQuant.c	/^static FileFormat dff=UNDEFF;       \/* data file format *\/$/;"	v	file:
dff	HTKTools/HRest.c	/^static FileFormat dff=UNDEFF;    \/* data file format *\/$/;"	v	file:
dfmt	HTKTools/HVite.c	/^static FileFormat dfmt=UNDEFF;    \/* Data input file format *\/$/;"	v	file:
diagCovXForm	HTKLib/HAdapt.c	/^static AdaptXForm* diagCovXForm = NULL;$/;"	v	file:
dictFN	HTKTools/HMMIRest.c	/^static char *dictFN=0;             \/* not needed at the moment. *\/$/;"	v	file:
dictFn	HTKTools/HLEd.c	/^static char *dictFn = NULL;         \/* Dictionary used for EX command *\/$/;"	v	file:
dictFn	HTKTools/HVite.c	/^static char *dictFn;              \/* Dictionary *\/$/;"	v	file:
dictList	HLMTools/HLMCopy.c	/^dictList;$/;"	t	typeref:struct:dictlist	file:
dictfn	HTKTools/HLRescore.c	/^static char *dictfn;		\/* dict filename from commandline *\/$/;"	v	file:
dictlist	HLMTools/HLMCopy.c	/^typedef struct dictlist {$/;"	s	file:
dim	HTKLib/HAdapt.c	/^   int dim;$/;"	m	struct:__anon92	file:
dim	HTKLib/esignal.h	/^    long        *dim;           \/* vector of dimensions *\/$/;"	m	struct:Array
dim	HTKLib/esignal.h	/^    long        *dim;           \/* vector of dimensions *\/$/;"	m	struct:FieldSpec
dim_fea	HTKLib/HRNLM.h	/^    int num_layer, dim_fea, nclass, inputlayersize, outputlayersize;$/;"	m	struct:_RNNLM
dir	HTKTools/HResults.c	/^   Direction dir;$/;"	m	struct:_Cell	file:
dirName	HTKLib/HModel.c	/^  char *dirName;           \/* input XForm directory name *\/$/;"	m	struct:_XFDirInfo	file:
direct_order	HTKLib/HRNLM.h	/^    int direct_order;$/;"	m	struct:_RNNLM
direct_size	HTKLib/HRNLM.h	/^    long long direct_size;$/;"	m	struct:_RNNLM
direct_t	HTKLib/HRNLM.h	/^typedef double direct_t;$/;"	t
disCount	HTKTools/HLStats.c	/^static float disCount = 0.5;        \/* discount for backoff *\/$/;"	v	file:
discmods	HTKBook/htkbook-pdf.tex	/^\\include{refine}$/;"	i
discmods	HTKBook/htkbook.tex	/^\\include{refine}$/;"	i
discreteLZero	HTKLib/HModel.c	/^static Boolean discreteLZero=FALSE;     \/* map DLOGZERO to LZERO *\/$/;"	v	file:
dispDEEP	HTKLib/HGraf.c	/^static unsigned int  ncells, dispWIDE, dispHIGH, dispDEEP;$/;"	v	file:
dispDEEP	HTKLib/HGraf_WIN32.c	/^static int   dispDEEP,dispWIDE,dispHIGH;$/;"	v	file:
dispHIGH	HTKLib/HGraf.c	/^static unsigned int  ncells, dispWIDE, dispHIGH, dispDEEP;$/;"	v	file:
dispHIGH	HTKLib/HGraf_WIN32.c	/^static int   dispDEEP,dispWIDE,dispHIGH;$/;"	v	file:
dispWIDE	HTKLib/HGraf.c	/^static unsigned int  ncells, dispWIDE, dispHIGH, dispDEEP;$/;"	v	file:
dispWIDE	HTKLib/HGraf_WIN32.c	/^static int   dispDEEP,dispWIDE,dispHIGH;$/;"	v	file:
dkind	HTKLib/HModel.h	/^   DurKind dkind;          \/* kind of duration model (model or state) *\/$/;"	m	struct:_HMMSet
doBOff	HTKTools/HLStats.c	/^static Boolean doBOff   = FALSE;$/;"	v	file:
doBigram	HTKTools/HLStats.c	/^static Boolean doBigram = FALSE;    \/* do what? *\/$/;"	v	file:
doDurs	HTKTools/HLStats.c	/^static Boolean doDurs   = FALSE;$/;"	v	file:
doLCount	HTKTools/HLStats.c	/^static Boolean doLCount = FALSE;$/;"	v	file:
doList	HTKTools/HLStats.c	/^static Boolean doList   = FALSE;$/;"	v	file:
doPCount	HTKTools/HLStats.c	/^static Boolean doPCount = FALSE; $/;"	v	file:
do_one_iteration	HLMTools/Cluster.c	/^static void do_one_iteration(int w_period, int start_word)$/;"	f	file:
do_recovery	HLMTools/Cluster.c	/^void do_recovery(char *fname, int words)$/;"	f
dotmultiply	HTKLib/HRNLM.c	/^void dotmultiply (float *arr1, float *arr2, int num)$/;"	f
doubleFFT	HTKLib/HParm.c	/^   Boolean doubleFFT;         \/* use twice the required FFT size *\/$/;"	m	struct:__anon76	file:
dpdf	HTKLib/HModel.h	/^   ShortVec dpdf;        \/* DISCRETE *\/$/;"	m	union:__anon58
dumpOfs	HLMTools/LGCopy.c	/^static int dumpOfs   = 0;           \/* initial numeric ext of gbase files *\/$/;"	v	file:
dumpOfs	HLMTools/LGPrep.c	/^static int  dumpOfs  = 0;           \/* initial numeric ext of gbase files *\/$/;"	v	file:
dur	HTKLib/HModel.h	/^   SVector dur;            \/* vector of model duration params, if any *\/   $/;"	m	struct:__anon64
dur	HTKLib/HModel.h	/^   SVector dur;         \/* vector of state duration params, if any *\/   $/;"	m	struct:__anon62
dur	HTKLib/HNet.h	/^   float dur;         \/* Duration of segment in seconds *\/$/;"	m	struct:lalign
dynamic	HTKLib/HRNLM.h	/^    real dynamic;$/;"	m	struct:_RNNLM
eNormalise	HTKLib/HParm.c	/^   Boolean eNormalise;        \/* Normalise log energy *\/$/;"	m	struct:__anon76	file:
eScale	HTKLib/HParm.c	/^   float eScale;              \/* Energy scale factor *\/$/;"	m	struct:__anon76	file:
eSep	HTKLib/HFBLat.c	/^static  Boolean eSep;$/;"	v	file:
eSep	HTKLib/HParm.h	/^   Boolean eSep;         \/* Energy is in separate stream *\/$/;"	m	struct:__anon120
editBuf	HLMTools/LGPrep.c	/^static LabId editBuf[MAX_FIELDS];   \/* edit buffer for input text *\/$/;"	v	file:
editUsed	HLMTools/LGPrep.c	/^static int editUsed;                \/* number of words in editPipe *\/$/;"	v	file:
editWinSize	HLMTools/LGPrep.c	/^static int editWinSize = 0;         \/* size of edit window *\/$/;"	v	file:
egbSize	HLMTools/LGPrep.c	/^static int egbSize   =  100000;     \/* edited ngram buffer size *\/$/;"	v	file:
elemSize	HTKLib/HMem.h	/^   size_t elemSize;     \/*  size of each elem              1 always       *\/$/;"	m	struct:__anon73
en	HTKTools/HCopy.c	/^static HTime en=0.0;            \/* end of samples to copy *\/$/;"	v	file:
en	HTKTools/HSLab.c	/^   long st, en;            \/* start and end sample of the previous zoom level *\/$/;"	m	struct:__anon145	file:
enableBlockAdapt	HTKLib/HAdapt.c	/^static IntVec enableBlockAdapt = NULL;$/;"	v	file:
encrypt	HLMLib/LModel.h	/^   Boolean encrypt;          \/* flag for encryption *\/$/;"	m	struct:__anon16
end	HTKLib/HArc.h	/^  CorrN *end;$/;"	m	struct:_CorrA
end	HTKLib/HArc.h	/^  HArc *end;$/;"	m	struct:ArcInfoStruct
end	HTKLib/HArc.h	/^  HArc *end;$/;"	m	struct:_ArcTrans
end	HTKLib/HFBLat.c	/^   int end;$/;"	m	struct:__anon89	file:
end	HTKLib/HLabel.h	/^   HTime start,end;         \/* Start and end times in 100ns units *\/$/;"	m	struct:_Label
end	HTKLib/HLat.c	/^   SubLNode *end;$/;"	m	struct:_SubLArc	file:
end	HTKLib/HNet.h	/^   NodeId end;         \/* Node at end of word *\/$/;"	m	struct:larc
end	HTKLib/HNet.h	/^   NodeId end;         \/* Node at end of word *\/$/;"	m	struct:larc_e
end	HTKLib/HNet.h	/^   NodeId end;$/;"	m	struct:larc_s
endLMWord	HTKLib/HLat.c	/^static LabId endLMWord;         \/* word at end in LM (<\/s>) *\/$/;"	v	file:
endLMWord	HTKTools/HLRescore.c	/^static char *endLMWord;         \/* word at end in LM (<\/s>) *\/$/;"	v	file:
endLab	HTKTools/HLRescore.c	/^static LabId endLab;            \/* corresponding LabId *\/$/;"	v	file:
endWord	HTKLib/HLat.c	/^static LabId endWord;           \/* word at end of Lattice (!SENT_END) *\/$/;"	v	file:
endWord	HTKTools/HLRescore.c	/^static char *endWord;           \/* word at end of Lattice (!SENT_END) *\/$/;"	v	file:
end_foll	HTKLib/HArc.h	/^  ArcTrans *end_foll;  \/*similarly for the end_{foll,prec}. *\/$/;"	m	struct:_ArcTrans
end_foll	HTKLib/HArc.h	/^  CorrA *end_foll;$/;"	m	struct:_CorrA
end_id	HLMTools/Cluster.c	/^static int         start_id=-1, end_id=-1;  \/* Start and end word ids *\/$/;"	v	file:
end_prec	HTKLib/HArc.h	/^  ArcTrans *end_prec; $/;"	m	struct:_ArcTrans
endi	HTKLib/HArc.h	/^  int endi;$/;"	m	struct:_CorrN
ends	HTKLib/HNet.c	/^   NetNode *ends;   \/* Chain of final models *\/$/;"	m	struct:pronholder	file:
enindex	HTKLib/HShell.c	/^   long enindex;                        \/* end sample to extract *\/$/;"	m	struct:__anon140	file:
ent2	HTKTools/HLStats.c	627;"	d	file:
enterExitId	HTKTools/HParse.c	/^static LabId  enterExitId;   \/* for use in RemoveGlue *\/$/;"	v	file:
enterId	HTKTools/HBuild.c	/^static LabId enterId;               \/* id of !ENTRY label in ngram *\/$/;"	v	file:
enterId	HTKTools/HLStats.c	/^static LabId enterId;               \/* id of ENTRY label in ngram *\/$/;"	v	file:
enterId	HTKTools/HParse.c	/^static LabId enterId;                 \/* LabId of the ENTER node name *\/$/;"	v	file:
entries	HLMLib/LCMap.h	/^   int entries;    	     	\/* total classes (or unk entries) in map *\/$/;"	m	struct:__anon21
entry	HTKTools/HBuild.c	/^   WordFllr *entry;$/;"	m	struct:_GramEntry	file:
entryHeap	HTKTools/HBuild.c	/^   MemHeap entryHeap;$/;"	m	struct:__anon164	file:
entryNode	HTKTools/HParse.c	/^   Link entryNode;$/;"	m	struct:__anon155	file:
epsilon	HTKTools/HInit.c	/^static float epsilon = 1.0E-4;      \/* convergence criterion *\/$/;"	v	file:
epsilon	HTKTools/HRest.c	/^static float epsilon = 1.0E-4;   \/* convergence criterion *\/$/;"	v	file:
epsilon	HTKTools/HSmooth.c	/^static float epsilon = 0.0001;   \/* binary chop convergence criterion *\/$/;"	v	file:
eqId	HLMTools/LPlex.c	/^static LabId  *eqId;                \/* label equivalence lookup table *\/$/;"	v	file:
eqList	HLMTools/LPlex.c	/^static Equiv *eqList = NULL;          \/* List of equivalent label ids *\/$/;"	v	file:
eql	HTKLib/HParm.c	/^   Vector eql;        \/* Equal loundness curve *\/$/;"	m	struct:__anon76	file:
eqlist	HTKTools/HResults.c	/^static Equiv *eqlist=NULL;            \/* List of equivalent label ids *\/$/;"	v	file:
equivId	HLMTools/LPlex.c	/^   LabId equivId;$/;"	m	struct:_Equiv	file:
equivId	HTKTools/HResults.c	/^   LabId equivId;$/;"	m	struct:_Equiv	file:
equivState	HTKTools/HHEd.c	/^static Boolean equivState = TRUE;      \/* TRUE if states can be equivalent *\/$/;"	v	file:
er	HTKLib/HRNLM.h	/^    real er;		\/*error value in neuron, used by learning algorithm *\/$/;"	m	struct:neuron
errors	HTKBook/htkbook-pdf.tex	/^\\include{config}$/;"	i
errors	HTKBook/htkbook.tex	/^\\include{config}$/;"	i
evalPPlex	HTKTools/HLRescore.c	/^static Boolean evalPPlex = TRUE;           \/* LM perplexity evaluation on label files *\/$/;"	v	file:
event	HTKLib/HGraf.h	/^   HEvent event;     \/* type of event *\/$/;"	m	struct:__anon96
evin	HTKLib/HAudio.c	/^   Environment *evin;$/;"	m	struct:_AudioIn	file:
evout	HTKLib/HAudio.c	/^   Environment *evout;$/;"	m	struct:_AudioOut	file:
exampsys	HTKBook/htkbook-pdf.tex	/^\\include{htkoview}$/;"	i
exampsys	HTKBook/htkbook.tex	/^\\include{htkoview}$/;"	i
exec_prefix	HTKLib/Makefile	/^exec_prefix = ${prefix}$/;"	m
exec_prefix	HTKTools/Makefile	/^exec_prefix = ${prefix}$/;"	m
exit	HTKLib/HRec.c	/^   TokenSet *exit;      \/* TokenSet in exit state *\/$/;"	m	struct:_NetInst	file:
exitId	HTKTools/HBuild.c	/^static LabId exitId;                \/* id of !EXIT label in ngram *\/$/;"	v	file:
exitId	HTKTools/HLStats.c	/^static LabId exitId;                \/* id of EXIT label in ngram *\/$/;"	v	file:
exitId	HTKTools/HParse.c	/^static LabId exitId;                  \/* LabId of the EXIT node name *\/$/;"	v	file:
exitNode	HTKTools/HParse.c	/^   Link exitNode;$/;"	m	struct:__anon155	file:
expandLat	HTKTools/HLRescore.c	/^static Boolean expandLat = FALSE;   \/* -n *\/$/;"	v	file:
export_classes	HLMTools/Cluster.c	/^void export_classes(int recovery)$/;"	f
export_index	HLMTools/Cluster.c	/^static int         export_index=0;          \/* What iteration is this? *\/$/;"	v	file:
export_prefix	HLMTools/Cluster.c	/^static char       *export_prefix="cluster"; \/* Prefix of export filenames *\/$/;"	v	file:
ext	HTKLib/HParm.c	/^   HParmSrcDef ext;     \/* external source functions *\/$/;"	m	struct:_ParmBuf	file:
extFileNext	HTKLib/HShell.c	/^static int extFileNext = 0;             \/* next slot to save into *\/$/;"	v	file:
extFileUsed	HTKLib/HShell.c	/^static int extFileUsed = 0;             \/* total ext files in buffer *\/$/;"	v	file:
extFiles	HTKLib/HShell.c	/^static ExtFile extFiles[MAXEFS];        \/* circ buf of ext file names *\/$/;"	v	file:
extName	HTKTools/HParse.c	/^   LabId extName;    \/* external name (used in compatability mode) *\/$/;"	m	struct:_Node	file:
extendedFileNames	HTKLib/HShell.c	/^static Boolean extendedFileNames = TRUE; \/* allow extended file names *\/$/;"	v	file:
f	HTKLib/HRNLM.h	/^    float *i, *f, *newc, *zi, *fc, *o;  \/* *c *z from GRU layer defination *\/$/;"	m	struct:_Layer
f	HTKLib/HShell.h	/^   FILE *f;             \/* input stream *\/$/;"	m	struct:__anon84
f	HTKLib/HShell.h	/^   double f;$/;"	m	union:__anon86
f	HTKTools/HParse.c	/^static FILE *f;                     \/* Input stream *\/$/;"	v	file:
fClose	HTKLib/HParm.c	/^   void (*fClose)(Ptr xInfo,Ptr bInfo);  \/* Close buffer and free resources *\/$/;"	m	struct:hparmsrcdef	file:
fCnt	HTKLib/HParm.c	/^   int fCnt;              \/* Number of files processed for this channel *\/$/;"	m	struct:channelinfo	file:
fGetData	HTKLib/HParm.c	/^   int (*fGetData)(Ptr xInfo,Ptr bInfo,int n,Ptr data);  \/* Read samples *\/$/;"	m	struct:hparmsrcdef	file:
fGetWaveData	HTKLib/HParm.c	/^static int fGetWaveData(int n,void *data,short *res,$/;"	f	file:
fHead	HTKLib/HAudio.c	/^   mmApiBuf *fHead;         \/* Head of filled buffer list *\/$/;"	m	struct:_AudioIn	file:
fName	HTKLib/HModel.h	/^   char *fName;            \/* MMF file name *\/$/;"	m	struct:_MMFInfo
fNumSamp	HTKLib/HParm.c	/^   int (*fNumSamp)(Ptr xInfo,Ptr bInfo);  \/* Query samples readable without blocking *\/$/;"	m	struct:hparmsrcdef	file:
fOpen	HTKLib/HParm.c	/^   Ptr (*fOpen)(Ptr xInfo,char *fn,BufferInfo *info);  \/* Open new buffer *\/$/;"	m	struct:hparmsrcdef	file:
fShort	HTKLib/HParm.c	/^   Boolean fShort;     \/* file is array of shorts (DISCRETE, COMPX or IREFC) *\/$/;"	m	struct:_ParmBuf	file:
fStart	HTKLib/HParm.c	/^   void (*fStart)(Ptr xInfo,Ptr bInfo);  \/* Start data capture for real-time sources *\/$/;"	m	struct:hparmsrcdef	file:
fStop	HTKLib/HParm.c	/^   void (*fStop)(Ptr xInfo,Ptr bInfo);  \/* Stop data capture for real-time sources *\/$/;"	m	struct:hparmsrcdef	file:
fTail	HTKLib/HAudio.c	/^   mmApiBuf *fTail;         \/* Tail of filled buffer list *\/$/;"	m	struct:_AudioIn	file:
f_FIELD	HLMTools/LGPrep.c	/^   f_FIELD,                   \/* slot contents *\/$/;"	e	enum:__anon24	file:
f_NONE	HLMTools/LGPrep.c	/^   f_NONE$/;"	e	enum:__anon24	file:
f_NWSET	HLMTools/LGPrep.c	/^   f_NWSET,                   \/* not in word set *\/$/;"	e	enum:__anon24	file:
f_WILD	HLMTools/LGPrep.c	/^   f_WILD,                    \/* wildcard *\/$/;"	e	enum:__anon24	file:
f_WORD	HLMTools/LGPrep.c	/^   f_WORD,                    \/* literal word *\/$/;"	e	enum:__anon24	file:
f_WSET	HLMTools/LGPrep.c	/^   f_WSET,                    \/* in word set *\/$/;"	e	enum:__anon24	file:
faTimeUnit	HTKTools/HResults.c	/^static float faTimeUnit = 1.0;        \/* unit for measuring false alarms *\/$/;"	v	file:
facc	HTKTools/HLEd.c	/^static FindAcc *facc = NULL;$/;"	v	file:
factorLM	HTKLib/HNet.c	/^Boolean factorLM=FALSE;$/;"	v
farc	HTKLib/HNet.h	/^   ArcId farc;         \/* Next arc following start node *\/$/;"	m	struct:larc
farc	HTKLib/HNet.h	/^   ArcId farc;$/;"	m	struct:larc_s
farc	HTKLib/HNet.h	/^   EArcId farc;        \/* Next arc following start node *\/$/;"	m	struct:larc_e
fbInfo	HTKLib/HFBLat.c	/^static FBLatInfo *fbInfo; \/* current fbInfo, so don't have to pass it around. *\/$/;"	v	file:
fbInfo	HTKLib/HParm.c	/^   FBankInfo fbInfo;  \/* FBank info used for filterbank analysis *\/$/;"	m	struct:__anon76	file:
fbInfo	HTKTools/HMMIRest.c	/^static FBLatInfo  fbInfo;            \/* Structure for discriminative forward-backward. *\/$/;"	v	file:
fbInfo	HTKTools/HVite.c	/^static FBInfo *fbInfo;            \/* forward-backward info for alignment *\/$/;"	v	file:
fbInfoStack	HTKTools/HERest.c	/^static MemHeap fbInfoStack;$/;"	v	file:
fbank	HTKLib/HParm.c	/^   Vector fbank;      \/* filterbank vector *\/$/;"	m	struct:__anon76	file:
fc	HTKLib/HNet.c	/^   int fc;          \/* Final context - cache saves finding for all links *\/$/;"	m	struct:pronholder	file:
fc	HTKLib/HRNLM.h	/^    float *i, *f, *newc, *zi, *fc, *o;  \/* *c *z from GRU layer defination *\/$/;"	m	struct:_Layer
fci	HTKLib/HNet.c	/^   Boolean fci;     \/* Final phone context independent *\/$/;"	m	struct:pronholder	file:
fcmp	HTKLib/HParm.c	/^static int fcmp(const void *v1,const void *v2)$/;"	f	file:
fcra	HTKLib/HNet.h	/^   EArcId fcra;        \/* List linked in both directions *\/$/;"	m	struct:larc_e
fct	HTKLib/HNet.c	/^   LogFloat fct;    \/* LM likelihood to be factored into each phone *\/$/;"	m	struct:pronholder	file:
fdt	HLMTools/LGPrep.c	/^   FieldItem fdt[MAX_FIELDS]; \/* actual data in each field *\/$/;"	m	struct:__anon27	file:
fe_buff	HLMLib/LModel.h	/^   FLEntry *fe_buff;         \/* temp buffer *\/$/;"	m	struct:__anon16
fea	HLMLib/LModel.h	/^   struct _FLEntry *fea;    \/* sorted array [0..nfe-1] of FLEntry *\/$/;"	m	struct:_FLEntry	typeref:struct:_FLEntry::_FLEntry
ff	HTKTools/HLStats.c	/^static FileFormat ff=UNDEFF;        \/* Label file format *\/$/;"	v	file:
ff	HTKTools/HList.c	/^static FileFormat ff = UNDEFF;   \/* Source File format *\/$/;"	v	file:
fftN	HTKLib/HSigP.h	/^   int fftN;            \/* fft size *\/$/;"	m	struct:__anon129
fg	HTKLib/HGraf.h	/^   HColour fg, bg;            \/* colors *\/$/;"	m	struct:_HButton
fg	HTKTools/HSLab.c	/^   HColour fg, bg;$/;"	m	struct:__anon148	file:
fg	HTKTools/HSLab.c	/^   HColour fg;$/;"	m	struct:__anon149	file:
fidx	HTKLib/HLabel.h	/^   int fidx;      \/* MLF file index in mlfile *\/$/;"	m	struct:__anon117
fidx	HTKLib/HModel.h	/^   int fidx;               \/* MMF file index *\/$/;"	m	struct:_MMFInfo
fidx	HTKLib/HModel.h	/^   short fidx;             \/* idx of MMF file (0 = SMF) *\/$/;"	m	struct:_MacroDef
fidx	HTKTools/HHEd.c	/^static int fidx;           \/* current macro file id *\/$/;"	v	file:
figures	HTKBook/Makefile	/^figures =    HTKFigs\/Blocking.eps      HTKFigs\/melfbank.eps		    \\$/;"	m
file	HTKLib/HLabel.c	/^   FILE *file;$/;"	m	struct:__anon135	file:
fileLimit	HTKTools/HResults.c	/^static int fileLimit = INT_MAX;       \/* max num of label files to process *\/$/;"	v	file:
fileSize	HTKLib/HWave.c	/^   int32 fileSize;    \/* num samples * 2 *\/$/;"	m	struct:__anon102	file:
fileWin	HTKTools/HSLab.c	/^static RectWin fileWin;      \/* the window for file names and other info *\/$/;"	v	file:
filetype	HTKLib/HRNLM.h	/^    int filetype;$/;"	m	struct:_RNNLM
fill	HTKLib/HWave.c	/^   char fill[832];$/;"	m	struct:__anon102	file:
fill1	HTKLib/HWave.c	/^   char fill1[182];$/;"	m	struct:__anon102	file:
filtList	HLMTools/LGList.c	/^static FItem *filtList = NULL;$/;"	v	file:
filtermap	HTKLib/HShell.c	/^static char *filtermap[] = {$/;"	v	file:
final	HTKLib/HNet.h	/^   NetNode final;     \/* Final (dummy) node *\/$/;"	m	struct:__anon128
findBest	HTKTools/HLRescore.c	/^static Boolean findBest = FALSE;    \/* -f *\/$/;"	v	file:
finite	HTKLib/HTrain.h	49;"	d
firstElem	HTKLib/HModel.h	/^   Boolean *firstElem;     \/* first element added to hmem during MakeHMMSet*\/$/;"	m	struct:_HMMSet
firstFree	HTKLib/HMem.h	/^   size_t firstFree;    \/* idx of 1st free elem      idx of stack top     *\/$/;"	m	struct:_Block
firstGram	HLMLib/LGBase.h	/^   LabId firstGram[MAXNG];  \/* first entry in file *\/$/;"	m	struct:__anon4
firstGram	HLMLib/LGBase.h	/^   LabId firstGram[MAXNG];  \/* first entry in file *\/$/;"	m	struct:gramfile
firstNdx	HLMLib/LWMap.h	/^   int     firstNdx;     \/* ndx of entry which is first in sort order *\/$/;"	m	struct:__anon20
firstOnly	HLMTools/HLMCopy.c	/^static Boolean   firstOnly = FALSE;      \/* Only use first dictionary with pron *\/$/;"	v	file:
firstTime	HTKLib/HFBLat.h	/^  Boolean firstTime ;     \/* Flag used to enable creation of ot *\/$/;"	m	struct:__anon54
firstTime	HTKTools/HERest.c	/^static Boolean firstTime = TRUE;    \/* Flag used to enable creation of ot *\/$/;"	v	file:
firstTime	HTKTools/HInit.c	/^static Boolean firstTime = TRUE;    \/* Flag used to enable InitSegStore *\/$/;"	v	file:
firstTime	HTKTools/HRest.c	/^static Boolean firstTime = TRUE; \/* Flag used to enable InitSegStore *\/$/;"	v	file:
fitem	HLMTools/LGList.c	/^typedef struct fitem {$/;"	s	file:
fixBadLats	HTKTools/HLRescore.c	/^static Boolean fixBadLats = FALSE;         \/* fix final word in lattices *\/$/;"	v	file:
fixPronprobs	HTKTools/HLRescore.c	/^static Boolean fixPronprobs = FALSE; \/* get pron probs from dict *\/$/;"	v	file:
fixed	HTKTools/HCompV.c	/^   Covariance   fixed;              \/* fixed (co)variance values *\/$/;"	m	struct:__anon151	file:
flags	HTKLib/HRec.c	/^   int flags;           \/* Flags, active ... *\/$/;"	m	struct:_NetInst	file:
flid	HLMTools/LGPrep.c	/^   int   flid;                \/* field index *\/$/;"	m	union:__anon25	file:
flist	HLMLib/LCMap.h	/^   ClassEntry *flist;	        \/* free list of ClassEntry records *\/$/;"	m	struct:__anon21
fllrHeap	HTKTools/HBuild.c	/^   MemHeap fllrHeap;$/;"	m	struct:__anon164	file:
fltcompare	HTKTools/HERest.c	/^static  int fltcompare(const void *_i, const void *_j)$/;"	f	file:
fltcompare	HTKTools/HMMIRest.c	/^static  int fltcompare(const void *_i, const void *_j)$/;"	f	file:
fmem	HLMTools/LGList.c	/^static MemHeap fmem;$/;"	v	file:
fmt	HLMLib/LModel.h	/^   LMFileFmt fmt;           \/* indicates LM section stored in binary *\/$/;"	m	struct:__anon14
fmt	HTKLib/HWave.c	/^   FileFormat fmt;      \/* Format of associated source file *\/$/;"	m	struct:_Wave	file:
fmt	HTKTools/HList.c	/^   FileFormat fmt;$/;"	m	struct:__anon153	file:
fmtmap	HTKLib/HWave.c	/^static char *fmtmap[] = {$/;"	v	file:
fn	HLMLib/LGBase.h	/^   char *fn;               \/* basename of output file name *\/$/;"	m	struct:__anon6
fn	HLMLib/LGBase.h	/^   char fn[MAXSTRLEN];     \/* file name *\/$/;"	m	struct:gramfile
fn	HLMLib/LPMerge.h	/^   char *fn;                \/* LM filename *\/$/;"	m	struct:__anon17
fname	HLMTools/HLMCopy.c	/^   char *fname;$/;"	m	struct:dictlist	file:
fname	HTKLib/HModel.h	/^  char *fname;                      \/* filename of where the xform was loaded *\/$/;"	m	struct:_AdaptXForm
fname	HTKLib/HModel.h	/^  char *fname;         \/* filename of where the baseclass was loaded *\/$/;"	m	struct:__anon65
fname	HTKLib/HModel.h	/^  char *fname;         \/* filename of where the input xform was loaded *\/$/;"	m	struct:__anon70
fname	HTKLib/HModel.h	/^  char *fname;         \/* filename of where the regTree was loaded *\/$/;"	m	struct:RegTree
fndx	HLMLib/LGBase.h	/^   int fndx;               \/* index of next output file *\/$/;"	m	struct:__anon6
fof	HLMLib/LGBase.h	/^   UInt **fof;             \/* array[1..N][1..size] of count *\/$/;"	m	struct:__anon7
fofFN	HLMTools/LBuild.c	/^static char *fofFN   = NULL;        \/* FoF table filename *\/$/;"	v	file:
fofFN	HLMTools/LFoF.c	/^static char       *fofFN = NULL;    \/* output FoF file name *\/$/;"	v	file:
fofSize	HLMTools/LFoF.c	/^static int        fofSize = 128;    \/* size of fof table *\/$/;"	v	file:
fofTab	HLMTools/LFoF.c	/^static FoFTab     *fofTab;          \/* FoF Table *\/$/;"	v	file:
foll	HTKLib/HArc.h	/^  HArc *foll;$/;"	m	struct:_Arc
foll	HTKLib/HLat.c	/^   SubLArc *foll;$/;"	m	struct:_SubLNode	file:
foll	HTKLib/HNet.h	/^   ArcId foll;         \/* Linked list of arcs following node *\/$/;"	m	struct:lnode
follTrans	HTKLib/HArc.h	/^  ArcTrans *follTrans;  \/*Arcs which follow.*\/$/;"	m	struct:_Arc
follTrans	HTKLib/HArc.h	/^  CorrA *follTrans;$/;"	m	struct:_CorrN
fomA	HTKTools/HResults.c	/^static float fomA;            \/* interpolation factor *\/$/;"	v	file:
fomN	HTKTools/HResults.c	/^static int fomN;              \/* num FA levels needed *\/$/;"	v	file:
fomTab	HTKTools/HResults.c	/^static Matrix fomTab;         \/* array[1..kn+1,1..fomN+1] of hitRate *\/$/;"	v	file:
fop	HLMTools/LGPrep.c	/^   FieldOp   fop[MAX_FIELDS]; \/* tag\/operation for each field *\/$/;"	m	struct:__anon27	file:
forceCnts	HLMTools/LGPrep.c	/^static Boolean forceCnts = FALSE;   \/* force the output of word counts *\/$/;"	v	file:
forceCxtExp	HTKLib/HNet.c	/^Boolean forceCxtExp=FALSE;$/;"	v
forceHSKind	HTKLib/HModel.c	/^static Boolean forceHSKind= FALSE;      \/* force HMM Set Kind *\/$/;"	v	file:
forceLeftBiphones	HTKLib/HNet.c	/^Boolean forceLeftBiphones=FALSE;$/;"	v
forceOutput	HTKLib/HRec.c	/^static Boolean forceOutput=FALSE;$/;"	v	file:
forceRightBiphones	HTKLib/HNet.c	/^Boolean forceRightBiphones=FALSE;$/;"	v
formType	HTKLib/HWave.c	/^   int32 formType;    \/* must be 'AIFF' *\/$/;"	m	struct:__anon104	file:
format	HTKLib/HNet.h	/^   LatFormat format;	       	\/* indicate which fields are valid *\/$/;"	m	struct:lattice
forward	HLMTools/Cluster.c	/^static bigrams     *forward=0, *backward;    \/* Forward and backward bigram tables *\/$/;"	v	file:
forward	HLMTools/Cluster.c	/^static bigrams    *forward, *backward;      \/* Forward and backward bigram tables *\/$/;"	v	file:
forward	HTKLib/HRNLM.c	/^void forward (Layer *self, int prevword, int curword, float *neu0_ac, float *neu1_ac)$/;"	f
forward_nosigm	HTKLib/HRNLM.c	/^void forward_nosigm (Layer *self, int prevword, int curword, float *neu0_ac, float *neu1_ac)$/;"	f
fourthWin	HTKLib/HParm.c	/^   int fourthWin;             \/* Fourth order differential halfsize *\/$/;"	m	struct:__anon76	file:
fp_map_in	HTKLib/HNLM.c	/^static FILE *fp_map_in;$/;"	v	file:
fp_map_out	HTKLib/HNLM.c	/^static FILE *fp_map_out;$/;"	v	file:
frBuf	HTKLib/HAudio.c	/^   short * frBuf;            \/* buffer for constructing frames *\/$/;"	m	struct:_AudioIn	file:
frIdx	HTKLib/HWave.c	/^   int frIdx;           \/* Start of next frame *\/$/;"	m	struct:_Wave	file:
frMax	HTKLib/HParm.c	/^   float frMax;           \/* Measured maximum frame energy for channel (dB) *\/$/;"	m	struct:channelinfo	file:
frMin	HTKLib/HParm.c	/^   float frMin;           \/* Measured minimum frame energy for channel (dB) *\/$/;"	m	struct:channelinfo	file:
frOLap	HTKLib/HAudio.c	/^   Vector frOLap;            \/* frame overlap buffer used by GetAudio *\/$/;"	m	struct:_AudioIn	file:
frRate	HTKLib/HAudio.c	/^   int frRate;               \/* num samples between speech frames *\/$/;"	m	struct:_AudioIn	file:
frRate	HTKLib/HParm.c	/^   int frRate;        \/* Number of waveform samples advanced each frame *\/$/;"	m	struct:__anon76	file:
frRate	HTKLib/HParm.h	/^   int frRate;                \/* Number of source samples forward each frame *\/$/;"	m	struct:__anon122
frRate	HTKLib/HWave.c	/^   int frRate;          \/* Frame rate *\/$/;"	m	struct:_Wave	file:
frSize	HTKLib/HAudio.c	/^   int frSize;               \/* num samples per speech frame *\/$/;"	m	struct:_AudioIn	file:
frSize	HTKLib/HParm.c	/^   int frSize;        \/* Total number of waveform samples in frame *\/$/;"	m	struct:__anon76	file:
frSize	HTKLib/HParm.h	/^   int frSize;                \/* Number of source samples in each frame *\/$/;"	m	struct:__anon122
frSize	HTKLib/HWave.c	/^   int frSize;          \/* Num samples per frame *\/$/;"	m	struct:_Wave	file:
frag_size	HTKLib/HAudio.c	/^static int frag_size;$/;"	v	file:
frame	HTKLib/HRec.c	/^   int frame;               \/* Current frame number *\/$/;"	m	struct:precinfo	file:
frame	HTKLib/HRec.c	/^   int frame;           \/* Frame number upon entering state\/model end *\/$/;"	m	struct:align	file:
frame	HTKLib/HRec.h	/^   int frame;               \/* Current frame number *\/$/;"	m	struct:vrecinfo
frame	HTKLib/HRec.h	/^   int frame;           \/* Time (frame) of boundary (end of word) *\/$/;"	m	struct:path
frameDur	HTKLib/HRec.h	/^   HTime frameDur;          \/* Sample rate (to convert frame to time) *\/$/;"	m	struct:vrecinfo
frameSize	HTKLib/HSigP.h	/^   int frameSize;       \/* speech frameSize *\/$/;"	m	struct:__anon129
framedur	HTKLib/HArc.h	/^  float framedur;$/;"	m	struct:ArcInfoStruct
framedur	HTKLib/HNet.h	/^   HTime framedur;              \/* Frame duration in 100ns units *\/$/;"	m	struct:lattice
frames	HTKLib/HParm.c	/^   int frames;            \/* Number of frames processed in session *\/$/;"	m	struct:meanrec	file:
frcDisc	HTKTools/HList.c	/^static Boolean frcDisc = FALSE;  \/* List VQ symbols from cont file *\/$/;"	v	file:
frcSil	HTKLib/HNet.c	/^char *frcSil=NULL,frcSilBuf[MAXSTRLEN];$/;"	v
frcSilBuf	HTKLib/HNet.c	/^char *frcSil=NULL,frcSilBuf[MAXSTRLEN];$/;"	v
freeSlots	HLMTools/LBuild.c	/^static int  freeSlots = 10;$/;"	v	file:
freeSlots	HLMTools/LGCopy.c	/^static int freeSlots = 100;         \/* free class slots *\/$/;"	v	file:
freq_sort_order	HLMTools/Cluster.c	/^static int freq_sort_order(int *in1, int *in2)$/;"	f	file:
fres	HTKLib/HSigP.h	/^   float fres;          \/* scaled fft resolution *\/$/;"	m	struct:__anon129
ftab	HLMLib/LPCalc.h	/^   FoFTab       *ftab;                \/* FoF table *\/$/;"	m	struct:__anon2
fullResults	HTKTools/HResults.c	/^static Boolean fullResults = FALSE;   \/* enable full Results *\/$/;"	v	file:
fullcNeeded	HTKTools/HCompV.c	/^static Boolean fullcNeeded[SMAX];   \/* true for each stream that needs full$/;"	v	file:
fulldict_size	HTKLib/HRNLM.h	/^    int fulldict_size;              \/*  size of full dictionary used in ngram  *\/$/;"	m	struct:_RNNLM
fullname	HTKLib/esignal.h	/^    char	*fullname;	\/* name including parent name, if any,$/;"	m	struct:FieldSpec
fundaments	HTKBook/htkbook-pdf.tex	/^\\part{Tutorial Overview}$/;"	i
fundaments	HTKBook/htkbook.tex	/^\\part{Tutorial Overview}$/;"	i
fv	HTKLib/HParm.h	/^   Vector fv[SMAX];      \/* array[1..swidth[0]] of Vector *\/$/;"	m	struct:__anon120
fvSegs	HTKLib/HTrain.h	/^   Sequence fvSegs;     \/* each seg is a sequence of fv[SMAX] *\/$/;"	m	struct:_SegStoreRec
fwlike	HTKLib/HLat.h	/^   LogDouble fwlike;     \/* forward likelihood *\/$/;"	m	struct:FBlnodeInfo
fword	HTKLib/HLM.h	/^   lmId fword[NSIZE];              \/* Succeeding word *\/$/;"	m	struct:nentry
fwordname	HTKLib/HLat.c	/^   LabId    fwordname[NSIZE];$/;"	m	struct:_SubLNode	file:
g	HTKLib/HRNLM.h	/^    float *g, *v;$/;"	m	struct:_Layer
gConst	HTKLib/HAdapt.c	/^   float gConst;$/;"	m	struct:__anon93	file:
gConst	HTKLib/HModel.h	/^   float gConst;        \/* Precomputed component of b(x) *\/$/;"	m	struct:__anon56
gGw	HLMTools/Cluster.c	/^static int         GwGw, gGw, Gwg, gg;      \/* Special-case class counts *\/$/;"	v	file:
gInfo	HLMLib/LModel.h	/^   NGramInfo gInfo[LM_NSIZE];\/* information for each n-gram component *\/$/;"	m	struct:__anon16
gScale	HLMLib/LModel.h	/^   float   gScale;           \/* grammar scale factor *\/$/;"	m	struct:__anon16
gScriptFN	HTKTools/HDMan.c	/^static char *gScriptFN = NULL;       \/* name of global edit script *\/$/;"	v	file:
gains	HTKLib/HAudio.c	/^   AGainEntry gains[4];$/;"	m	struct:_AudioIn	file:
gains	HTKLib/HAudio.c	/^   AGainEntry gains[4];$/;"	m	struct:_AudioOut	file:
gbGen	HLMTools/LGPrep.c	/^static Boolean gbGen = TRUE;        \/* flag to enable GBase generation *\/$/;"	v	file:
gcheap	HTKLib/HMem.c	/^MemHeap gcheap;   \/* global CHEAP for general purpose use *\/$/;"	v
gconst	HTKLib/HVQ.h	/^   float gconst;        \/* const part of log prob for INVDIAGC & FULLC *\/$/;"	m	struct:_VQNodeRec
gconst_cmp	HTKLib/HModel.c	/^static int gconst_cmp(const void *v1,const void *v2)$/;"	f	file:
gcs	HTKLib/HGraf.c	/^static GC            gcs[MAX_GC];$/;"	v	file:
gen	HTKLib/HRNLM.h	/^    int gen;$/;"	m	struct:_RNNLM
gen	HTKTools/HList.c	/^static long gen = -1;             \/* end sample to list *\/$/;"	v	file:
genBeam	HTKLib/HRec.h	/^   LogFloat genBeam;        \/* Global beam width *\/$/;"	m	struct:vrecinfo
genBeam	HTKTools/HVite.c	/^static LogDouble genBeam = -LZERO;\/* genBeam threshold *\/$/;"	v	file:
genBeamInc	HTKTools/HVite.c	/^static LogDouble genBeamInc  = 0.0;       \/* increment         *\/$/;"	v	file:
genBeamLim	HTKTools/HVite.c	/^static LogDouble genBeamLim = -LZERO;     \/* max value       *\/$/;"	v	file:
genMaxNode	HTKLib/HRec.c	/^   NetNode *genMaxNode;     \/* Most likely node in network *\/$/;"	m	struct:precinfo	file:
genMaxNode	HTKLib/HRec.h	/^   NetNode *genMaxNode;     \/* Most likely node in network *\/$/;"	m	struct:vrecinfo
genMaxTok	HTKLib/HRec.c	/^   Token genMaxTok;         \/* Most likely token *\/$/;"	m	struct:precinfo	file:
genMaxTok	HTKLib/HRec.h	/^   Token genMaxTok;         \/* Most likely token *\/$/;"	m	struct:vrecinfo
genThresh	HTKLib/HRec.c	/^   LogFloat genThresh;      \/* Cutoff from global beam *\/$/;"	m	struct:precinfo	file:
getWordHash	HTKLib/HRNLM.c	/^static int getWordHash(RNNLM* rnnlm, char *word)$/;"	f	file:
get_id_from_word	HLMTools/Cluster.c	/^UInt get_id_from_word(char *word)$/;"	f
get_space	HLMTools/Cluster.c	/^static void *get_space(int size)$/;"	f	file:
gf	HLMLib/LGBase.h	/^   GFLink gf[MAXINF];      \/* list of ptrs to gram files *\/$/;"	m	struct:__anon5
gfsort	HLMLib/LGBase.h	/^   int gfsort[MAXINF];     \/* idx's of sorted gram files *\/$/;"	m	struct:__anon5
gg	HLMTools/Cluster.c	/^static int         GwGw, gGw, Gwg, gg;      \/* Special-case class counts *\/$/;"	v	file:
glist	HTKTools/HBuild.c	/^   GramEntry *glist;   $/;"	m	struct:__anon164	file:
globClustVar	HTKTools/HQuant.c	/^static Boolean globClustVar = FALSE;\/*Output global variance of data to$/;"	v	file:
global_heap	HLMTools/Cluster.c	/^static MemHeap     global_heap;             \/* Claim fixed block memory from here *\/$/;"	v	file:
global_stack	HLMTools/Cluster.c	/^static MemHeap     global_stack;            \/* Claim other memory from here *\/$/;"	v	file:
goToDelimiter	HTKLib/HRNLM.c	/^static void goToDelimiter(int delim, FILE *fi)$/;"	f	file:
gradient_cutoff	HTKLib/HRNLM.h	/^    real gradient_cutoff;$/;"	m	struct:_RNNLM
gramfile	HLMLib/LGBase.h	/^typedef struct gramfile{ \/* info record for a packed gram file *\/$/;"	s
greys	HTKLib/HGraf.c	/^static int greys[MAX_GREYS];$/;"	v	file:
greys	HTKLib/HGraf_WIN32.c	/^static unsigned char greys[MAX_GREYS];$/;"	v	file:
grid	HTKTools/HResults.c	/^static CellPtr *grid;     \/* matrix of cells *\/$/;"	v	file:
growf	HTKLib/HMem.h	/^   float growf;         \/*           succ blocks grow as 1+growf          *\/$/;"	m	struct:__anon73
gst	HTKTools/HList.c	/^static long gst = -1;             \/* start sample to list *\/$/;"	v	file:
gstack	HTKLib/HMem.c	/^MemHeap gstack;   \/* global MSTAK for general purpose use *\/$/;"	v
h	HTKLib/HArc.c	/^   HArc *h;$/;"	m	struct:_ArcList	file:
h	HTKLib/HFBLat.c	/^   CorrectArc *h;$/;"	m	struct:_CorrectArcList	file:
h	HTKLib/HGraf.h	/^   int x, y, w, h;            \/* size of button rectangle *\/$/;"	m	struct:_HButton
h	HTKLib/HUtil.h	/^   int h;            \/* current mtab slot *\/$/;"	m	struct:__anon38
h	HTKTools/HSLab.c	/^   int x, y, w, h, bw;    \/* x-pos, y-pos, width, height, fg and bg colours *\/$/;"	m	struct:__anon148	file:
hRedrawWindow	HTKTools/HSLab.c	/^void hRedrawWindow(void)$/;"	f
hSet	HTKTools/HHEd.c	/^static HMMSet hSet;        \/* current HMM set *\/$/;"	v	file:
hSize	HTKTools/HLStats.c	/^static int hSize = 0;               \/* hash table size, small(0), med(1), large(2)  *\/$/;"	v	file:
h_	HTKLib/HRNLM.h	/^    float *r, *z, *c, *h_;$/;"	m	struct:_Layer
h_ac	HTKLib/HRNLM.h	/^    float *h_ac;$/;"	m	struct:_Layer
hadapt_vc_id	HTKLib/HAdapt.c	/^char *hadapt_vc_id =  "$Id: HAdapt.c,v 1.2 2006\/12\/07 11:09:07 mjfg Exp $";$/;"	v
hadapt_version	HTKLib/HAdapt.c	/^char *hadapt_version = "!HVER!HAdapt:   3.4.1  [CUED 12\/03\/09]";$/;"	v
hamWin	HTKLib/HSigP.c	/^static Vector hamWin = NULL;        \/* Current Hamming window *\/$/;"	v	file:
hamWinSize	HTKLib/HSigP.c	/^static int hamWinSize = 0;          \/* Size of current Hamming window *\/$/;"	v	file:
hasCnts	HLMLib/LWMap.h	/^   Boolean hasCnts;      \/* has word freq cnts, map option only *\/$/;"	m	struct:__anon20
hasfv	HTKLib/HTrain.h	/^   Boolean hasfv;$/;"	m	struct:_SegStoreRec
hashSize	HLMLib/LUtil.h	/^  int hashSize;                \/* hash size - prime number *\/$/;"	m	struct:__anon23
hashTableHeap	HLMLib/LUtil.c	/^static MemHeap hashTableHeap;           \/* heap for hash tables *\/$/;"	v	file:
hashsize	HTKLib/HLM.h	/^   unsigned int hashsize;       \/* Size of hashtab (adjusted by lm counts) *\/$/;"	m	struct:ngramlm
hashsize	HTKLib/HRNLM.h	/^    unsigned int hashsize;$/;"	m	struct:__anon91
hashsizes	HTKTools/HLStats.c	/^static int hashsizes[4]={ 87793, 188281, 715249 };$/;"	v	file:
hashtab	HTKLib/HLM.h	/^   NEntry **hashtab;            \/* Hash table for finding NEntries *\/$/;"	m	struct:ngramlm
hashtab	HTKLib/HLabel.c	/^static NameCell *hashtab[HASHSIZE];  \/* the actual table *\/$/;"	v	file:
hasvq	HTKLib/HTrain.h	/^   Boolean hasvq;$/;"	m	struct:_SegStoreRec
haudio_vc_id	HTKLib/HAudio.c	/^char *haudio_vc_id = "$Id: HAudio.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
haudio_version	HTKLib/HAudio.c	/^char *haudio_version = "!HVER!HAudio:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hbuild_vc_id	HTKTools/HBuild.c	/^char *hbuild_vc_id = "$Id: HBuild.c,v 1.1.1.1 2006\/10\/11 09:54:59 jal58 Exp $";$/;"	v
hbuild_version	HTKTools/HBuild.c	/^char *hbuild_version = "!HVER!HBuild:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hcompv_vc_id	HTKTools/HCompV.c	/^char *hcompv_vc_id = "$Id: HCompV.c,v 1.1.1.1 2006\/10\/11 09:54:59 jal58 Exp $";$/;"	v
hcompv_version	HTKTools/HCompV.c	/^char *hcompv_version = "!HVER!HCompV:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hcopy_vc_id	HTKTools/HCopy.c	/^char *hcopy_vc_id = "$Id: HCopy.c,v 1.1.1.1 2006\/10\/11 09:54:59 jal58 Exp $";$/;"	v
hcopy_version	HTKTools/HCopy.c	/^char *hcopy_version = "!HVER!HCopy:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hcrit	HTKTools/HMMIRest.c	/^static float hcrit = 1.0; \/* Scale on denominator (MMI) part. Not really useful.  *\/$/;"	v	file:
hd	HTKLib/HTrain.h	/^   IBLink hd;        \/* head of list of item blocks *\/$/;"	m	struct:__anon108
hdict_vc_id	HTKLib/HDict.c	/^char *hdict_vc_id = "$Id: HDict.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hdict_version	HTKLib/HDict.c	/^char *hdict_version = "!HVER!HDict:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hdman_vc_id	HTKTools/HDMan.c	/^char *hdman_vc_id = "$Id: HDMan.c,v 1.2 2006\/12\/07 11:09:08 mjfg Exp $";$/;"	v
hdman_version	HTKTools/HDMan.c	/^char *hdman_version = "!HVER!HDMan:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hdrField	HLMLib/LUtil.c	/^typedef struct hdrField{$/;"	s	file:
hdrSize	HTKLib/HWave.c	/^   int  hdrSize;        \/* Header size in bytes *\/$/;"	m	struct:_Wave	file:
hdrSize	HTKLib/HWave.c	/^   short hdrSize;    \/* should be 1336 *\/$/;"	m	struct:__anon102	file:
hdrSize	HTKLib/HWave.c	/^   short hdrSize;$/;"	m	struct:__anon100	file:
hdrSize	HTKLib/HWave.c	/^   short hdrSize;$/;"	m	struct:__anon101	file:
hdrless	HLMLib/LCMap.h	/^   Boolean hdrless;	     	\/* if true, nentries is size of unk class *\/$/;"	m	struct:__anon21
head	HLMLib/LGBase.h	/^   GramFile head;          \/* dummy head of tree *\/$/;"	m	struct:__anon5
head	HLMTools/LGPrep.c	/^   RuleDef * head;            \/* head of list of rules *\/$/;"	m	struct:__anon28	file:
head	HTKLib/HLabel.h	/^   LLink head;              \/* Pointer to head of List *\/$/;"	m	struct:_LabList
head	HTKLib/HLabel.h	/^   LabList *head;          \/* Pointer to head of Label List *\/$/;"	m	struct:__anon116
head	HTKLib/HRec.c	/^   NetInst head;            \/* Head (oldest) of Inst linked list *\/$/;"	m	struct:precinfo	file:
headSkip	HTKTools/HDMan.c	/^   int headSkip;                \/* num header lines to skip on input *\/$/;"	m	struct:__anon162	file:
headac	HTKLib/HAdapt.c	/^static AccCache *headac = NULL;$/;"	v	file:
headboc	HTKLib/HAdapt.c	/^static ObsCache *headboc = NULL; $/;"	v	file:
headerPrinted	HTKTools/HResults.c	/^static Boolean headerPrinted = FALSE;  \/* delay header as long as poss *\/$/;"	v	file:
headpoc	HTKLib/HAdapt.c	/^static ObsCache *headpoc = NULL; $/;"	v	file:
heap	HLMLib/LModel.h	/^   MemHeap *heap;            \/* heap for storage *\/$/;"	m	struct:__anon16
heap	HTKLib/HDict.h	/^   MemHeap heap;        \/* storage for dictionary *\/$/;"	m	struct:__anon74
heap	HTKLib/HLM.h	/^   MemHeap *heap ;$/;"	m	struct:__anon124
heap	HTKLib/HLM.h	/^   MemHeap *heap;               \/* Heap for allocating lm structs *\/$/;"	m	struct:lmodel
heap	HTKLib/HLM.h	/^   MemHeap *heap;               \/* Pointer to heap *\/$/;"	m	struct:intpltlm
heap	HTKLib/HLM.h	/^   MemHeap *heap;               \/* Pointer to heap *\/$/;"	m	struct:matbilm
heap	HTKLib/HLM.h	/^   MemHeap *heap;               \/* Pointer to heap *\/$/;"	m	struct:mlplm
heap	HTKLib/HLM.h	/^   MemHeap *heap;               \/* Pointer to heap *\/$/;"	m	struct:ngramlm
heap	HTKLib/HMem.c	/^   MemHeap *heap;$/;"	m	struct:_MemHeapRec	file:
heap	HTKLib/HMem.h	/^   BlockP heap;         \/*               linked list of blocks            *\/$/;"	m	struct:__anon73
heap	HTKLib/HNet.h	/^   MemHeap *heap;               \/* Heap lattice uses *\/$/;"	m	struct:lattice
heap	HTKLib/HNet.h	/^   MemHeap *heap;     \/* heap for allocating network *\/$/;"	m	struct:__anon128
heap	HTKLib/HRec.c	/^   MemHeap heap;            \/* Memory for this set of pre-comps *\/$/;"	m	struct:psetinfo	file:
heap	HTKLib/HRec.h	/^   MemHeap heap;            \/* General storage CHEAP (inc vri) *\/$/;"	m	struct:vrecinfo
heapList	HTKLib/HMem.c	/^static MemHeapRec *heapList = NULL;$/;"	v	file:
herest_vc_id	HTKTools/HERest.c	/^char *herest_vc_id = "$Id: HERest.c,v 1.2 2006\/12\/07 11:09:08 mjfg Exp $";$/;"	v
herest_version	HTKTools/HERest.c	/^char *herest_version = "!HVER!HERest:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hexactmpe_vc_id	HTKLib/HExactMPE.c	/^char *hexactmpe_vc_id = "$Id: HExactMPE.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hexactmpe_version	HTKLib/HExactMPE.c	/^char *hexactmpe_version = "!HVER!HExactMPE:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hfb_vc_id	HTKLib/HFB.c	/^char *hfb_vc_id = "$Id: HFB.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hfb_version	HTKLib/HFB.c	/^char *hfb_version = "!HVER!HFB:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hfblat_vc_id	HTKLib/HFBLat.c	/^char *hfblat_vc_id = "$Id: HFBLat.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hfblat_version	HTKLib/HFBLat.c	/^char *hfblat_version = "!HVER!HFBLat:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hfwdbkwd_totalProbScale	HTKLib/HFBLat.c	/^float hfwdbkwd_totalProbScale = 1.0;          \/* (not a config.) Product of all scales affecting lm likelihoods.   Also read in HFBExactMPE.c and possibly$/;"	v
hgraf_vc_id	HTKLib/HGraf.c	/^char *hgraf_vc_id = "$Id: HGraf.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hgraf_vc_id	HTKLib/HGraf.null.c	/^char *hgraf_vc_id = "$Id: HGraf.null.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hgraf_vc_id	HTKLib/HGraf_WIN32.c	/^char *hgraf_vc_id = "$Id: HGraf_WIN32.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hgraf_version	HTKLib/HGraf.c	/^char *hgraf_version = "!HVER!HGraf(X):   3.4.1 [CUED 12\/03\/09]";$/;"	v
hgraf_version	HTKLib/HGraf.null.c	/^char *hgraf_version = "!HVER!HGraf(null):   3.4.1 [CUED 12\/03\/09]";$/;"	v
hgraf_version	HTKLib/HGraf_WIN32.c	/^char *hgraf_version = "!HVER!HGraf(NT):   3.4.1 [CUED 12\/03\/09]";$/;"	v
hhed_vc_id	HTKTools/HHEd.c	/^char *hhed_vc_id = "$Id: HHEd.c,v 1.2 2006\/12\/07 11:09:08 mjfg Exp $";$/;"	v
hhed_version	HTKTools/HHEd.c	/^char *hhed_version = "!HVER!HHEd:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hiFBankFreq	HTKLib/HParm.c	/^   float hiFBankFreq;         \/* Fbank hi frequency cut-off *\/$/;"	m	struct:__anon76	file:
highDiff	HTKLib/HParm.c	/^static Boolean highDiff = FALSE;   \/* compute higher oder differentials, only up to fourth *\/$/;"	v	file:
hinit_vc_id	HTKTools/HInit.c	/^char *hinit_vc_id = "$Id: HInit.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hinit_version	HTKTools/HInit.c	/^char *hinit_version = "!HVER!HInit:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hints	HTKLib/HGraf.c	/^static XSizeHints    hints;$/;"	v	file:
history	HTKLib/HRNLM.h	/^    int history[MAX_NGRAM_ORDER];$/;"	m	struct:_RNNLM
history	HTKTools/HParse.c	/^   Link history;     \/* used for word pronunciation expansion *\/$/;"	m	struct:_NodeInfo	file:
hists	HTKLib/HRNLM.c	/^static Vector hists, mean, pmean, pvar, var;$/;"	v	file:
hit	HTKTools/HResults.c	/^   Boolean hit;                 \/* true if real occurrence *\/$/;"	m	struct:_SpotRec	file:
hit	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Cell	file:
hit	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Spkr	file:
hits	HTKTools/HResults.c	/^static long hits  = 0;     \/* Total hits *\/$/;"	v	file:
hlabel_vc_id	HTKLib/HLabel.c	/^char *hlabel_vc_id = "$Id: HLabel.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hlabel_version	HTKLib/HLabel.c	/^char *hlabel_version = "!HVER!HLabel:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hlat_vc_id	HTKLib/HLat.c	/^char *hlat_vc_id = "$Id: HLat.c,v 1.2 2006\/12\/07 11:09:08 mjfg Exp $";$/;"	v
hlat_version	HTKLib/HLat.c	/^char *hlat_version = "!HVER!HLat:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hled_vc_id	HTKTools/HLEd.c	/^char *hled_vc_id = "$Id: HLEd.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hled_version	HTKTools/HLEd.c	/^char *hled_version = "!HVER!HLEd:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hlib	HTKLib/Makefile	/^hlib = .$/;"	m
hlist_vc_id	HTKTools/HList.c	/^char *hlist_vc_id = "$Id: HList.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hlist_version	HTKTools/HList.c	/^char *hlist_version = "!HVER!HList:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hlmModel	HTKLib/HLM.h	/^      void *hlmModel;$/;"	m	union:lmodel::__anon125
hlmModel	HTKLib/HLM.h	/^typedef enum { boNGram=1, matBigram, mlpLM, intpltLM, rnnLM, hlmModel } LMType;$/;"	e	enum:__anon123
hlm_vc_id	HTKLib/HLM.c	/^char *hlm_vc_id = "$Id: HLM.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hlm_version	HTKLib/HLM.c	/^char *hlm_version = "!HVER!HLM:   3.4 [CUED 25\/04\/06]";$/;"	v
hlmfiles	HTKBook/htkbook-pdf.tex	/^\\include{hlmtutorial}$/;"	i
hlmfiles	HTKBook/htkbook.tex	/^\\include{hlmtutorial}$/;"	i
hlmfund	HTKBook/htkbook-pdf.tex	/^\\part{Language Modelling}$/;"	i
hlmfund	HTKBook/htkbook.tex	/^\\part{Language Modelling}$/;"	i
hlmtutorial	HTKBook/htkbook-pdf.tex	/^\\include{hlmfund}$/;"	i
hlmtutorial	HTKBook/htkbook.tex	/^\\include{hlmfund}$/;"	i
hlrescore_vc_id	HTKTools/HLRescore.c	/^char *hlrescore_vc_id = "$Id: HLRescore.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hlrescore_version	HTKTools/HLRescore.c	/^char *hlrescore_version = "!HVER!HLRescore:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hlstats_vc_id	HTKTools/HLStats.c	/^char *hlstats_vc_id = "$Id: HLStats.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hlstats_version	HTKTools/HLStats.c	/^char *hlstats_version = "!HVER!HLStats:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hmap_vc_id	HTKLib/HMap.c	/^char *hmap_vc_id = "$Id: HMap.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hmap_version	HTKLib/HMap.c	/^char *hmap_version = "!HVER!HMap: 3.4.1 [CUED 12\/03\/09]";$/;"	v
hmath_vc_id	HTKLib/HMath.c	/^char *hmath_vc_id = "$Id: HMath.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
hmath_version	HTKLib/HMath.c	/^char *hmath_version = "!HVER!HMath:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hmem	HTKLib/HModel.h	/^   MemHeap *hmem;          \/* memory heap for this HMM Set *\/   $/;"	m	struct:_HMMSet
hmem_vc_id	HTKLib/HMem.c	/^char *hmem_vc_id = "$Id: HMem.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
hmem_version	HTKLib/HMem.c	/^char *hmem_version = "!HVER!HMem:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hmm	HTKLib/HArc.h	/^  HLink hmm; \/*For comparison, to see whether the physical hmm is the same.  Only used (at time of writing) for the exact-time$/;"	m	struct:_Arc
hmm	HTKLib/HArc.h	/^  HLink hmm;$/;"	m	struct:_Acoustic
hmm	HTKLib/HNet.h	/^      HLink  hmm;       \/* HMM (physical) definition *\/$/;"	m	union:_NetNode::__anon127
hmm	HTKLib/HUtil.h	/^   HLink hmm;        \/* -> current hmm *\/$/;"	m	struct:__anon38
hmm	HTKTools/HRest.c	/^static HLink hmm;          \/* link to the hmm itself *\/$/;"	v	file:
hmmDir	HTKTools/HERest.c	/^static char * hmmDir = NULL;     \/* directory to look for hmm def files *\/$/;"	v	file:
hmmDir	HTKTools/HHEd.c	/^static char * hmmDir = NULL;     \/* directory to look for hmm def files *\/$/;"	v	file:
hmmDir	HTKTools/HMMIRest.c	/^static char * hmmDir = NULL;     \/* directory to look for hmm def files *\/$/;"	v	file:
hmmDir	HTKTools/HSmooth.c	/^static char * hmmDir = NULL;     \/* directory to look for hmm def files *\/$/;"	v	file:
hmmDir	HTKTools/HVite.c	/^static char * hmmDir = NULL;      \/* directory to look for hmm def files *\/$/;"	v	file:
hmmExt	HTKTools/HERest.c	/^static char * hmmExt = NULL;     \/* hmm def file extension *\/$/;"	v	file:
hmmExt	HTKTools/HHEd.c	/^static char * hmmExt = NULL;     \/* hmm def file extension *\/$/;"	v	file:
hmmExt	HTKTools/HMMIRest.c	/^static char * hmmExt = NULL;     \/* hmm def file extension *\/$/;"	v	file:
hmmExt	HTKTools/HSmooth.c	/^static char * hmmExt = NULL;     \/* hmm def file extension *\/$/;"	v	file:
hmmExt	HTKTools/HVite.c	/^static char * hmmExt = NULL;      \/* hmm def file extension *\/$/;"	v	file:
hmmHeap	HTKTools/HHEd.c	/^static MemHeap hmmHeap;     \/* Heap holds all hmm related info *\/$/;"	v	file:
hmmId	HTKTools/HCompV.c	/^static LabId  hmmId  = NULL;        \/* id of model *\/$/;"	v	file:
hmmLink	HTKTools/HCompV.c	/^static HLink hmmLink;               \/* Link to the physical HMM *\/$/;"	v	file:
hmmLink	HTKTools/HInit.c	/^static HLink hmmLink;            \/* link to the hmm itself *\/$/;"	v	file:
hmmListFn	HTKTools/HVite.c	/^static char *hmmListFn;           \/* HMMs *\/$/;"	v	file:
hmmName	HTKTools/HHEd.c	/^   char   *hmmName;          \/* Physical hmm name for this component *\/$/;"	m	struct:_CoList	file:
hmmSetId	HTKLib/HModel.h	/^   char *hmmSetId;         \/* identifier for the hmm set *\/$/;"	m	struct:_HMMSet
hmmStack	HTKTools/HERest.c	/^static MemHeap hmmStack;   \/*For Storage of all dynamic structures created...*\/$/;"	v	file:
hmmStack	HTKTools/HMMIRest.c	/^static MemHeap hmmStack;           \/* HMM defs and related structures *\/$/;"	v	file:
hmmStack	HTKTools/HSmooth.c	/^static MemHeap hmmStack;     \/*For Storage of dynamic data structures *\/$/;"	v	file:
hmmfn	HTKTools/HCompV.c	/^static char *hmmfn=NULL;            \/* HMM definition file name *\/$/;"	v	file:
hmmfn	HTKTools/HInit.c	/^static char *hmmfn;                 \/* HMM definition file name (& part dir)*\/$/;"	v	file:
hmmfn	HTKTools/HRest.c	/^static char *hmmfn;              \/* HMM definition file name *\/$/;"	v	file:
hmmirest_vc_id	HTKTools/HMMIRest.c	/^char *hmmirest_vc_id = "$Id: HMMIRest.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hmmirest_version	HTKTools/HMMIRest.c	/^char *hmmirest_version = "!HVER!HMMIRest:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hmms	HTKLib/HNet.h	/^   char *hmms;			\/* MMF file name (NULL==unknown) *\/$/;"	m	struct:lattice
hmmsetcxtinfo	HTKLib/HNet.h	/^typedef struct hmmsetcxtinfo {$/;"	s
hmodel_vc_id	HTKLib/HModel.c	/^char *hmodel_vc_id = "$Id: HModel.c,v 1.2 2006\/12\/07 11:09:08 mjfg Exp $";$/;"	v
hmodel_version	HTKLib/HModel.c	/^char *hmodel_version = "!HVER!HModel:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hnet_vc_id	HTKLib/HNet.c	/^char *hnet_vc_id = "$Id: HNet.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
hnet_version	HTKLib/HNet.c	/^char *hnet_version = "!HVER!HNet:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hnlm_vc_id	HTKLib/HNLM.c	/^char *hnlm_vc_id = "$Id: HNLM.c,v 1.1.1.1 2006\/10\/11 09:54:57 jhp33 Exp $";$/;"	v
hnlm_version	HTKLib/HNLM.c	/^char *hnlm_version = "!HVER!HNLM:   3.4 [CUED 25\/04\/06]";$/;"	v
hook	HTKLib/HModel.h	/^   Ptr hook;               \/* general hook *\/$/;"	m	struct:__anon64
hook	HTKLib/HModel.h	/^   Ptr hook;            \/* general hook *\/$/;"	m	struct:__anon56
hook	HTKLib/HModel.h	/^   Ptr hook;            \/* general hook *\/$/;"	m	struct:__anon61
hook	HTKLib/HModel.h	/^   Ptr hook;            \/* general hook *\/$/;"	m	struct:__anon62
hook	HTKLib/HNet.h	/^   Ptr hook;                    \/* User definable hook *\/$/;"	m	struct:lattice
hook	HTKLib/HNet.h	/^   Ptr hook;           \/* User definable hook *\/$/;"	m	struct:lnode
hparmBin	HTKLib/HParm.c	/^static Boolean hparmBin=TRUE; \/* HTK format files are binary *\/$/;"	v	file:
hparm_vc_id	HTKLib/HParm.c	/^char *hparm_vc_id = "$Id: HParm.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
hparm_version	HTKLib/HParm.c	/^char *hparm_version = "!HVER!HParm:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hparmsrcdef	HTKLib/HParm.c	/^typedef struct hparmsrcdef {$/;"	s	file:
hparse_vc_id	HTKTools/HParse.c	/^char *hparse_vc_id = "$Id: HParse.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hparse_version	HTKTools/HParse.c	/^char *hparse_version = "!HVER!HParse:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hquant_vc_id	HTKTools/HQuant.c	/^char *hquant_vc_id = "$Id: HQuant.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hquant_version	HTKTools/HQuant.c	/^char *hquant_version = "!HVER!HQuant:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hrec_vc_id	HTKLib/HRec.c	/^char *hrec_vc_id = "$Id: HRec.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
hrec_version	HTKLib/HRec.c	/^char *hrec_version = "!HVER!HRec:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hrest_vc_id	HTKTools/HRest.c	/^char *hrest_vc_id = "$Id: HRest.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hrest_version	HTKTools/HRest.c	/^char *hrest_version = "!HVER!HRest:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hresults_vc_id	HTKTools/HResults.c	/^char *hresults_vc_id = "$Id: HResults.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hresults_version	HTKTools/HResults.c	/^char *hresults_version = "!HVER!HResults:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hrnlm_vc_id	HTKLib/HRNLM.c	/^char *hrnlm_vc_id = "$Id: HRNLM.c,v 1.1.1.1 2013\/06\/30 09:54:57 yw293 Exp $";$/;"	v
hrnlm_version	HTKLib/HRNLM.c	/^char *hrnlm_version = "!HVER!RHNLM:   3.4 [CUED 06\/30\/13]";$/;"	v
hsKind	HTKLib/HFB.h	/^  HSetKind hsKind;    \/* kind of the alignment HMM system *\/$/;"	m	struct:__anon139
hsKind	HTKLib/HFBLat.h	/^  HSetKind hsKind;              \/* kind of the alignment HMM system *\/$/;"	m	struct:__anon54
hsKind	HTKLib/HModel.h	/^   HSetKind hsKind;        \/* kind of HMM set *\/$/;"	m	struct:_HMMSet
hsKind	HTKTools/HMMIRest.c	/^static HSetKind hsKind;          \/* kind of the HMM system *\/ \/*!Must be PLAINHS | SHAREDHS (|TIEDHS?) *\/$/;"	v	file:
hsKind	HTKTools/HRest.c	/^static HSetKind hsKind;          \/* kind of the HMM system *\/$/;"	v	file:
hsKind	HTKTools/HSmooth.c	/^static HSetKind hsKind;          \/* kind of loaded hmm set *\/$/;"	v	file:
hset	HTKLib/HFBLat.h	/^  HMMSet *hset;$/;"	m	struct:__anon54
hset	HTKLib/HModel.h	/^  struct _HMMSet *hset;                     \/* transform is linked with a model set *\/$/;"	m	struct:_AdaptXForm	typeref:struct:_AdaptXForm::_HMMSet
hset	HTKLib/HNet.h	/^   HMMSet *hset;   \/* HMMSet *\/$/;"	m	struct:hmmsetcxtinfo
hset	HTKLib/HParm.c	/^static HMMSet *hset = NULL;        \/* hmmset to be used for frontend *\/$/;"	v	file:
hset	HTKLib/HRec.c	/^   HMMSet *hset;            \/* HMM Set for recognition *\/$/;"	m	struct:psetinfo	file:
hset	HTKLib/HUtil.h	/^   HMMSet *hset;     \/* HMM set *\/$/;"	m	struct:__anon38
hset	HTKTools/HCompV.c	/^static HMMSet hset;                 \/* HMM to be initialised with *\/$/;"	v	file:
hset	HTKTools/HHEd.c	/^static HMMSet *hset;       \/* current HMM set *\/$/;"	v	file:
hset	HTKTools/HInit.c	/^static HMMSet hset;              \/* The current unitary hmm set *\/$/;"	v	file:
hset	HTKTools/HMMIRest.c	/^static HMMSet hset;                  \/* Set of HMMs to be re-estimated *\/$/;"	v	file:
hset	HTKTools/HRest.c	/^static HMMSet hset;        \/* The current unitary hmm set *\/$/;"	v	file:
hset	HTKTools/HSmooth.c	/^static HMMSet hset;        \/* Set of HMMs to be re-estimated *\/$/;"	v	file:
hset	HTKTools/HVite.c	/^static HMMSet hset;               \/* the HMM set *\/$/;"	v	file:
hset_prior	HTKTools/HMMIRest.c	/^static HMMSet hset_prior;            \/* Usually uninitialised, except for MMI-MAP\/MPE-MAP *\/$/;"	v	file:
hset_prior_dir	HTKTools/HMMIRest.c	/^static char *hset_prior_dir = NULL;$/;"	v	file:
hset_prior_initialised	HTKTools/HMMIRest.c	/^Boolean hset_prior_initialised = FALSE;$/;"	v
hsgen_vc_id	HTKTools/HSGen.c	/^char *hsgen_vc_id = "$Id: HSGen.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hsgen_version	HTKTools/HSGen.c	/^char *hsgen_version = "!HVER!HSGen:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hshell_vc_id	HTKLib/HShell.c	/^char *hshell_vc_id = "$Id: HShell.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
hshell_version	HTKLib/HShell.c	/^char *hshell_version = "!HVER!HShell:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hsigp_vc_id	HTKLib/HSigP.c	/^char *hsigp_vc_id = "$Id: HSigP.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
hsigp_version	HTKLib/HSigP.c	/^char *hsigp_version = "!HVER!HSigP:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hslab_vc_id	HTKTools/HSLab.c	/^char *hslab_vc_id = "$Id: HSLab.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hslab_version	HTKTools/HSLab.c	/^char *hslab_version = "!HVER!HSLab:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hsmooth_vc_id	HTKTools/HSmooth.c	/^char *hsmooth_vc_id = "$Id: HSmooth.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hsmooth_version	HTKTools/HSmooth.c	/^char *hsmooth_version = "!HVER!HSmooth:   3.4.1 [CUED 12\/03\/09]";$/;"	v
htab	HLMLib/LCMap.h	/^   ClassEntry *htab[CLMHASHSIZE];  \/* hash table of ClassEntrys *\/$/;"	m	struct:__anon21
htab	HLMLib/LModel.h	/^   HashTab *htab;            \/* hash table for names *\/$/;"	m	struct:__anon16
htkEsc	HLMLib/LCMap.h	/^   Boolean htkEsc;              \/* has HTK escaping *\/$/;"	m	struct:__anon21
htkEsc	HLMLib/LModel.c	/^static Boolean htkEsc = FALSE;          \/* Don't use HTK quoting and escapes *\/$/;"	v	file:
htkEsc	HLMLib/LWMap.h	/^   Boolean htkEsc;       \/* has HTK escaping *\/$/;"	m	struct:__anon20
htkEscape	HLMTools/LAdapt.c	/^static Boolean htkEscape = TRUE;      \/* string escaping for output word map *\/$/;"	v	file:
htkEscape	HLMTools/LGPrep.c	/^static Boolean htkEscape = TRUE;    \/* default escaping *\/$/;"	v	file:
htkLabelTimeScale	HTKLib/HLabel.c	/^static double htkLabelTimeScale = 1; \/* multiply all times in HTK format labels by this on reading *\/$/;"	v	file:
htkWidth	HTKTools/HResults.c	/^static int  htkWidth  = 66;     \/* width of output banners *\/$/;"	v	file:
htkoview	HTKBook/htkbook-pdf.tex	/^\\include{fundaments}$/;"	i
htkoview	HTKBook/htkbook.tex	/^\\include{fundaments}$/;"	i
htkslf	HTKBook/htkbook-pdf.tex	/^\\include{errors}$/;"	i
htkslf	HTKBook/htkbook.tex	/^\\include{errors}$/;"	i
htool  HDecode	HTKBook/htkoview.tex	/^({\\tt -m} option) with HLRescore.$/;"	b
htool  HLRescore	HTKBook/htkoview.tex	/^to assist with this process.$/;"	b
htool  HVite	HTKBook/htkoview.tex	/^distributed under a more restrictive licence agreement.$/;"	b
htrain_vc_id	HTKLib/HTrain.c	/^char *htrain_vc_id = "$Id: HTrain.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
htrain_version	HTKLib/HTrain.c	/^char *htrain_version = "!HVER!HTrain:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hutil_vc_id	HTKLib/HUtil.c	/^char *hutil_vc_id = "$Id: HUtil.c,v 1.1.1.1 2006\/10\/11 09:54:59 jal58 Exp $";$/;"	v
hutil_version	HTKLib/HUtil.c	/^char *hutil_version = "!HVER!HUtil:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hvite_vc_id	HTKTools/HVite.c	/^char *hvite_vc_id = "$Id: HVite.c,v 1.1.1.1 2006\/10\/11 09:55:02 jal58 Exp $";$/;"	v
hvite_version	HTKTools/HVite.c	/^char *hvite_version = "!HVER!HVite:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hvq_vc_id	HTKLib/HVQ.c	/^char *hvq_vc_id = "$Id: HVQ.c,v 1.1.1.1 2006\/10\/11 09:54:59 jal58 Exp $";$/;"	v
hvq_version	HTKLib/HVQ.c	/^char *hvq_version = "!HVER!HVQ:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hvs	HTKLib/HLM.c	/^static int hvs[]= { 165902236, 220889002, 32510287, 117809592,$/;"	v	file:
hwave_vc_id	HTKLib/HWave.c	/^char *hwave_vc_id = "$Id: HWave.c,v 1.1.1.1 2006\/10\/11 09:54:59 jal58 Exp $";$/;"	v
hwave_version	HTKLib/HWave.c	/^char *hwave_version = "!HVER!HWave:   3.4.1 [CUED 12\/03\/09]";$/;"	v
i	HTKLib/HParm.c	/^      Ptr i;            \/* data for external source *\/$/;"	m	union:_ParmBuf::__anon78	file:
i	HTKLib/HParm.h	/^   Ptr i;                     \/* the other input - if any *\/$/;"	m	struct:__anon122
i	HTKLib/HRNLM.c	/^        int j,i;$/;"	m	struct:__anon130::__anon131	file:
i	HTKLib/HRNLM.h	/^    float *i, *f, *newc, *zi, *fc, *o;  \/* *c *z from GRU layer defination *\/$/;"	m	struct:_Layer
i	HTKLib/HShell.h	/^   int i;$/;"	m	union:__anon86
i	HTKLib/HUtil.h	/^   int i;            \/* current state index 2..N-1 *\/$/;"	m	struct:__anon38
iStack	HTKTools/HCompV.c	/^static MemHeap iStack;$/;"	v	file:
iStack	HTKTools/HCopy.c	/^static MemHeap iStack;          \/* input stack *\/$/;"	v	file:
iStack	HTKTools/HQuant.c	/^static MemHeap iStack;             \/* input buffer  *\/$/;"	v	file:
i_label	HTKLib/HFBLat.c	/^   int i_label;$/;"	m	struct:__anon89	file:
ic	HTKLib/HNet.c	/^   int ic;          \/* Initial context - cache saves finding for all links *\/$/;"	m	struct:pronholder	file:
id	HLMLib/LCMap.h	/^   LabId id;		   \/* name of class id->aux points here *\/$/;"	m	struct:clEntry
id	HLMLib/LModel.h	/^  int    id;                 \/* private ID used for dynamic count lookups *\/$/;"	m	struct:__anon15
id	HLMLib/LWMap.h	/^   LabId    *id;         \/* array[0..used-1] of labid: aux-> MapEntry *\/$/;"	m	struct:__anon20
id	HLMTools/Cluster.c	/^   UInt id;	  \/* Word id *\/$/;"	m	struct:__anon30	file:
id	HTKLib/HArc.h	/^  int id;   \/*numbering from 1..nArcs for arcs which will be used for forward-backward alignment; $/;"	m	struct:_Arc
id	HTKLib/HGraf.h	/^   ButtonId id; $/;"	m	struct:_HButton
id	HTKLib/HLM.h	/^    int id;$/;"	m	struct:lmodel
id	HTKLib/HModel.h	/^   LabId id;               \/* name of macro *\/$/;"	m	struct:_MacroDef
id	HTKLib/HRec.c	/^   int id;                  \/* Unique identifier for current frame *\/$/;"	m	struct:precomp	file:
id	HTKLib/HRec.c	/^   int id;                  \/* Unique observation identifier *\/$/;"	m	struct:precinfo	file:
id	HTKLib/HWave.c	/^   int32 id;          \/* must be 'FORM' *\/$/;"	m	struct:__anon104	file:
id	HTKLib/HWave.c	/^   int32 id;$/;"	m	struct:__anon105	file:
id2string_in	HTKLib/HNLM.c	/^char *id2string_in(NNLM *NNlm, int id)$/;"	f
id2string_out	HTKLib/HNLM.c	/^char *id2string_out(NNLM *NNlm, int id)$/;"	f
id_sort	HLMTools/Cluster.c	/^int id_sort(UInt *in1, UInt *in2)$/;"	f
ident	HTKTools/HParse.c	/^static LabId ident;                 \/* Current identifier, if any *\/$/;"	v	file:
idx	HTKTools/HHEd.c	/^   int idx;                     \/* index of this item *\/$/;"	m	struct:_CRec	file:
ifmt	HTKTools/HLEd.c	/^static FileFormat ifmt=UNDEFF;      \/* Label input file format *\/$/;"	v	file:
ifmt	HTKTools/HLRescore.c	/^static FileFormat ifmt=UNDEFF;  \/* Label input file format *\/$/;"	v	file:
ifmt	HTKTools/HSLab.c	/^static FileFormat ifmt=UNDEFF;      \/* Label input file format *\/$/;"	v	file:
ifmt	HTKTools/HVite.c	/^static FileFormat ifmt=UNDEFF;    \/* Label input file format *\/$/;"	v	file:
ignoreCase	HTKTools/HResults.c	/^static Boolean ignoreCase = FALSE;    \/* true converts labels to upper case *\/$/;"	v	file:
ilang	HTKLib/HLM.h	/^      IntpltLM *ilang;$/;"	m	union:lmodel::__anon125
ilist	HTKLib/HModel.h	/^  ILink *ilist;        \/* 1..numClasses of ilists *\/$/;"	m	struct:__anon65
ilist	HTKTools/HHEd.c	/^   ILink ilist;$/;"	m	struct:_QEnt	file:
imag	HTKLib/esignal.h	/^typedef struct {Schar	real, imag;}	ScharComplex;$/;"	m	struct:__anon50
imag	HTKLib/esignal.h	/^typedef struct {double	real, imag;}	DoubleComplex;$/;"	m	struct:__anon46
imag	HTKLib/esignal.h	/^typedef struct {float	real, imag;}	FloatComplex;$/;"	m	struct:__anon47
imag	HTKLib/esignal.h	/^typedef struct {long	real, imag;}	LongComplex;$/;"	m	struct:__anon48
imag	HTKLib/esignal.h	/^typedef struct {short	real, imag;}	ShortComplex;$/;"	m	struct:__anon49
imagf	HTKLib/HNLM.h	/^    int32 imagf;$/;"	m	struct:matheader
imapFN	HLMTools/LGPrep.c	/^static char *imapFN  = NULL;        \/* input word map filename *\/$/;"	v	file:
imem	HLMTools/Cluster.c	/^static MemHeap      imem;                   \/* memory for input gram file set *\/$/;"	v	file:
imem2	HLMTools/Cluster.c	/^static MemHeap      imem2;                  \/* memory for input gram file set (copy) *\/$/;"	v	file:
immed	HTKLib/HLabel.h	/^   ImmDef immed;     \/* Immediate Definition for MLF_IMMEDIATE *\/$/;"	m	union:__anon118
import_classmap	HLMTools/Cluster.c	/^void import_classmap(char *fname, int numb_words)$/;"	f
in	HTKLib/HParm.c	/^   in;$/;"	m	struct:_ParmBuf	typeref:union:_ParmBuf::__anon78	file:
inBinary	HTKTools/HHEd.c	/^static Boolean inBinary = FALSE; \/* set to save models in binary *\/$/;"	v	file:
inBufPos	HTKLib/HAudio.c	/^   int inBufPos;             \/* Position to write in to buffer *\/$/;"	m	struct:_AudioIn	file:
inCMapRaw	HLMLib/LCMap.c	/^static Boolean inCMapRaw = FALSE;        \/* Read input files in raw mode *\/$/;"	v	file:
inCMapRaw	HLMTools/Cluster.c	/^static Boolean     inCMapRaw = FALSE;       \/* Input classes in raw mode *\/$/;"	v	file:
inCMapRawTrap	HLMTools/Cluster.c	/^static Boolean     inCMapRawTrap = FALSE;   \/* Has this been changed by config file? *\/$/;"	v	file:
inClass	HLMLib/LCMap.h	/^   Boolean inClass;	   \/* "in class" class *\/$/;"	m	struct:clEntry
inConn	HTKLib/HAudio.c	/^   char inConn[30];   $/;"	m	struct:_AudioIn	file:
inOLap	HTKLib/HAudio.c	/^   int inOLap;               \/* num samples in frOLap *\/$/;"	m	struct:_AudioIn	file:
inRow	HTKLib/HParm.c	/^   int inRow;          \/* Absolute row number of next to read (nRows+stRow) *\/$/;"	m	struct:_ParmBuf	file:
inSet	HLMLib/LPCalc.h	/^   NGInputSet   *inSet;               \/* input n-gram file set *\/$/;"	m	struct:__anon2
inSet	HLMTools/LAdapt.c	/^static NGInputSet inSet;             \/* input set of files *\/$/;"	v	file:
inSet	HLMTools/LBuild.c	/^static NGInputSet inSet;$/;"	v	file:
inSet	HLMTools/LFoF.c	/^static NGInputSet inSet;            \/* input file set *\/$/;"	v	file:
inSpkrPat	HTKLib/HAdapt.h	/^  char *inSpkrPat;$/;"	m	struct:__anon37
inWMapRaw	HLMLib/LWMap.c	/^static Boolean inWMapRaw = FALSE;    \/* Read input files in raw mode *\/$/;"	v	file:
inXForm	HTKLib/HAdapt.h	/^  AdaptXForm *inXForm;$/;"	m	struct:__anon37
inXForm	HTKLib/HFB.h	/^  AdaptXForm *inXForm;\/* current input transform (if any) *\/$/;"	m	struct:__anon139
inXForm	HTKLib/HFBLat.h	/^  AdaptXForm *inXForm;\/* current input transform (if any) *\/$/;"	m	struct:__anon54
inXForm	HTKLib/HRec.c	/^static AdaptXForm *inXForm;$/;"	v	file:
inXFormExt	HTKLib/HAdapt.h	/^  char *inXFormExt;$/;"	m	struct:__anon37
in_num_word	HTKLib/HNLM.h	/^   int in_num_word;             \/* Input layer vocab size *\/$/;"	m	struct:nnlm
in_num_word	HTKLib/HRNLM.h	/^    int     in_num_word;            \/*  input vocab size *\/$/;"	m	struct:_RNNLM
in_oos_nodeid	HTKLib/HRNLM.h	/^    int in_oos_nodeid;              \/*  position of oos node in in_vocab *\/$/;"	m	struct:_RNNLM
in_vocab	HTKLib/HRNLM.h	/^    HashTable in_vocab;             \/*  input vocab *\/$/;"	m	struct:_RNNLM
inbuf	HTKTools/HDMan.c	/^static DBuffer inbuf[MAXDICTS];      \/* the input buffers and associated scripts *\/$/;"	v	file:
inc	HTKTools/Makefile	/^inc = ..\/HTKLib$/;"	m
incLab	HTKTools/HSLab.c	/^static Boolean incLab       = FALSE;   \/* increment global label *\/$/;"	v	file:
incOutSyms	HTKTools/HDMan.c	/^static Boolean incOutSyms = FALSE;   \/* write out extra field *\/$/;"	v	file:
incProbs	HTKTools/HDMan.c	/^static Boolean incProbs = FALSE;     \/* write out extra field *\/$/;"	v	file:
incSpaces	HTKLib/HLabel.c	/^static Boolean incSpaces;$/;"	v	file:
includedir	HTKLib/Makefile	/^includedir = ${prefix}\/include$/;"	m
includedir	HTKTools/Makefile	/^includedir = ${prefix}\/include$/;"	m
indent	HTKLib/esignal.h	/^    int     indent;$/;"	m	struct:Annot
independent	HTKLib/HRNLM.h	/^    int independent;$/;"	m	struct:_RNNLM
index	HTKLib/HAudio.c	/^   int index;             \/* Index of buffer *\/$/;"	m	struct:mmapibuf	file:
index	HTKLib/HModel.h	/^   short index;          \/* mixture index *\/$/;"	m	struct:__anon59
index	HTKLib/HNLM.h	/^    int *index;$/;"	m	struct:string2indexmap
indexSet	HTKLib/HModel.c	/^static Boolean indexSet = FALSE;        \/* have the indexes been set for the model set *\/$/;"	v	file:
indx	HTKLib/HTrain.h	/^   int indx;$/;"	m	struct:__anon115
info	HLMLib/LGBase.h	/^   NGInfo info;             \/* ngram size information *\/$/;"	m	struct:__anon4
info	HLMLib/LGBase.h	/^   NGInfo info;            \/* N-gram size and related byte sizes *\/$/;"	m	struct:__anon6
info	HTKLib/HModel.h	/^   Ptr info;            \/* hook to hang information from *\/$/;"	m	struct:__anon56
info	HTKLib/HModel.h	/^   StateInfo *info;     \/* information for this state *\/$/;"	m	struct:__anon63
info	HTKLib/HModel.h	/^  Ptr info;                 \/* hook to hang information from *\/$/;"	m	struct:_RegNode
info	HTKLib/HModel.h	/^  XFormAccInfo *info;               \/* information abbout the accumulates for this transform *\/$/;"	m	struct:_AdaptXForm
info	HTKLib/HNet.h	/^   info;                \/* Extra information specific to type of node *\/$/;"	m	struct:_NetNode	typeref:union:_NetNode::__anon127
info	HTKLib/HWave.c	/^   char info[4];  $/;"	m	struct:__anon103	file:
info	HTKTools/HQuant.c	/^static BufferInfo info;             \/* global observation format, etc. *\/$/;"	v	file:
infoPrinted	HTKLib/HShell.c	/^static Boolean infoPrinted = FALSE;      \/* set when -A -B or -V is used *\/$/;"	v	file:
infoStack	HTKLib/HAdapt.c	/^static MemHeap infoStack;$/;"	v	file:
infodir	HTKLib/Makefile	/^infodir = ${prefix}\/share\/info$/;"	m
infodir	HTKTools/Makefile	/^infodir = ${prefix}\/share\/info$/;"	m
initNet	HTKLib/HRNLM.c	/^static void initNet(RNNLM* rnnlm)$/;"	f	file:
initNuisanceFR	HTKLib/HAdapt.c	/^static Boolean initNuisanceFR = TRUE;$/;"	v	file:
initNuisanceFRIdent	HTKLib/HAdapt.c	/^static Boolean initNuisanceFRIdent = FALSE;$/;"	v	file:
initial	HTKLib/HNet.h	/^   NetNode initial;   \/* Initial (dummy) node *\/$/;"	m	struct:__anon128
initial_bigram_buffer	HLMTools/Cluster.c	73;"	d	file:
initial_cluster	HLMTools/Cluster.c	/^void initial_cluster(void)$/;"	f
inlyne	HTKTools/HParse.c	/^static char inlyne[SCANBUFMAX+1];   \/* (Portion of) current input line *\/$/;"	v	file:
inmap	HTKLib/HNLM.h	/^   String2IndexMap inmap;	\/* Input String to Index Map *\/$/;"	m	struct:nnlm
inputContainOOS	HTKLib/HRNLM.c	/^static Boolean inputContainOOS = TRUE;$/;"	v	file:
inputlayersize	HTKLib/HRNLM.h	/^    int num_layer, dim_fea, nclass, inputlayersize, outputlayersize;$/;"	m	struct:_RNNLM
ins	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Cell	file:
ins	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Spkr	file:
ins	HTKTools/HResults.c	/^static long ins   = 0;     \/* Total insertions *\/$/;"	v	file:
insPen	HTKLib/HArc.h	/^  float insPen; $/;"	m	struct:ArcInfoStruct
insPen	HTKTools/HResults.c	/^static const int insPen = 7;$/;"	v	file:
insPenNIST	HTKTools/HResults.c	/^static const int insPenNIST = 3;$/;"	v	file:
inset	HLMTools/Cluster.c	/^static NGInputSet   inset;                  \/* input gram file set *\/$/;"	v	file:
inset	HLMTools/LGCopy.c	/^static NGInputSet inset;            \/* input file set *\/$/;"	v	file:
inset2	HLMTools/Cluster.c	/^static NGInputSet   inset2;                 \/* input gram file set (copy) *\/$/;"	v	file:
inst	HTKLib/HNet.h	/^   NetInst *inst;       \/* Model Instance (if one exists, else NULL) *\/   $/;"	m	struct:_NetNode
instHeap	HTKLib/HRec.c	/^   MemHeap instHeap;        \/* Inst heap *\/$/;"	m	struct:precinfo	file:
int32	HTKLib/HShell.h	/^typedef int int32;$/;"	t
intpltLM	HTKLib/HLM.h	/^typedef enum { boNGram=1, matBigram, mlpLM, intpltLM, rnnLM, hlmModel } LMType;$/;"	e	enum:__anon123
intpltLatGram	HTKLib/HLat.c	/^static Boolean intpltLatGram = FALSE; \/* interpolation between LM and lattice LM *\/$/;"	v	file:
intpltlm	HTKLib/HLM.h	/^typedef struct intpltlm$/;"	s
inv	HTKLib/HMath.h	/^   STriMat inv;         \/* if FULLC or LLTC *\/$/;"	m	union:__anon44
invalid_header	HLMTools/Cluster.c	/^static void invalid_header(void)$/;"	f	file:
inx	HTKLib/HAudio.c	/^   int inx,outx;         \/* in\/out indices - wrap modulo size *\/$/;"	m	struct:__anon53	file:
ioConfName	HTKLib/HParm.c	/^static char * ioConfName[CFGSIZE] = {$/;"	v	file:
io_Win	HTKTools/HSLab.c	/^static RectWin io_Win;       \/* the I\/O window used for messages and inputing strings *\/$/;"	v	file:
iphone	HTKLib/HArc.h	/^  int iphone; \/* (int) correct phone. *\/$/;"	m	struct:_CorrN
ipos	HTKLib/HRec.c	/^   int ipos;                \/* Current inst position *\/$/;"	m	struct:precinfo	file:
ipos	HTKLib/HRec.c	/^   int ipos;$/;"	m	struct:_NetInst	file:
isActive	HTKLib/HAudio.c	/^   AudioDevStatus isActive;  \/* indicates when device active *\/$/;"	m	struct:_AudioIn	file:
isActive	HTKLib/HAudio.c	/^   Boolean isActive;         \/* true when device active *\/$/;"	m	struct:_AudioOut	file:
isActive	HTKLib/HAudio.c	/^   Boolean isActive;     \/* true if in use *\/$/;"	m	struct:__anon53	file:
isAudio	HTKTools/HList.c	/^   Boolean isAudio;$/;"	m	struct:__anon153	file:
isCont	HTKLib/HUtil.h	/^   Boolean isCont;   \/* true PLAINHS or SHAREDHS *\/$/;"	m	struct:__anon38
isLoaded	HTKLib/HModel.h	/^   Boolean isLoaded;       \/* true if contents are loaded *\/$/;"	m	struct:_MMFInfo
isLogging	HTKTools/HDMan.c	/^static Boolean isLogging = FALSE;$/;"	v	file:
isMap	HLMLib/LWMap.h	/^   Boolean isMap;        \/* true if map, false if word list *\/$/;"	m	struct:__anon20
isPipe	HTKLib/HShell.h	/^   Boolean isPipe;      \/* input is a pipe *\/$/;"	m	struct:__anon84
isPipe	HTKLib/HWave.c	/^   Boolean isPipe;      \/* Source is a pipe *\/$/;"	m	struct:_Wave	file:
isPipe	HTKTools/HDMan.c	/^   Boolean isPipe;              \/* dictionary is input thru pipe *\/$/;"	m	struct:__anon162	file:
isProbTableCached	HTKLib/HRNLM.c	/^Boolean isProbTableCached()$/;"	f
isSorted	HLMLib/LWMap.h	/^   Boolean isSorted;     \/* used to avoid redundant sorts *\/$/;"	m	struct:__anon20
isSource	HTKTools/HList.c	/^   Boolean isSource;$/;"	m	struct:__anon153	file:
isTree	HTKLib/HTrain.h	/^   Boolean isTree; \/* true if tree clustered *\/$/;"	m	struct:__anon110
is_nonsil	HTKLib/HFBLat.c	/^   int is_nonsil;  \/* used in SetCorrectnessAsError *\/$/;"	m	struct:__anon89	file:
isbigendian	HTKLib/HNLM.h	/^    int isbigendian;        \/* Big endian?*\/$/;"	m	struct:matinfo
isdouble	HTKLib/HNLM.h	/^    int isdouble;           \/* Double precision?*\/$/;"	m	struct:matinfo
isnan	HTKLib/HMath.h	30;"	d
item	HLMTools/LGPrep.c	/^   LabId item[MAX_ITEMS];     \/* list of words *\/$/;"	m	struct:__anon26	file:
item	HTKLib/HModel.h	/^   Ptr item;         \/* -> to a HMM structure *\/$/;"	m	struct:_ItemRec
item	HTKTools/HHEd.c	/^   ILink item;                  \/* a single item in this cluster (group) *\/$/;"	m	struct:_CRec	file:
itemHeap	HTKLib/HUtil.c	/^static MemHeap itemHeap;$/;"	v	file:
items	HTKLib/HTrain.h	/^   Ptr *items;       \/* array[0..blkSize-1] of items *\/$/;"	m	struct:_ItemBlock
iter	HTKLib/HRNLM.h	/^    int iter;$/;"	m	struct:_RNNLM
j	HTKLib/HRNLM.c	/^        int j,i;$/;"	m	struct:__anon130::__anon131	file:
jMatHeap	HTKTools/HParse.c	/^MemHeap  jMatHeap;$/;"	v
jmCols	HTKTools/HParse.c	/^static int jmRows,jmCols;      \/* size of JoinMatrix *\/$/;"	v	file:
jmRows	HTKTools/HParse.c	/^static int jmRows,jmCols;      \/* size of JoinMatrix *\/$/;"	v	file:
jmat	HTKTools/HParse.c	/^static JoinMatrix jmat;        \/* binary join matrix *\/$/;"	v	file:
joinFloor	HTKTools/HHEd.c	/^static float joinFloor;                \/* join mix weight floor (* MINMIX) *\/$/;"	v	file:
joinHeap	HTKTools/HParse.c	/^MemHeap  joinHeap;$/;"	v
joinSet	HTKTools/HHEd.c	/^static MixtureElem *joinSet;           \/* current join Mix Set *\/$/;"	v	file:
joinSize	HTKTools/HHEd.c	/^static int joinSize=0;                 \/* number of mixes in a joined pdf *\/$/;"	v	file:
k	HTKLib/HParm.c	/^   Vector a,k;        \/* lpc and refc vectors *\/$/;"	m	struct:__anon76	file:
kRange	HLMLib/LModel.h	/^   int kRange;              \/* discounting range *\/$/;"	m	struct:__anon11
kRange	HLMLib/LPCalc.h	/^   int          kRange;               \/* discounting range for Turing-Good scheme *\/$/;"	m	struct:__anon2
keepDistinct	HTKLib/HModel.c	/^static Boolean keepDistinct=FALSE;      \/* keep orphan HMMs distinct *\/$/;"	v	file:
keepXFormDistinct	HTKLib/HAdapt.c	/^static Boolean keepXFormDistinct = TRUE;$/;"	v	file:
key	HTKLib/HRNLM.h	/^    char*   key;$/;"	m	struct:_HashSlot
keyOccs	HTKTools/HResults.c	/^static int *keyOccs;          \/* array[1..kn] of actual keyword occurrences *\/$/;"	v	file:
keymap	HTKLib/HUtil.c	/^static char *keymap[] = {$/;"	v	file:
khi	HTKLib/HSigP.h	/^   int klo,khi;         \/* lopass to hipass cut-off fft indices *\/$/;"	m	struct:__anon129
kind	HTKLib/HShell.h	/^   ConfKind kind;       \/* kind of config param value *\/$/;"	m	struct:__anon87
kind	HTKTools/HList.c	/^   ParmKind kind;$/;"	m	struct:__anon153	file:
klo	HTKLib/HSigP.h	/^   int klo,khi;         \/* lopass to hipass cut-off fft indices *\/$/;"	m	struct:__anon129
knil	HTKLib/HRec.c	/^   Align *knil;         \/* Prev align in list *\/$/;"	m	struct:align	file:
knil	HTKLib/HRec.c	/^   NBestEntry *knil;$/;"	m	struct:nbestentry	file:
knil	HTKLib/HRec.c	/^   struct _NetInst *knil; \/* Doubly linked list of instances, backward *\/$/;"	m	struct:_NetInst	typeref:struct:_NetInst::_NetInst	file:
knil	HTKLib/HRec.h	/^   Path *knil;          \/* Prev path in list *\/$/;"	m	struct:path
ktype	HTKLib/HGraf.h	/^   KeyType ktype;    \/* type of key pressed *\/$/;"	m	struct:__anon96
l	HTKTools/HParse.c	/^   LabId l;$/;"	m	struct:__anon157	file:
l2nId	HLMLib/LPMerge.c	/^   int     **l2nId;          \/* array of LabId -> NameId lookup tables *\/$/;"	m	struct:__anon1	file:
l2nId	HLMTools/LPlex.c	/^static NameId **l2nId;              \/* array of LabId -> NameId lookup tables *\/$/;"	v	file:
lAlign	HTKLib/HNet.h	/^   LAlign *lAlign;     \/* Array[0..nAlign-1] of alignment records *\/$/;"	m	struct:larc
lCountLimit	HTKTools/HLStats.c	/^static int lCountLimit  = -1;       \/* max occurrences to list for lCount *\/$/;"	v	file:
lRef	HTKTools/HResults.c	/^static LabId *lRef,*lTest;$/;"	v	file:
lSize	HTKTools/HLStats.c	/^static int lSize;                \/* Number of logical labels *\/$/;"	v	file:
lStack	HTKTools/HCopy.c	/^static MemHeap lStack;          \/* label i\/o  stack *\/$/;"	v	file:
lTab	HTKTools/HLStats.c	/^static WordInfo *lTab;           \/* Table of logical counts\/durations *\/$/;"	v	file:
lTest	HTKTools/HResults.c	/^static LabId *lRef,*lTest;$/;"	v	file:
la	HTKLib/HLat.c	/^   LArc *la;$/;"	m	struct:_SubLArc	file:
lab	HTKTools/HSLab.c	/^   Label lab;           \/* the label prior to change *\/$/;"	m	struct:__anon147	file:
lab2Lat	HTKTools/HLRescore.c	/^static Boolean lab2Lat = FALSE;     \/* -I *\/$/;"	v	file:
labDir	HTKTools/HCompV.c	/^static char *labDir = NULL;         \/* label file directory *\/$/;"	v	file:
labDir	HTKTools/HCopy.c	/^static char *labDir = NULL;     \/* label file directory *\/$/;"	v	file:
labDir	HTKTools/HERest.c	/^static char * labDir = NULL;     \/* label (transcription) file directory *\/$/;"	v	file:
labDir	HTKTools/HInit.c	/^static char * labDir = NULL;        \/* label file directory *\/$/;"	v	file:
labDir	HTKTools/HQuant.c	/^static char *labDir = NULL;         \/* label file directory *\/$/;"	v	file:
labDir	HTKTools/HRest.c	/^static char * labDir = NULL;     \/* label file directory *\/$/;"	v	file:
labDir	HTKTools/HResults.c	/^static char * labDir    = NULL;       \/* label file directory *\/$/;"	v	file:
labDir	HTKTools/HSLab.c	/^static char *labDir = NULL;                \/* directory for label files *\/$/;"	v	file:
labDir	HTKTools/HVite.c	/^static char * labDir = NULL;      \/* output label file directory *\/$/;"	v	file:
labExt	HTKTools/HCompV.c	/^static char *labExt = "lab";        \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HCopy.c	/^static char *labExt = "lab";    \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HERest.c	/^static char * labExt = "lab";    \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HInit.c	/^static char * labExt = "lab";       \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HQuant.c	/^static char *labExt = "lab";        \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HRest.c	/^static char * labExt = "lab";    \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HResults.c	/^static char * labExt    = "lab";      \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HSLab.c	/^static char *labExt = "lab";               \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HVite.c	/^static char * labExt = "rec";     \/* output label file extension *\/$/;"	v	file:
labF	HTKTools/HCopy.c	/^static Boolean labF=FALSE;      \/* set if we should  process label files too *\/$/;"	v	file:
labFile	HTKTools/HCopy.c	/^static char labFile[255];       \/* current source of trans *\/$/;"	v	file:
labFileMask	HTKTools/HERest.c	/^static char *labFileMask = NULL;$/;"	v	file:
labFileMask	HTKTools/HLRescore.c	/^static char *labFileMask = NULL;$/;"	v	file:
labFileMask	HTKTools/HVite.c	/^static char * labFileMask = NULL; \/* mask for reading lablels (lattices) *\/$/;"	v	file:
labForm	HTKTools/HVite.c	/^static char * labForm = NULL;     \/* output label reformat *\/$/;"	v	file:
labHeap	HTKTools/HLRescore.c	/^static MemHeap labHeap;$/;"	v	file:
labIdStack	HTKTools/HSmooth.c	/^static MemHeap labIdStack;$/;"	v	file:
labInDir	HTKTools/HLRescore.c	/^static char *labInDir = NULL;   \/* Label input dir, set by -L  *\/$/;"	v	file:
labInDir	HTKTools/HVite.c	/^static char * labInDir = NULL;    \/* input network\/label file directory *\/$/;"	v	file:
labInExt	HTKTools/HLRescore.c	/^static char *labInExt = "lab";  \/* Label Extension, set by -X *\/$/;"	v	file:
labInExt	HTKTools/HVite.c	/^static char * labInExt = "lab";   \/* input network\/label file extension *\/$/;"	v	file:
labName	HTKTools/HCopy.c	/^static LabId labName = NULL;    \/* name of label to extract (if set) *\/$/;"	v	file:
labOFileMask	HTKTools/HLRescore.c	/^static char *labOFileMask = NULL;$/;"	v	file:
labOutDir	HTKTools/HLRescore.c	/^static char *labOutDir = NULL;  \/* output label file directory *\/$/;"	v	file:
labOutExt	HTKTools/HLRescore.c	/^static char *labOutExt = "rec"; \/* output label file extension *\/$/;"	v	file:
labOutForm	HTKTools/HLRescore.c	/^static char *labOutForm = NULL; \/* output label format *\/$/;"	v	file:
labRep	HTKTools/HCopy.c	/^static int labRep=1;            \/* repetition of named label *\/$/;"	v	file:
labSet	HTKTools/HSLab.c	/^static int labSet;              \/* the number of the current label list *\/$/;"	v	file:
labStack	HTKTools/HSLab.c	/^static MemHeap labStack;     \/* storage for label objects *\/$/;"	v	file:
labWin1	HTKTools/HSLab.c	/^static RectWin labWin1;      \/* the label window *\/$/;"	v	file:
label	HTKLib/HNet.h	/^   LabId label;       \/* Segment label ('phys_hmm[state]' or 'phys_hmm') *\/$/;"	m	struct:lalign
labelQuote	HTKLib/HLabel.c	/^static char labelQuote = 0;        \/* How do we quote label names *\/$/;"	v	file:
labels	HTKBook/htkbook-pdf.tex	/^\\include{speechio}$/;"	i
labels	HTKBook/htkbook.tex	/^\\include{speechio}$/;"	i
labenidx	HTKTools/HCopy.c	/^static int labenidx=0;          \/* label end index (if set) *\/$/;"	v	file:
labfn	HTKTools/HResults.c	/^static char labfn[255];               \/* lab file name (reference) *\/$/;"	v	file:
labfn	HTKTools/HSLab.c	/^static char labfn[SLEN];                   \/* the label file name *\/$/;"	v	file:
labid	HTKLib/HLabel.h	/^   LabId labid;             \/* primary label id *\/$/;"	m	struct:_Label
labsModified	HTKTools/HSLab.c	/^static Boolean labsModified = FALSE;   \/* tracks any changes made to the labels *\/$/;"	v	file:
labstidx	HTKTools/HCopy.c	/^static int labstidx=0;          \/* label start index (if set) *\/$/;"	v	file:
labstr	HTKTools/HSLab.c	/^static char labstr[LAB_BUF_LEN] = "Speech";$/;"	v	file:
labstr_btn	HTKTools/HSLab.c	/^static HButton *labstr_btn;$/;"	v	file:
ladapt_vc_id	HLMTools/LAdapt.c	/^char *ladapt_vc_id = "$Id: LAdapt.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
ladapt_version	HLMTools/LAdapt.c	/^char *ladapt_version = "!HVER!LAdapt:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lalign	HTKLib/HNet.h	/^typedef struct lalign $/;"	s
lambda	HTKLib/HRNLM.h	/^    real lambda;$/;"	m	struct:_RNNLM
lang	HLMLib/LCMap.h	/^   char *lang;     	     	\/* language *\/$/;"	m	struct:__anon21
lang	HLMLib/LWMap.h	/^   char    *lang;        \/* language *\/$/;"	m	struct:__anon20
langHeap	HLMTools/HLMCopy.c	/^static MemHeap   langHeap;               \/* Stores global stats *\/$/;"	v	file:
langHeap	HLMTools/LAdapt.c	/^static MemHeap langHeap;            \/* memory for NGBuffers and LMs*\/$/;"	v	file:
langHeap	HLMTools/LBuild.c	/^static MemHeap langHeap;            \/* memory for NGBuffers *\/$/;"	v	file:
langHeap	HLMTools/LMerge.c	/^static MemHeap   langHeap;               \/* Stores global stats *\/$/;"	v	file:
langHeap	HLMTools/LNorm.c	/^static MemHeap   langHeap;               \/* Stores global stats *\/$/;"	v	file:
langProbScale	HTKLib/HFBLat.c	/^static float langProbScale = 1.0;             \/* Extra scale on lm probabilities.   Leave this alone for normal usage. *\/$/;"	v	file:
larc	HTKLib/HNet.h	/^typedef struct larc$/;"	s
larc	HTKLib/HRec.c	/^   LArc *larc;$/;"	m	struct:nbestentry	file:
larc_e	HTKLib/HNet.h	/^typedef struct larc_e$/;"	s
larc_s	HTKLib/HNet.h	/^typedef struct larc_s$/;"	s
larcs	HTKLib/HNet.h	/^   LArc *larcs;                 \/* Array of lattice arcs *\/$/;"	m	struct:lattice
lastAccess	HTKLib/HLat.c	/^   int lastAccess;$/;"	m	struct:_LLFInfo	file:
lastCommand	HTKTools/HHEd.c	/^static int lastCommand=0;              \/* index of previous command *\/$/;"	v	file:
lastGram	HLMLib/LGBase.h	/^   LabId lastGram[MAXNG];   \/* last entry in file *\/$/;"	m	struct:__anon4
lastGram	HLMLib/LGBase.h	/^   LabId lastGram[MAXNG];   \/* last entry in file *\/$/;"	m	struct:gramfile
lastP	HTKTools/HInit.c	/^static Vector   thisP,lastP;     \/* Columns of log probabilities *\/$/;"	v	file:
lastRow	HTKLib/HParm.c	/^   int lastRow;        \/*   of final row (if we know it) *\/$/;"	m	struct:_ParmBuf	file:
lastUsed	HLMLib/LWMap.h	/^   int     lastUsed;     \/* last word index *\/$/;"	m	struct:__anon20
lastWpos	HTKTools/HSLab.c	/^static int thisWpos, lastWpos;      \/* the positions of the waveform pointer *\/$/;"	v	file:
last_word	HLMTools/Cluster.c	/^static UInt         last_word;              \/* ID of last word (w,?) read in *\/$/;"	v	file:
lat	HTKLib/HArc.h	/^  Lattice *lat[MAXLATS]; \/*only needed if we are creating an Arc. Array starts from zero.*\/$/;"	m	struct:ArcInfoStruct
lat	HTKLib/HNet.h	/^   struct lattice *lat;     \/* Lattice this refers to (may be shared) *\/$/;"	m	struct:sublatdef	typeref:struct:sublatdef::lattice
lat	HTKTools/HSGen.c	/^static Lattice *lat;    \/* The defining syntax Lattice *\/$/;"	v	file:
latExt	HTKTools/HMMIRest.c	/^static char *latExt    = "lat";$/;"	v	file:
latExt	HTKTools/HVite.c	/^static char * latExt = NULL;      \/* output lattice file extension *\/$/;"	v	file:
latFileMask	HTKTools/HLRescore.c	/^static char *latFileMask = NULL;$/;"	v	file:
latFileMask	HTKTools/HMMIRest.c	/^static char *latFileMask = NULL;$/;"	v	file:
latForm	HTKTools/HVite.c	/^static char * latForm = NULL;     \/* output lattice format *\/$/;"	v	file:
latHeap	HTKTools/HLRescore.c	/^static MemHeap latHeap;$/;"	v	file:
latInDir	HTKTools/HLRescore.c	/^static char *latInDir = NULL;   \/* Lattice input dir, set by -L  *\/$/;"	v	file:
latInExt	HTKTools/HLRescore.c	/^static char *latInExt = "lat";  \/* Lattice Extension, set by -X *\/$/;"	v	file:
latOFileMask	HTKTools/HLRescore.c	/^static char *latOFileMask = NULL;$/;"	v	file:
latOutForm	HTKTools/HLRescore.c	/^static char *latOutForm = NULL; \/* output lattice format *\/$/;"	v	file:
latProbScale	HTKLib/HExactMPE.c	/^static float latProbScale = 1.0; \/* repeat of config also used in HFBLat.c *\/$/;"	v	file:
latProbScale	HTKLib/HFBLat.c	/^static float latProbScale = 1.0; \/*IMPORTANT*\/  \/* Scales the lattice-arc and lm probabilities.  Normally set to e.g. 1\/12 or 1\/15, the inverse$/;"	v	file:
latStack	HTKTools/HMMIRest.c	/^static MemHeap latStack;           \/* Lattices. *\/$/;"	v	file:
lattice	HTKLib/HNet.h	/^typedef struct lattice$/;"	s
lattices	HTKLib/HFBLat.h	/^  ArcInfo lattices; $/;"	m	struct:__anon54
layer0_fea	HTKLib/HRNLM.h	/^    real *layer0_fea, *neu0_ac_fea, *layerN_class, *neuN_ac_class;$/;"	m	struct:_RNNLM
layer0_hist	HTKLib/HRNLM.h	/^    real *layer0_hist, *neu0_ac_hist, **layers, **neu_ac;$/;"	m	struct:_RNNLM
layer0_size	HTKLib/HRNLM.h	/^    int layer0_size;$/;"	m	struct:_RNNLM
layer0_topic_size	HTKLib/HRNLM.h	/^    int layer0_topic_size;$/;"	m	struct:_RNNLM
layer1_size	HTKLib/HRNLM.h	/^    int layer1_size;$/;"	m	struct:_RNNLM
layer1_succ	HTKLib/HRNLM.h	/^    Layer *succlayers, *layer1_succ;$/;"	m	struct:_RNNLM
layer2_size	HTKLib/HRNLM.h	/^    int layer2_size;$/;"	m	struct:_RNNLM
layerN_class	HTKLib/HRNLM.h	/^    real *layer0_fea, *neu0_ac_fea, *layerN_class, *neuN_ac_class;$/;"	m	struct:_RNNLM
layerc_size	HTKLib/HRNLM.h	/^    int layerc_size;$/;"	m	struct:_RNNLM
layers	HTKLib/HRNLM.h	/^    real *layer0_hist, *neu0_ac_hist, **layers, **neu_ac;$/;"	m	struct:_RNNLM
layersizes	HTKLib/HRNLM.h	/^    int *layersizes, *classinfo, *word2class;$/;"	m	struct:_RNNLM
layertypes	HTKLib/HRNLM.h	/^    char layertypes[100][100];$/;"	m	struct:_RNNLM
lbuild_vc_id	HLMTools/LBuild.c	/^char *lbuild_vc_id = "$Id: LBuild.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lbuild_version	HLMTools/LBuild.c	/^char *lbuild_version = "!HVER!LBuild:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lc	HTKLib/HNet.c	/^   NetNode **lc;    \/* Left contexts - linked to word initial models *\/$/;"	m	struct:pronholder	file:
lcmap_vc_id	HLMLib/LCMap.c	/^char *lcmap_vc_id = "$Id: LCMap.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
lcmap_version	HLMLib/LCMap.c	/^char *lcmap_version = "!HVER!LCMap:   3.4.1 [CUED 12\/03\/09]";$/;"	v
ldBinary	HTKLib/HTrain.c	/^static Boolean ldBinary = TRUE;        \/* load\/dump in binary *\/$/;"	v	file:
ldBinary	HTKTools/HERest.c	/^static Boolean ldBinary = TRUE;        \/* load\/dump in binary *\/$/;"	v	file:
ldBinary	HTKTools/HSmooth.c	/^static Boolean ldBinary = TRUE;     \/* load in binary *\/$/;"	v	file:
leaf	HTKTools/HHEd.c	/^   Node *leaf;                  \/* chain of leaf nodes *\/$/;"	m	struct:_Tree	file:
left	HTKLib/HVQ.h	/^   VQNode left,right;   \/* offspring, only right is used in linTree *\/$/;"	m	struct:_VQNodeRec
left	HTKTools/HHEd.c	/^   HLink left,right;            \/* physical names of constituent biphones *\/$/;"	m	struct:__anon166	file:
lenSum	HTKTools/HSGen.c	/^static long lenSum;     \/* total length of all sentences *\/$/;"	v	file:
lendian	HTKLib/HWave.c	/^   int32  lendian;$/;"	m	struct:__anon101	file:
levSplit	HTKTools/HLEd.c	/^static Boolean levSplit = FALSE;    \/* Split levels into lists *\/$/;"	v	file:
levStr	HTKTools/HSLab.c	/^static char levStr[10];      \/* the level button string *\/$/;"	v	file:
lev_btn	HTKTools/HSLab.c	/^static HButton *lev_btn;     \/* the level button *\/$/;"	v	file:
level	HTKLib/HAdapt.c	/^   int level;$/;"	m	struct:_AInfo	file:
lff	HLMTools/LPlex.c	/^static FileFormat lff = UNDEFF;     \/* label file format *\/$/;"	v	file:
lff	HTKTools/HCompV.c	/^static FileFormat lff=UNDEFF;       \/* label file format *\/$/;"	v	file:
lff	HTKTools/HERest.c	/^static FileFormat lff=UNDEFF;       \/* label file format *\/$/;"	v	file:
lff	HTKTools/HInit.c	/^static FileFormat lff=UNDEFF;       \/* label file format *\/$/;"	v	file:
lff	HTKTools/HQuant.c	/^static FileFormat lff=UNDEFF;       \/* label file format *\/$/;"	v	file:
lff	HTKTools/HRest.c	/^static FileFormat lff=UNDEFF;    \/* label file format *\/$/;"	v	file:
lfof_vc_id	HLMTools/LFoF.c	/^char *lfof_vc_id = "$Id: LFoF.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lfof_version	HLMTools/LFoF.c	/^char *lfof_version = "!HVER!LFoF:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lgain	HTKLib/HAudio.c	/^   long lgain;$/;"	m	struct:_AudioIn	file:
lgain	HTKLib/HAudio.c	/^   long lgain;$/;"	m	struct:_AudioOut	file:
lgbase_vc_id	HLMLib/LGBase.c	/^char *lgbase_vc_id = "$Id: LGBase.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
lgbase_version	HLMLib/LGBase.c	/^char *lgbase_version = "!HVER!LGBase:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lgcopy_vc_id	HLMTools/LGCopy.c	/^char *lgcopy_vc_id = "$Id: LGCopy.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lgcopy_version	HLMTools/LGCopy.c	/^char *lgcopy_version = "!HVER!LGCopy:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lglist_vc_id	HLMTools/LGList.c	/^char *lglist_vc_id = "$Id: LGList.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lglist_version	HLMTools/LGList.c	/^char *lglist_version = "!HVER!LGList:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lgprep_vc_id	HLMTools/LGPrep.c	/^char *lgprep_vc_id = "$Id: LGPrep.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lgprep_version	HLMTools/LGPrep.c	/^char *lgprep_version = "!HVER!LGPrep:   3.4.1 [CUED 12\/03\/09]";$/;"	v
libdir	HTKLib/Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libdir	HTKTools/Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libexecdir	HTKLib/Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
libexecdir	HTKTools/Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
lid	HTKLib/HVQ.h	/^   short nid,lid,rid;   \/* used for mapping between mem and ext def *\/$/;"	m	struct:_VQNodeRec
like	HTKLib/HNet.h	/^   LogFloat like;       \/* Transition likelihood *\/$/;"	m	struct:_NetLink
like	HTKLib/HNet.h	/^   LogFloat like;     \/* Total aclike of label (inc trans within + out) *\/$/;"	m	struct:lalign
like	HTKLib/HRec.c	/^   LogDouble like;      \/* Likelihood at boundary *\/$/;"	m	struct:nxtpath	file:
like	HTKLib/HRec.c	/^   LogDouble like;      \/* Likelihood upon entering state\/model end *\/$/;"	m	struct:align	file:
like	HTKLib/HRec.c	/^   LogFloat like;       \/* Relative Likelihood of token *\/$/;"	m	struct:reltoken	file:
like	HTKLib/HRec.c	/^   double like;$/;"	m	struct:nbestentry	file:
like	HTKLib/HRec.h	/^   LogDouble like;	\/* Likelihood of token *\/$/;"	m	struct:token
like	HTKLib/HRec.h	/^   LogDouble like;      \/* Likelihood at boundary *\/$/;"	m	struct:path
linTree	HTKLib/HVQ.h	/^   linTree,    \/* linear flat codebook (right branching tree) *\/$/;"	e	enum:__anon35
lineIn	HTKLib/HAudio.c	/^static Boolean lineIn = TRUE;$/;"	v	file:
lineOut	HTKLib/HAudio.c	/^static Boolean lineOut = TRUE;$/;"	v	file:
link	HTKLib/HLM.h	/^   struct nentry *link;         \/* Next entry in hash table *\/$/;"	m	struct:nentry	typeref:struct:nentry::nentry
link	HTKLib/HRec.c	/^   Align *link;         \/* Next align in list *\/$/;"	m	struct:align	file:
link	HTKLib/HRec.c	/^   NBestEntry *link;$/;"	m	struct:nbestentry	file:
link	HTKLib/HRec.c	/^   struct _NetInst *link; \/* Doubly linked list of instances, forward *\/$/;"	m	struct:_NetInst	typeref:struct:_NetInst::_NetInst	file:
link	HTKLib/HRec.h	/^   Path *link;          \/* Next path in list *\/$/;"	m	struct:path
link	HTKTools/HLStats.c	/^   struct aentry *link;          \/* Next entry in hash table *\/$/;"	m	struct:aentry	typeref:struct:aentry::aentry	file:
linkHeap	HTKLib/HNet.h	/^   MemHeap linkHeap;  \/* a stack for adding the links as needed *\/$/;"	m	struct:__anon128
links	HTKLib/HNet.h	/^   NetLink *links;      \/* Array[0..nlinks-1] of links to connected nodes *\/$/;"	m	struct:_NetNode
links	HTKTools/HParse.c	/^   Link *links;      \/* array[1..numLinks]of Link *\/$/;"	m	struct:__anon154	file:
list	HLMLib/LUtil.c	/^   struct hdrField *list;$/;"	m	struct:lmFileHdrRec	typeref:struct:lmFileHdrRec::hdrField	file:
list	HTKTools/HHEd.c	/^   CoList *list;             \/* linked list of the mixture components *\/$/;"	m	struct:__anon167	file:
listFile	HTKTools/HLStats.c	/^static char *listFile   = NULL;     \/* file for label list *\/$/;"	v	file:
lit	HTKLib/HGraf.h	/^   Boolean lit;               \/* if true, invert colors *\/$/;"	m	struct:_HButton
llfExt	HTKLib/HLat.c	/^static char *llfExt = "LLF";    \/* extension for LLF lattice files *\/$/;"	v	file:
llfHeap	HTKLib/HLat.c	/^static MemHeap llfHeap;$/;"	v	file:
llfInfo	HTKLib/HLat.c	/^static LLFInfo *llfInfo = NULL;$/;"	v	file:
llink_vc_id	HLMTools/LLink.c	/^char *llink_vc_id = "$Id: LLink.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
llink_version	HLMTools/LLink.c	/^char *llink_version = "!HVER!LLink:   3.4.1 [CUED 12\/03\/09]";$/;"	v
llist	HTKTools/HSLab.c	/^static LabList *llist;          \/* the current label list edited *\/$/;"	v	file:
llogp	HTKLib/HRNLM.h	/^    double logp, llogp;$/;"	m	struct:_RNNLM
lm	HLMLib/LPMerge.c	/^   BackOffLM *lm;            \/* target model *\/$/;"	m	struct:__anon1	file:
lm	HLMLib/LPMerge.h	/^   BackOffLM *lm;           \/* the language model *\/$/;"	m	struct:__anon17
lm	HLMTools/HLMCopy.c	/^static BackOffLM *lm;                    \/* the language model *\/$/;"	v	file:
lm	HLMTools/LNorm.c	/^static BackOffLM *lm;                    \/* the language model *\/$/;"	v	file:
lm	HTKLib/HRec.c	/^   LogFloat lm;         \/* LM likelihood of current word *\/$/;"	m	struct:nxtpath	file:
lm	HTKLib/HRec.c	/^   LogFloat lm;         \/* LM likelihood of token *\/$/;"	m	struct:reltoken	file:
lm	HTKLib/HRec.h	/^   LogFloat lm;         \/* LM likelihood of current word *\/$/;"	m	struct:path
lm	HTKLib/HRec.h	/^   LogFloat lm;         \/* LM likelihood of token *\/$/;"	m	struct:token
lm	HTKTools/HLRescore.c	/^static LModel *lm;              \/* LM for expandin lattices *\/$/;"	v	file:
lmCnt	HTKLib/HLM.h	/^typedef unsigned int lmCnt;     \/* Type used by lm to count wds 0..MAX_LMID *\/$/;"	t
lmFile	HTKTools/HLRescore.c	/^static char *lmFile = NULL;     \/* LM filename *\/$/;"	v	file:
lmFileHdrRec	HLMLib/LUtil.c	/^typedef struct lmFileHdrRec {$/;"	s	file:
lmHeap	HTKTools/HLRescore.c	/^static MemHeap lmHeap;$/;"	v	file:
lmId	HTKLib/HLM.h	/^typedef unsigned int lmId;      \/* Type used by lm to id words  1..MAX_LMID *\/$/;"	t
lmInfo	HLMLib/LPMerge.c	/^   LMInfo  *lmInfo;          \/* array of LMs to merge *\/$/;"	m	struct:__anon1	file:
lmInfo	HLMTools/LAdapt.c	/^static LMInfo  lmInfo[MAX_LMODEL];          \/* array of loaded LMs *\/$/;"	v	file:
lmInfo	HLMTools/LMerge.c	/^static LMInfo    lmInfo[MAX_LMODEL];     \/* array of loaded LMs *\/$/;"	v	file:
lmInfo	HLMTools/LPlex.c	/^static LMInfo  lmInfo[MAX_LMODEL];  \/* array of loaded LMs *\/$/;"	v	file:
lmScale	HTKLib/HArc.h	/^  float lmScale; \/*This functions as a prscale (pronunciation$/;"	m	struct:ArcInfoStruct
lmScale	HTKTools/HLRescore.c	/^static double lmScale = 1.0;    \/* LM scale factor *\/$/;"	v	file:
lmScale	HTKTools/HVite.c	/^static double lmScale = 1.0;      \/* bigram and log(1\/NSucc) scale factor *\/$/;"	v	file:
lmerge_vc_id	HLMTools/LMerge.c	/^char *lmerge_vc_id = "$Id: LMerge.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lmerge_version	HLMTools/LMerge.c	/^char *lmerge_version = "!HVER!LMerge:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lmlike	HTKLib/HArc.h	/^  LogFloat lmlike;  \/*This is the lmprob + the prlike [not scaled].*\/$/;"	m	struct:_ArcTrans
lmlike	HTKLib/HNet.h	/^   LogFloat lmlike;    \/* Language model likelihood of word *\/$/;"	m	struct:larc
lmlike	HTKLib/HNet.h	/^   LogFloat lmlike;    \/* Language model likelihood of word *\/$/;"	m	struct:larc_e
lmlike	HTKLib/HNet.h	/^   LogFloat lmlike;$/;"	m	struct:larc_s
lmodel	HTKLib/HLM.h	/^typedef struct lmodel {$/;"	s
lmodel_vc_id	HLMLib/LModel.c	/^char *lmodel_vc_id = "$Id: LModel.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
lmodel_version	HLMLib/LModel.c	/^char *lmodel_version = "!HVER!LModel:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lmpplexacc	HTKLib/HLM.h	/^typedef struct lmpplexacc {$/;"	s
lmprob	HTKLib/HLat.c	/^   LogFloat lmprob;$/;"	m	struct:_SubLArc	file:
lmprob_file	HTKLib/HRNLM.h	/^    char lmprob_file[MAX_STRING];$/;"	m	struct:_RNNLM
lms	HTKLib/HLM.h	/^   Ptr **lms;                   \/* Language models to be interpolated *\/$/;"	m	struct:intpltlm
lmscale	HTKLib/HNet.h	/^   float lmscale;		\/* LM scale factor *\/$/;"	m	struct:lattice
lmstate	HTKLib/HLM.h	/^   Ptr *lmstate;                \/* Full span N-gram cache for full vocab LM states *\/$/;"	m	struct:__anon124
lmstate	HTKLib/HLM.h	/^   Ptr *lmstate;                \/* Full span N-gram cache for full vocab LM states *\/$/;"	m	struct:mlplm
lmstate	HTKLib/HLat.c	/^      LMState lmstate;$/;"	m	union:_SubLNode::__anon45	file:
lmstate_mix	HTKLib/HLat.c	/^   LMState lmstate_mix[MAX_LMODEL];$/;"	m	struct:_SubLNode	file:
lmvec	HLMLib/LModel.h	/^   float *lmvec;             \/* vector for storing vector n-grams *\/$/;"	m	struct:__anon16
ln	HTKLib/HNet.c	/^   LNode *ln;       \/* Node that created this instance *\/$/;"	m	struct:pronholder	file:
lnewmap_vc_id	HLMTools/LNewMap.c	/^char *lnewmap_vc_id = "$Id: LNewMap.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lnewmap_version	HLMTools/LNewMap.c	/^char *lnewmap_version = "!HVER!LNewMap:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lnode	HTKLib/HNet.h	/^typedef struct lnode$/;"	s
lnode	HTKLib/HRec.c	/^   LNode *lnode;$/;"	m	struct:nbestentry	file:
lnodes	HTKLib/HNet.h	/^   LNode *lnodes;               \/* Array of lattice nodes *\/$/;"	m	struct:lattice
lnorm_vc_id	HLMTools/LNorm.c	/^char *lnorm_vc_id = "$Id: LNorm.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lnorm_version	HLMTools/LNorm.c	/^char *lnorm_version = "!HVER!LNorm:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lnum	HTKTools/HSGen.c	/^static Boolean lnum = FALSE;        \/* enable line numbers *\/$/;"	v	file:
loChan	HTKLib/HSigP.h	/^   ShortVec loChan;     \/* array[1..fftN\/2] of loChan index *\/$/;"	m	struct:__anon129
loFBankFreq	HTKLib/HParm.c	/^   float loFBankFreq;         \/* Fbank lo frequency cut-off *\/$/;"	m	struct:__anon76	file:
loWt	HTKLib/HSigP.h	/^   Vector loWt;         \/* array[1..fftN\/2] of loChan weighting *\/$/;"	m	struct:__anon129
loadLabels	HTKTools/HVite.c	/^static Boolean loadLabels = FALSE; \/* Load network for each file *\/$/;"	v	file:
loadNetworks	HTKTools/HVite.c	/^static Boolean loadNetworks = FALSE; \/* Load network for each file *\/$/;"	v	file:
localstatedir	HTKLib/Makefile	/^localstatedir = ${prefix}\/var$/;"	m
localstatedir	HTKTools/Makefile	/^localstatedir = ${prefix}\/var$/;"	m
locc	HTKLib/HArc.h	/^  LogFloat locc;$/;"	m	struct:_Acoustic
locc	HTKLib/HArc.h	/^  LogFloat locc;$/;"	m	struct:_ArcTrans
log2	HTKTools/HLStats.c	626;"	d	file:
logF	HTKTools/HDMan.c	/^static FILE *logF = NULL;            \/* log file if any *\/$/;"	v	file:
logWt	HTKLib/HModel.h	/^   Boolean logWt;       \/* Component weights are stored as Logs *\/$/;"	m	struct:_HMMSet
logbase	HTKLib/HNet.h	/^   float logbase;               \/* base of logarithm for likelihoods in lattice files$/;"	m	struct:lattice
logfile	HLMTools/Cluster.c	/^static FILE       *logfile=NULL;            \/* Log progress to this file *\/$/;"	v	file:
logfile	HTKLib/HShell.c	/^   char logfile[1024];                  \/* logical name *\/$/;"	m	struct:__anon140	file:
logintLatGram	HTKLib/HLat.c	/^static Boolean logintLatGram = FALSE; \/* log-linear interpolation between LM and lattice LM *\/$/;"	v	file:
loglike	HTKLib/HLM.h	/^   double loglike;              \/* accumumalte of log-likelihood *\/$/;"	m	struct:lmpplexacc
lognorm	HTKLib/HRNLM.h	/^    real lognorm;$/;"	m	struct:_RNNLM
lognormconst	HTKLib/HRNLM.h	/^    real cuedversion, reluratio, lognormconst;$/;"	m	struct:_RNNLM
logp	HTKLib/HRNLM.h	/^    double logp, llogp;$/;"	m	struct:_RNNLM
logpp	HLMTools/LPlex.c	/^   double logpp;            \/* accumulated LM score *\/$/;"	m	struct:__anon33	file:
logpp2	HLMTools/LPlex.c	/^   double logpp2;           \/* accumulated logp^2 score *\/$/;"	m	struct:__anon33	file:
lp	HTKLib/HParm.c	/^   Vector as, ac, lp; \/* Auditory, autocorrelation an lp vectors for PLP *\/ $/;"	m	struct:__anon76	file:
lpcOrder	HTKLib/HParm.c	/^   int lpcOrder;              \/* Order of lpc analysis *\/$/;"	m	struct:__anon76	file:
lpcalc_vc_id	HLMLib/LPCalc.c	/^char *lpcalc_vc_id = "$Id: LPCalc.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
lpcalc_version	HLMLib/LPCalc.c	/^char *lpcalc_version = "!HVER!LPCalc:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lplex_vc_id	HLMTools/LPlex.c	/^char *lplex_vc_id = "$Id: LPlex.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lplex_version	HLMTools/LPlex.c	/^char *lplex_version = "!HVER!LPlex:     3.4.1 [CUED 12\/03\/09]";$/;"	v
lpmerge_vc_id	HLMLib/LPMerge.c	/^char *lpmerge_vc_id = "$Id: LPMerge.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
lpmerge_version	HLMLib/LPMerge.c	/^char *lpmerge_version = "!HVER!LPMerge:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lsChunkHeap	HTKTools/HParse.c	/^static MemHeap lsChunkHeap;$/;"	v	file:
lsHeap	HTKTools/HParse.c	/^static MemHeap lsHeap;$/;"	v	file:
lsLargeHeap	HTKTools/HParse.c	/^static MemHeap lsLargeHeap;$/;"	v	file:
lset	HTKTools/HSLab.c	/^   int lset;            \/* label set *\/$/;"	m	struct:__anon147	file:
lsubset_vc_id	HLMTools/LSubset.c	/^char *lsubset_vc_id = "$Id: LSubset.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lsubset_version	HLMTools/LSubset.c	/^char *lsubset_version = "!HVER!LSubset:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lutil_vc_id	HLMLib/LUtil.c	/^char *lutil_vc_id = "$Id: LUtil.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
lutil_version	HLMLib/LUtil.c	/^char *lutil_version = "!HVER!LUtil:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lvobjects	HTKLib/Makefile	/^lvobjects = $(basename HGraf.o).lv.o esig_asc.lv.o \\$/;"	m
lwmap_vc_id	HLMLib/LWMap.c	/^char *lwmap_vc_id = "$Id: LWMap.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
lwmap_version	HLMLib/LWMap.c	/^char *lwmap_version = "!HVER!LWMap:   3.4.1 [CUED 12\/03\/09]";$/;"	v
m	HTKLib/HModel.h	/^   MLink m;                \/* macro def for this structure *\/$/;"	m	struct:_PtrMap
m	HTKLib/HUtil.h	/^   int m;            \/* current mixture index 1..M *\/$/;"	m	struct:__anon38
m	HTKTools/HParse.c	/^   LabId m;$/;"	m	struct:__anon157	file:
mId	HLMLib/LPMerge.c	/^   int     *mId;             \/* map array for speedy FE\/SE copying *\/$/;"	m	struct:__anon1	file:
mIdx	HTKLib/HModel.h	/^   int mIdx;            \/* MixPDF index *\/$/;"	m	struct:__anon56
mInfo	HTKLib/HAdapt.c	/^   MInfo *mInfo;         \/* any original model information *\/$/;"	m	struct:__anon95	file:
mPre	HTKLib/HRec.c	/^   PreComp *mPre;           \/* Array[1..nmp] Shared mixture PreComps *\/$/;"	m	struct:psetinfo	file:
m_sectname	HTKLib/HNLM.c	/^const char *m_sectname[] =$/;"	v
mac	HTKLib/HUtil.h	/^   MLink mac;        \/* current macro *\/$/;"	m	struct:__anon38
macro	HTKTools/HHEd.c	/^   MLink macro;                 \/* macro used for tie *\/$/;"	m	struct:_Node	file:
macroLink	HTKTools/HCompV.c	/^static MLink macroLink;             \/* Link to specific HMM macro *\/$/;"	v	file:
macroLink	HTKTools/HInit.c	/^static MLink macroLink;          \/* Access to macro in HMMSet *\/$/;"	v	file:
macroType	HTKLib/HModel.c	/^   char macroType;      \/* current macro type if sym==MACRO *\/$/;"	m	struct:__anon42	file:
magic	HTKLib/HAudio.c	/^   DWORD magic;             \/* Magic number identifying this instance *\/$/;"	m	struct:_AudioIn	file:
magic	HTKLib/HAudio.c	/^   DWORD magic;             \/* Magic number identifying this instance *\/$/;"	m	struct:_AudioOut	file:
magic	HTKLib/HVQ.h	/^   short magic;         \/* magic num, usually the ParmKind *\/$/;"	m	struct:_VQTabRec
magic	HTKLib/HWave.c	/^   int32 magic;          \/* magic number 0x2e736e64 *\/$/;"	m	struct:__anon103	file:
main	HLMTools/Cluster.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/HLMCopy.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LAdapt.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LBuild.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LFoF.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LGCopy.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LGList.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LGPrep.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LLink.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LMerge.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LNewMap.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LNorm.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LPlex.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LSubset.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKLib/HParm.c	/^   PBlock main;        \/* Main block of data (next points to first block) *\/$/;"	m	struct:_ParmBuf	file:
main	HTKTools/HBuild.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HCompV.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HCopy.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HDMan.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HERest.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HHEd.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HInit.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HLEd.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HLRescore.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HLStats.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HList.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HMMIRest.c	/^int main(int argc, char *argv[]) $/;"	f
main	HTKTools/HParse.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HQuant.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HRest.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HResults.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HSGen.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HSLab.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HSmooth.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HVite.c	/^int main(int argc, char *argv[])$/;"	f
main	config.guess	/^		main()$/;"	f
main	config.guess	/^	main ()$/;"	f
main	config.guess	/^main ()$/;"	f
maintex	HTKBook/Makefile	/^maintex =    htkbook.tex HTK.tex errors.tex hlmtutorial.tex labels.tex      \\$/;"	m
mandir	HTKLib/Makefile	/^mandir = ${prefix}\/share\/man$/;"	m
mandir	HTKTools/Makefile	/^mandir = ${prefix}\/share\/man$/;"	m
mapFN	HLMLib/LPMerge.c	/^   char    *mapFN;           \/* LM symbol map file *\/$/;"	m	struct:__anon1	file:
mapFN	HLMTools/LFoF.c	/^static char       *mapFN = NULL;    \/* word map file name *\/$/;"	v	file:
mapFN	HLMTools/LGCopy.c	/^static char *mapFN   = NULL;        \/* word map file name *\/$/;"	v	file:
mapTau	HTKLib/HMap.c	/^static float mapTau     = 20.0;                \/* Guides the MAP process *\/$/;"	v	file:
mapUpdated	HLMTools/LAdapt.c	/^static Boolean mapUpdated;            \/* used optimise sort\/saving *\/$/;"	v	file:
mapUpdated	HLMTools/LGPrep.c	/^static Boolean mapUpdated;          \/* used optimise sort\/saving *\/$/;"	v	file:
mapWords	HLMTools/LGCopy.c	/^static Boolean mapWords = FALSE;    \/* map words to classes *\/$/;"	v	file:
marginCount	HTKLib/HParm.c	/^   int marginCount;           \/*   of sil around speech to process *\/$/;"	m	struct:__anon76	file:
markA	HTKTools/HSLab.c	/^static int markA, markB;               \/* boundaries of a marked region *\/$/;"	v	file:
markB	HTKTools/HSLab.c	/^static int markA, markB;               \/* boundaries of a marked region *\/$/;"	v	file:
matBiGram	HTKTools/HBuild.c	/^typedef enum {unknown, wordLoop, boBiGram, matBiGram, multiLat, wordPair} BuildType;$/;"	e	enum:__anon163	file:
matBigram	HTKLib/HLM.h	/^typedef enum { boNGram=1, matBigram, mlpLM, intpltLM, rnnLM, hlmModel } LMType;$/;"	e	enum:__anon123
matPK	HTKLib/HParm.c	/^   ParmKind matPK;$/;"	m	struct:__anon76	file:
matTranFN	HTKLib/HParm.h	/^   char *matTranFN;           \/* Matrix transformation name *\/$/;"	m	struct:__anon122
matbi	HTKLib/HLM.h	/^      MatBiLM *matbi;$/;"	m	union:lmodel::__anon125
matbilm	HTKLib/HLM.h	/^typedef struct matbilm {$/;"	s
matheader	HTKLib/HNLM.h	/^typedef struct matheader$/;"	s
matinfo	HTKLib/HNLM.h	/^typedef struct matinfo {$/;"	s
matrixXvector	HTKLib/HRNLM.c	/^static void matrixXvector(struct neuron *dest, struct neuron *srcvec, struct synapse *srcmatrix, int matrix_width, int from, int to, int from2, int to2, int type)$/;"	f	file:
matrixXvector_cuedrnnlm	HTKLib/HRNLM.c	/^static void matrixXvector_cuedrnnlm (real *src, real *wgt, real *dst, int nr, int nc)$/;"	f	file:
matrixXvector_v2	HTKLib/HRNLM.c	/^void matrixXvector_v2 (float *src, float *wgt, float *dst, int nr, int nc)$/;"	f
max	HTKLib/HRec.c	/^   LogFloat max;        \/* Likelihood for pruning of instance *\/$/;"	m	struct:_NetInst	file:
max	HTKLib/HRec.c	/^   int max;                 \/* Max states in HMM set *\/$/;"	m	struct:psetinfo	file:
maxActive	HTKTools/HVite.c	/^static int maxActive = 0;         \/* max active phone instances *\/$/;"	v	file:
maxAlphaBeta	HTKLib/HFB.h	/^  LogDouble maxAlphaBeta;   \/* max alpha\/beta product along beam ridge *\/$/;"	m	struct:__anon137
maxAuxLab	HTKLib/HLabel.h	/^   int maxAuxLab;           \/* max aux labels (default=0) *\/$/;"	m	struct:_LabList
maxBeam	HTKLib/HRec.h	/^   int maxBeam;             \/* Maximum model instance beam *\/$/;"	m	struct:vrecinfo
maxBeamWidth	HTKLib/HFB.h	/^  int maxBeamWidth;         \/* max width of beam in model units *\/$/;"	m	struct:__anon137
maxClndx	HLMLib/LCMap.h	/^   int maxClndx;   	     	\/* highest class index in map *\/$/;"	m	struct:__anon21
maxDur	HTKTools/HLStats.c	/^   float maxDur;                 \/* Max duration *\/$/;"	m	struct:wordinfo	file:
maxElem	HTKLib/HMem.h	/^   size_t maxElem;      \/*  max #elems per block     max #bytes per blk   *\/$/;"	m	struct:__anon73
maxId	HLMLib/LWMap.h	/^   int maxId;            \/* max index (mapped to size-1) *\/$/;"	m	struct:__anon19
maxIter	HTKLib/HTrain.c	/^static int maxIter = 10;               \/* max num cluster iterations *\/$/;"	v	file:
maxIter	HTKTools/HInit.c	/^static int  maxIter  = 20;          \/* max iterations in param estimation *\/$/;"	v	file:
maxIter	HTKTools/HRest.c	/^static int  maxIter  = 20;       \/* max iterations in parameter estimation *\/$/;"	v	file:
maxLLFs	HTKLib/HLat.c	/^static int maxLLFs = 5;$/;"	v	file:
maxLinks	HTKTools/HParse.c	/^   short maxLinks;   \/* max number of links *\/$/;"	m	struct:__anon154	file:
maxM	HTKLib/HFB.h	/^  int maxM;           \/* maximum number of mixtures in hmmset *\/$/;"	m	struct:__anon139
maxM	HTKLib/HMap.c	/^static int maxM;$/;"	v	file:
maxM	HTKTools/HMMIRest.c	/^static int maxM = 0;             \/* max mixtures in any model *\/$/;"	v	file:
maxM	HTKTools/HVite.c	/^static int maxM = 0;              \/* max mixtures in any model *\/$/;"	v	file:
maxMixInS	HTKLib/HFB.h	/^  int maxMixInS[SMAX];\/* array[1..swidth[0]] of max mixes *\/$/;"	m	struct:__anon139
maxMixInS	HTKTools/HInit.c	/^static int maxMixInS[SMAX];      \/* array[1..swidth[0]] of max mixes *\/$/;"	v	file:
maxMixInS	HTKTools/HRest.c	/^static int maxMixInS[SMAX];\/* array[1..swidth[0]] of max mixes *\/$/;"	v	file:
maxMixInS	HTKTools/HVite.c	/^static int maxMixInS[SMAX];       \/* array[1..swidth[0]] of max mixes *\/$/;"	v	file:
maxMixes	HTKLib/HUtil.c	/^static int maxMixes;           \/*  and max number of mix comps *\/$/;"	v	file:
maxMixes	HTKTools/HHEd.c	/^static int maxMixes;       \/* max number of mixes in current HMM set *\/$/;"	v	file:
maxMixes	HTKTools/HRest.c	/^static int maxMixes;       \/* max num mixtures across all streams *\/$/;"	v	file:
maxMixes	HTKTools/HSmooth.c	/^static int maxMixes = 0;         \/* max mixtures in any model *\/$/;"	v	file:
maxNDepth	HTKTools/HResults.c	/^static int maxNDepth=1;               \/* find best of 1..max lists *\/$/;"	v	file:
maxNOpen	HLMLib/LGBase.h	/^   int maxNOpen;           \/* max number of open files *\/$/;"	m	struct:__anon5
maxP	HTKLib/HModel.h	/^   LogFloat maxP;        \/* max log mixture prob *\/$/;"	m	struct:__anon60
maxRows	HTKLib/HParm.c	/^   int maxRows;      \/* total number of rows in this block *\/$/;"	m	struct:pblock	file:
maxSemiTiedIter	HTKLib/HAdapt.c	/^static int maxSemiTiedIter = 10;$/;"	v	file:
maxSpUtt	HTKTools/HERest.c	/^static int maxSpUtt = 0;$/;"	v	file:
maxStates	HTKLib/HUtil.c	/^static int maxStates;          \/*  and its max number of states *\/$/;"	v	file:
maxStates	HTKTools/HHEd.c	/^static int maxStates;      \/* max number of states in current HMM set *\/$/;"	v	file:
maxStates	HTKTools/HSmooth.c	/^static int maxStates = 0;        \/* max states in any model *\/$/;"	v	file:
maxStep	HTKTools/HSmooth.c	/^static int maxStep   = 16;       \/* max number of binary chops *\/$/;"	v	file:
maxT	HTKTools/HRest.c	/^static int maxT,minT,T;    \/* max,min and current segment lengths *\/$/;"	v	file:
maxTry	HTKLib/HShell.c	/^static int maxTry = 1;$/;"	v	file:
maxWordLen	HTKTools/HResults.c	/^static int maxWordLen = 5;$/;"	v	file:
maxXFormIter	HTKLib/HAdapt.c	/^static double maxXFormIter = 10; \/* something big, for CMLLR *\/ $/;"	v	file:
max_likelihood_check	HLMTools/Cluster.c	/^static void max_likelihood_check(void)$/;"	f	file:
max_likelihood_init	HLMTools/Cluster.c	/^static void max_likelihood_init(void)$/;"	f	file:
max_line_len	HLMTools/Cluster.c	1228;"	d	file:
max_words	HLMTools/Cluster.c	/^static int          max_words;              \/* Maximum number of words *\/$/;"	v	file:
maxmin_vf_ff	HTKLib/HNLM.c	/^void maxmin_vf_ff(size_t n, const float *vec, float *maxp, float *minp)$/;"	f
mcols	HTKLib/HNLM.h	/^    int32 mcols;$/;"	m	struct:matheader
me	HLMLib/LWMap.h	/^   MapEntry *me;         \/* array[0..used-1] of mapentry *\/$/;"	m	struct:__anon20
me	HTKLib/HUtil.h	/^   MixtureElem *me;  \/* ->current mixtureElem *\/$/;"	m	struct:__anon38
me_end	HTKLib/HArc.h	/^  HArc *me_start; HArc *me_end;\/* first & last arc. *\/$/;"	m	struct:_CorrN
me_start	HTKLib/HArc.h	/^  HArc *me_start; HArc *me_end;\/* first & last arc. *\/$/;"	m	struct:_CorrN
mean	HTKLib/HAdapt.c	/^   Vector mean;$/;"	m	struct:__anon93	file:
mean	HTKLib/HModel.h	/^   SVector mean;        \/* mean vector *\/$/;"	m	struct:__anon56
mean	HTKLib/HParm.c	/^   Vector mean;       \/* Running mean shared by this config *\/$/;"	m	struct:__anon76	file:
mean	HTKLib/HRNLM.c	/^static Vector hists, mean, pmean, pvar, var;$/;"	v	file:
mean	HTKLib/HVQ.h	/^   Vector mean;         \/* centre of this node *\/$/;"	m	struct:_VQNodeRec
mean	HTKTools/HQuant.c	/^Vector mean[SMAX];                 \/* Global stream mean  *\/$/;"	v
meanGC	HTKTools/HHEd.c	/^static float meanGC,stdGC;             \/* mean and stdev of GConst *\/$/;"	v	file:
meanSum	HTKTools/HCompV.c	/^   Vector       meanSum;            \/* acc for mean vector value *\/$/;"	m	struct:__anon151	file:
meanSum	HTKTools/HCompV.c	/^   Vector meanSum;                       \/* mean accumulate structure for speaker *\/$/;"	m	struct:__anon152	file:
meanUpdate	HTKTools/HCompV.c	/^static Boolean meanUpdate = FALSE;  \/* update means  *\/$/;"	v	file:
meanrec	HTKLib/HParm.c	/^typedef struct meanrec $/;"	s	file:
measureSil	HTKLib/HParm.c	/^   Boolean measureSil;        \/* Measure Silence *\/$/;"	m	struct:__anon76	file:
mem	HLMLib/LCMap.h	/^   MemHeap mem;    	     	\/* memory heap for this class map *\/$/;"	m	struct:__anon21
mem	HLMLib/LGBase.h	/^   MemHeap *mem;           \/* memory stack for this input set *\/$/;"	m	struct:__anon5
mem	HLMLib/LUtil.c	/^   MemHeap *mem;$/;"	m	struct:lmFileHdrRec	file:
mem	HLMLib/LWMap.h	/^   MemHeap mem;          \/* memory heap for this word map *\/$/;"	m	struct:__anon20
mem	HLMTools/LGPrep.c	/^   MemHeap mem;               \/* Memory for this ruleset *\/$/;"	m	struct:__anon28	file:
mem	HTKLib/HArc.h	/^  MemHeap *mem;$/;"	m	struct:ArcInfoStruct
mem	HTKLib/HAudio.c	/^   MemHeap *mem;             \/* memory heap for this audio rec *\/$/;"	m	struct:_AudioIn	file:
mem	HTKLib/HAudio.c	/^   MemHeap *mem;             \/* memory heap for this audio rec *\/$/;"	m	struct:_AudioOut	file:
mem	HTKLib/HModel.h	/^  MemHeap *mem;                     \/* heap used for storing transform *\/$/;"	m	struct:_AdaptXForm
mem	HTKLib/HParm.c	/^   MemHeap *mem;       \/* Memory heap for this parm buf *\/$/;"	m	struct:_ParmBuf	file:
mem	HTKLib/HTrain.h	/^   MemHeap *mem;        \/* memory for this seg store *\/$/;"	m	struct:_SegStoreRec
mem	HTKLib/HTrain.h	/^   MemHeap *mem;     \/* memory stack for this sequence *\/$/;"	m	struct:__anon108
mem	HTKLib/HWave.c	/^   MemHeap *mem;        \/* memory heap for this wave rec *\/$/;"	m	struct:_Wave	file:
memDC	HTKLib/HGraf_WIN32.c	/^static HDC memDC = NULL;          \/* A handle to the memory device context *\/$/;"	v	file:
memStak	HTKTools/HDMan.c	/^static MemHeap memStak;              \/* all storage allocated in this *\/$/;"	v	file:
mergeDir	HTKTools/HLRescore.c	/^static char *mergeDir;          \/* lattice merging direction *\/$/;"	v	file:
mergeLat	HTKTools/HLRescore.c	/^static Boolean mergeLat = FALSE;    \/* -m *\/$/;"	v	file:
mergeProns	HTKTools/HDMan.c	/^static Boolean mergeProns = FALSE;   \/* merge prons from all sources *\/$/;"	v	file:
micIn	HTKLib/HAudio.c	/^static Boolean micIn = FALSE;$/;"	v	file:
minAlphaBeta	HTKLib/HFB.h	/^  LogDouble minAlphaBeta;   \/* min alpha\/beta product along beam ridge *\/$/;"	m	struct:__anon137
minClustSize	HTKLib/HTrain.c	/^static int minClustSize = 3;           \/* min num vectors in cluster *\/$/;"	v	file:
minDur	HTKLib/HTrain.h	/^   int minDur;       \/* Min no of frames to get through trans mat *\/$/;"	m	struct:__anon111
minDur	HTKTools/HLStats.c	/^   float minDur;                 \/* Min duration *\/$/;"	m	struct:wordinfo	file:
minEgs	HTKLib/HMap.c	/^static int minEgs    = 0;        \/* min examples to train a model *\/$/;"	v	file:
minEgs	HTKTools/HERest.c	/^static int minEgs    = 3;        \/* min examples to train a model *\/$/;"	v	file:
minEgs	HTKTools/HSmooth.c	/^static int minEgs    = 3;        \/* min examples to train a model *\/$/;"	v	file:
minElem	HTKLib/HMem.h	/^   size_t minElem;      \/*  init #elems per blk      init #bytes per blk  *\/$/;"	m	struct:__anon73
minFrwdP	HTKLib/HFB.c	/^   float minFrwdP;           \/* mix prune threshold *\/$/;"	m	struct:__anon133	file:
minFrwdP	HTKLib/HFBLat.c	/^static float minFrwdP = 10.0;            \/* mix prune threshold *\/$/;"	v	file:
minFrwdP	HTKTools/HERest.c	/^static float minFrwdP = NOPRUNE;         \/* mix prune threshold *\/$/;"	v	file:
minGap	HTKTools/HLEd.c	/^static HTime minGap = 50000.0;      \/* minimum interword gap *\/$/;"	v	file:
minId	HLMLib/LWMap.h	/^   int minId;            \/* min index (mapped to 0) *\/$/;"	m	struct:__anon19
minLogExp	HTKLib/HMath.c	/^static LogDouble minLogExp;$/;"	v	file:
minObs	HTKLib/HMap.c	/^static float minObs  = 0;        \/* min observations  to train a model *\/$/;"	v	file:
minOccThresh	HTKLib/HAdapt.c	/^static float minOccThresh = 0.0;       \/* minimum occupancy to accumulate stats to estimate xform *\/$/;"	v	file:
minRows	HTKLib/HParm.c	/^   int minRows;        \/* min rows to keep in main block *\/$/;"	m	struct:_ParmBuf	file:
minSeg	HTKTools/HInit.c	/^static int minSeg    = 3;           \/* min segments to train a model *\/$/;"	v	file:
minSeg	HTKTools/HRest.c	/^static int minSeg    = 3;        \/* min segments to train a model *\/$/;"	v	file:
minT	HTKTools/HRest.c	/^static int maxT,minT,T;    \/* max,min and current segment lengths *\/$/;"	v	file:
minVar	HTKLib/HMap.c	/^static float minVar  = 0.0;      \/* minimum variance (diagonal only) *\/$/;"	v	file:
minVar	HTKTools/HCompV.c	/^static float minVar  = 0.0;         \/* minimum variance *\/$/;"	v	file:
minVar	HTKTools/HERest.c	/^static float minVar  = 0.0;      \/* minimum variance (diagonal only) *\/$/;"	v	file:
minVar	HTKTools/HInit.c	/^static float minVar  = 1.0E-2;      \/* minimum variance *\/$/;"	v	file:
minVar	HTKTools/HMMIRest.c	/^static float minVar  = 0.0;      \/* minimum variance (diagonal only). $/;"	v	file:
minVar	HTKTools/HRest.c	/^static float minVar  = 0.0;      \/* minimum variance *\/$/;"	v	file:
minVar	HTKTools/HSmooth.c	/^static float minVar  = 0.0;      \/* minimum variance (diagonal only) *\/$/;"	v	file:
min_improvement	HTKLib/HRNLM.h	/^    float min_improvement;$/;"	m	struct:_RNNLM
minab	HTKLib/HMath.c	685;"	d	file:
minfo	HTKLib/HNLM.h	/^    MatInfo minfo[QN_MAX_SECTIONS];$/;"	m	struct:mlpweightfile
miscStack	HTKLib/HFBLat.h	/^  MemHeap miscStack;$/;"	m	struct:__anon54
mix	HTKTools/HHEd.c	/^   int    mix;               \/* mixture for this component *\/$/;"	m	struct:_CoList	file:
mixId	HTKLib/HModel.h	/^   LabId mixId;          \/* id of macro base name *\/$/;"	m	struct:__anon60
mixShared	HTKLib/HRec.c	/^   Boolean mixShared;$/;"	m	struct:psetinfo	file:
mixWeightFloor	HTKLib/HMap.c	/^static float mixWeightFloor=0.0; \/* Floor for mixture weights *\/$/;"	v	file:
mixWeightFloor	HTKTools/HERest.c	/^static float mixWeightFloor=0.0; \/* Floor for mixture weights *\/$/;"	v	file:
mixWeightFloor	HTKTools/HInit.c	/^static float mixWeightFloor=0.0;    \/*Floor for mixture\/discrete prob weights*\/$/;"	v	file:
mixWeightFloor	HTKTools/HMMIRest.c	/^static float mixWeightFloor=MINMIX*2; \/* Floor for mixture weights *\/$/;"	v	file:
mixWeightFloor	HTKTools/HRest.c	/^static float mixWeightFloor=0.0; \/* Floor for mixture weights *\/$/;"	v	file:
mixWeightFloor	HTKTools/HSmooth.c	/^static float mixWeightFloor=0.0; \/* Floor for mixture weights *\/$/;"	v	file:
mixer_fd	HTKLib/HAudio.c	/^static int mixer_fd;$/;"	v	file:
mixes	HTKLib/HModel.h	/^   MixPDF ** mixes;      \/* array[1..M] of MixPDF *\/$/;"	m	struct:__anon60
mixoutp	HTKTools/HRest.c	/^static Matrix **mixoutp;   \/* array[2..nStates-1][1..maxT][1..nStreams]$/;"	v	file:
ml	HTKTools/HHEd.c	/^   MLink ml;$/;"	m	struct:__anon166	file:
ml_cnt	HTKLib/HParm.c	/^   ml_cnt      \/* Total size of ml results array *\/$/;"	e	enum:__anon79	file:
ml_max	HTKLib/HParm.c	/^   ml_max,     \/* Max frame energy *\/$/;"	e	enum:__anon79	file:
ml_min	HTKLib/HParm.c	/^   ml_min,     \/* Min frame energy *\/$/;"	e	enum:__anon79	file:
ml_off	HTKLib/HParm.c	/^   ml_off,     \/* Average sample offset *\/$/;"	e	enum:__anon79	file:
ml_range	HTKLib/HParm.c	/^   ml_range,   \/* Peak to peak sample range (% of max) *\/$/;"	e	enum:__anon79	file:
ml_sil	HTKLib/HParm.c	/^   ml_sil,     \/* Average silence energy *\/$/;"	e	enum:__anon79	file:
ml_snr	HTKLib/HParm.c	/^   ml_snr,     \/* Assumed SNR ratio *\/$/;"	e	enum:__anon79	file:
ml_sp	HTKLib/HParm.c	/^   ml_sp,      \/* Average speeck energy *\/$/;"	e	enum:__anon79	file:
ml_thresh	HTKLib/HParm.c	/^   ml_thresh,  \/* Threshold for speech detector *\/$/;"	e	enum:__anon79	file:
mlfHead	HTKLib/HLabel.c	/^static MLFEntry *mlfHead = NULL; \/* head of linked list of MLFEntry *\/$/;"	v	file:
mlfHeap	HTKLib/HLabel.c	/^static MemHeap mlfHeap;          \/* memory heap for MLF stuff *\/$/;"	v	file:
mlfTail	HTKLib/HLabel.c	/^static MLFEntry *mlfTail = NULL; \/* tail of linked list of MLFEntry *\/$/;"	v	file:
mlfUsed	HTKLib/HLabel.c	/^static int      mlfUsed = 0;     \/* number of entries in mlfTab *\/$/;"	v	file:
mlfile	HTKLib/HLabel.c	/^static FILE   * mlfile[MAXMLFS]; \/* array [0..numMLFs-1] of MLF file *\/$/;"	v	file:
mllrCov2CMLLR	HTKLib/HAdapt.c	/^static Boolean mllrCov2CMLLR= FALSE;   \/* apply mllrcov transforms as cmllr transform *\/ $/;"	v	file:
mllrCovAdaptKind	HTKLib/HAdapt.c	/^static AdaptKind mllrCovAdaptKind = BASE;$/;"	v	file:
mllrCovBaseClass	HTKLib/HAdapt.c	/^static char *mllrCovBaseClass = NULL;$/;"	v	file:
mllrCovBlockSize	HTKLib/HAdapt.c	/^static IntVec mllrCovBlockSize = NULL;$/;"	v	file:
mllrCovRegTree	HTKLib/HAdapt.c	/^static char *mllrCovRegTree = NULL;$/;"	v	file:
mllrCovSplitThresh	HTKLib/HAdapt.c	/^static float mllrCovSplitThresh = 1000.0;$/;"	v	file:
mllrDiagCov	HTKLib/HAdapt.c	/^static Boolean mllrDiagCov = FALSE;    \/* perform diagonal covariance adaptation *\/$/;"	v	file:
mllrMeanAdaptKind	HTKLib/HAdapt.c	/^static AdaptKind mllrMeanAdaptKind = BASE;$/;"	v	file:
mllrMeanBaseClass	HTKLib/HAdapt.c	/^static char *mllrMeanBaseClass = NULL;$/;"	v	file:
mllrMeanBlockSize	HTKLib/HAdapt.c	/^static IntVec mllrMeanBlockSize = NULL;$/;"	v	file:
mllrMeanRegTree	HTKLib/HAdapt.c	/^static char *mllrMeanRegTree = NULL;$/;"	v	file:
mllrMeanSplitThresh	HTKLib/HAdapt.c	/^static float mllrMeanSplitThresh = 1000.0;$/;"	v	file:
mlp	HTKLib/HLM.h	/^   Ptr *mlp;                    \/* MLP LM *\/$/;"	m	struct:mlplm
mlpInfoStack	HTKLib/HNLM.c	/^static MemHeap mlpInfoStack;       \/* Local stack to for MLP info *\/$/;"	v	file:
mlpLM	HTKLib/HLM.h	/^typedef enum { boNGram=1, matBigram, mlpLM, intpltLM, rnnLM, hlmModel } LMType;$/;"	e	enum:__anon123
mlpLMCacheInfoStack	HTKLib/HLM.c	/^static MemHeap mlpLMCacheInfoStack[10];          \/* Local stack to for MLP cache info *\/$/;"	v	file:
mlpLMStateInfoStack	HTKLib/HLM.c	/^static MemHeap mlpLMStateInfoStack;          \/* Local stack to for MLP LM info *\/$/;"	v	file:
mlp_layer_size	HTKLib/HNLM.c	/^static int mlp_layer_size[4] = {300006,600,400,20001};$/;"	v	file:
mlp_layer_size	HTKLib/HNLM.c	/^static int mlp_layer_size[4] = {300006,600,400,20002};$/;"	v	file:
mlplm	HTKLib/HLM.h	/^      MLPLM *mlplm;$/;"	m	union:lmodel::__anon125
mlplm	HTKLib/HLM.h	/^typedef struct mlplm {$/;"	s
mlpweightfile	HTKLib/HNLM.h	/^typedef struct mlpweightfile {$/;"	s
mlv	HLMTools/Cluster.c	/^static double     *mlv;                     \/* ML values involving class [N] *\/$/;"	v	file:
mmApiBuf	HTKLib/HAudio.c	/^} mmApiBuf;$/;"	t	typeref:struct:mmapibuf	file:
mmError	HTKLib/HAudio.c	/^   MMRESULT mmError;$/;"	m	struct:_AudioIn	file:
mmError	HTKLib/HAudio.c	/^   MMRESULT mmError;$/;"	m	struct:_AudioOut	file:
mmWPos	HTKTools/HSLab.c	/^static int mmWPos;$/;"	v	file:
mmapibuf	HTKLib/HAudio.c	/^typedef struct mmapibuf{$/;"	s	file:
mmeAllocBuffer	HTKLib/HAudio.c	/^void *mmeAllocBuffer(size_t size)$/;"	f
mmeAllocMem	HTKLib/HAudio.c	/^void *mmeAllocMem(size_t size)$/;"	f
mmeCheckForCallbacks	HTKLib/HAudio.c	/^Boolean mmeCheckForCallbacks(void)$/;"	f
mmeFreeBuffer	HTKLib/HAudio.c	/^Boolean mmeFreeBuffer(void *ptr)$/;"	f
mmeFreeMem	HTKLib/HAudio.c	/^Boolean mmeFreeMem(void *ptr)$/;"	f
mmeProcessCallbacks	HTKLib/HAudio.c	/^void mmeProcessCallbacks(void)$/;"	f
mmeWaitForCallbacks	HTKLib/HAudio.c	/^void mmeWaitForCallbacks(void)$/;"	f
mmfFn	HTKTools/HERest.c	/^static char * mmfFn  = NULL;     \/* output MMF file, if any *\/$/;"	v	file:
mmfFn	HTKTools/HHEd.c	/^static char * mmfFn  = NULL;     \/* output MMF file, if any *\/$/;"	v	file:
mmfFn	HTKTools/HMMIRest.c	/^static char * mmfFn  = NULL;     \/* output MMF file, if any *\/$/;"	v	file:
mmfIdMask	HTKLib/HModel.h	/^  char* mmfIdMask;     \/* mask of model sets that appropriate for *\/$/;"	m	struct:__anon65
mmfIdMask	HTKLib/HModel.h	/^  char* mmfIdMask;     \/* mask of model sets that appropriate for *\/$/;"	m	struct:__anon70
mmfIdMask	HTKTools/HHEd.c	/^static char mmfIdMask[MAXSTRLEN] = "*"; \/* MMF Id Mask for baseclass *\/$/;"	v	file:
mmfNames	HTKLib/HModel.h	/^   MILink mmfNames;        \/* List of external file names *\/$/;"	m	struct:_HMMSet
modelHeap	HTKTools/HVite.c	/^static MemHeap modelHeap;$/;"	v	file:
modelName	HTKTools/HParse.c	/^   LabId modelName;  \/* name of node *\/$/;"	m	struct:_Node	file:
models	HTKBook/htkbook-pdf.tex	/^\\include{labels}$/;"	i
models	HTKBook/htkbook.tex	/^\\include{labels}$/;"	i
models	HTKLib/HRec.c	/^   Boolean models;          \/* Keep track of model history *\/$/;"	m	struct:precinfo	file:
models	HTKTools/HVite.c	/^static Boolean models = FALSE;    \/* Keep track of model alignment *\/$/;"	v	file:
monophones	HTKTools/HSmooth.c	/^static LabId *monophones;    \/* array[1..nPhones]of LabId *\/$/;"	v	file:
mp	HTKLib/HFBLat.c	/^   MixPDF *mp;$/;"	m	struct:__anon90	file:
mp	HTKLib/HUtil.h	/^   MixPDF *mp;       \/* ->current mixPDF *\/$/;"	m	struct:__anon38
mp	HTKTools/HHEd.c	/^   MixPDF *mp;               \/* actual component *\/$/;"	m	struct:_CoList	file:
mpdf	HTKLib/HModel.h	/^   MixPDF *mpdf;        \/* -> mixture pdf *\/$/;"	m	struct:__anon57
mpe	HTKLib/HArc.h	/^  MPEStruct *mpe; \/*if doing mpe. *\/$/;"	m	struct:_Arc
mpe_occscale	HTKLib/HArc.h	/^  float mpe_occscale; \/* scale on the occupancy [for MPE code], equals$/;"	m	struct:_Acoustic
mrows	HTKLib/HNLM.h	/^    int32 mrows;$/;"	m	struct:matheader
mtab	HTKLib/HModel.h	/^   MLink * mtab;           \/* Array[0..MACHASHSIZE-1]OF MLink *\/$/;"	m	struct:_HMMSet
mu	HTKLib/HTrain.h	/^   Vector mu;        \/* mean vector counts *\/$/;"	m	struct:__anon113
muC	HTKLib/HTrain.c	/^static int muC,vaC,trC,wtC,prC;$/;"	v	file:
mulntacc_mfmf_mf	HTKLib/HNLM.c	/^void mulntacc_mfmf_mf(int Sm,int Sk,int Sn, const float *A,const float *B,float *C)$/;"	f
multiLat	HTKTools/HBuild.c	/^typedef enum {unknown, wordLoop, boBiGram, matBiGram, multiLat, wordPair} BuildType;$/;"	e	enum:__anon163	file:
myArc	HTKLib/HArc.h	/^  HArc *myArc; $/;"	m	struct:_Acoustic
n	HLMTools/LGPrep.c	/^   int n;                     \/* number of fields in list *\/$/;"	m	struct:__anon27	file:
n	HTKLib/HAudio.c	/^   int n;                 \/* Number of valid samples in buffer *\/$/;"	m	struct:mmapibuf	file:
n	HTKLib/HNet.c	/^   int n;$/;"	m	struct:pinstinfo	file:
n	HTKLib/HNet.h	/^   int n;              \/* Arc identity *\/$/;"	m	struct:larc_e
n	HTKLib/HNet.h	/^   int n;              \/* Sorted order *\/$/;"	m	struct:lnode
n	HTKLib/HRNLM.c	/^        } n;$/;"	m	union:__anon130	typeref:struct:__anon130::__anon131	file:
n	HTKLib/HRec.c	/^   short n;                  \/* Number of rtok valid (0==1-best, 1>==N-best) *\/$/;"	m	struct:tokenset	file:
n1Cmds	HTKTools/HLEd.c	/^static int  n1Cmds = 17;$/;"	v	file:
n2lId	HLMLib/LPMerge.c	/^   int     **n2lId;          \/* array of NameId -> LabId lookup tables *\/$/;"	m	struct:__anon1	file:
nAlign	HTKLib/HNet.h	/^   short nAlign;       \/* Number of alignment records in word *\/$/;"	m	struct:larc
nArcs	HTKLib/HArc.h	/^  int nArcs; \/* normally 1, but e.g.  if quinphone or perhaps MWE, can be more. *\/$/;"	m	struct:_CorrN
nArcs	HTKLib/HArc.h	/^  int nArcs;$/;"	m	struct:ArcInfoStruct
nArgs	HTKTools/HDMan.c	/^   short nArgs;$/;"	m	struct:__anon159	file:
nArgs	HTKTools/HLEd.c	/^   short nArgs;$/;"	m	struct:__anon142	file:
nAvail	HTKLib/HWave.c	/^   long nAvail;         \/* Num samples allocated for data *\/$/;"	m	struct:_Wave	file:
nBeam	HTKLib/HRec.h	/^   LogFloat nBeam;          \/* Beam width for non-best tokens *\/$/;"	m	struct:vrecinfo
nBeam	HTKTools/HVite.c	/^static LogDouble nBeam = 0.0;     \/* nBeam threshold *\/$/;"	v	file:
nBlk	HTKTools/HSmooth.c	/^static int nBlk = 0;       \/* number of data blocks *\/$/;"	v	file:
nClass	HLMLib/LWMap.h	/^   int     nClass;       \/* number of class ids in map *\/$/;"	m	struct:__anon20
nCmds	HTKTools/HDMan.c	/^static int  nCmds = 21;$/;"	v	file:
nCmds	HTKTools/HHEd.c	/^static int  nCmds = 40;$/;"	v	file:
nCmds	HTKTools/HLEd.c	/^static int  nCmds = LASTCMD-1;$/;"	v	file:
nCols	HTKLib/HParm.c	/^   int nCols;         \/* num columns in each row of the parameter block *\/$/;"	m	struct:__anon76	file:
nComponents	HTKTools/HHEd.c	/^   int  nComponents;         \/* number of components in this cluster *\/$/;"	m	struct:__anon167	file:
nCvrt	HTKLib/HParm.c	/^   int nCvrt;         \/* num columns produced from coding *\/$/;"	m	struct:__anon76	file:
nDefPhones	HTKTools/HDMan.c	/^static int nDefPhones = 0;               \/* num predefined phones *\/$/;"	v	file:
nDefs	HTKTools/HLEd.c	/^   short nDefs;$/;"	m	struct:_Context	file:
nDenLats	HTKTools/HMMIRest.c	/^int nDenLats = 0;$/;"	v
nEntry	HLMLib/LModel.h	/^   int nEntry;              \/* number of entries in model *\/$/;"	m	struct:__anon14
nFiles	HLMLib/LGBase.h	/^   int nFiles;             \/* num files in input set *\/$/;"	m	struct:__anon5
nFloorVar	HTKLib/HMap.c	/^static int nFloorVar = 0;     \/* # of floored variance comps *\/$/;"	v	file:
nFloorVar	HTKTools/HERest.c	/^static int nFloorVar = 0;     \/* # of floored variance comps *\/$/;"	v	file:
nFloorVar	HTKTools/HMMIRest.c	/^static int nFloorVar = 0;     \/* # of floored variance comps *\/$/;"	v	file:
nFloorVarMix	HTKLib/HMap.c	/^static int nFloorVarMix = 0;  \/* # of mix comps with floored vars *\/$/;"	v	file:
nFloorVarMix	HTKTools/HERest.c	/^static int nFloorVarMix = 0;  \/* # of mix comps with floored vars *\/$/;"	v	file:
nFloorVarMix	HTKTools/HMMIRest.c	/^static int nFloorVarMix = 0;  \/* # of mix comps with floored vars *\/$/;"	v	file:
nFloorWeight	HTKTools/HMMIRest.c	/^static int nFloorWeight = 0;  \/* # of floored weights. *\/$/;"	v	file:
nFree	HTKLib/HTrain.h	/^   int nFree;        \/* number of items slots in total *\/$/;"	m	struct:__anon108
nGaussPDE1	HTKLib/HModel.c	/^static int nGaussPDE1 = 0;$/;"	v	file:
nGaussPDE2	HTKLib/HModel.c	/^static int nGaussPDE2 = 0;$/;"	v	file:
nGaussTot	HTKLib/HModel.c	/^static int nGaussTot = 0;$/;"	v	file:
nGramName	HLMLib/LModel.c	/^static char *nGramName[LM_NSIZE] = {$/;"	v	file:
nInBuffer	HTKLib/HAudio.c	/^   int nInBuffer;            \/* Number of valid samples in buffer *\/$/;"	m	struct:_AudioIn	file:
nInc	HTKTools/HSmooth.c	/^   long nInc;        \/* num times this acc incremented *\/$/;"	m	struct:_ChWtAcc	file:
nInputs	HTKTools/HDMan.c	/^static int nInputs = 0;              \/* number of input dictionaries *\/$/;"	v	file:
nItem	HLMTools/LGPrep.c	/^   int nItem;                 \/* num words in set *\/$/;"	m	struct:__anon26	file:
nItems	HLMLib/LGBase.h	/^   int nItems;              \/* number of n-grams in file *\/$/;"	m	struct:__anon4
nItems	HTKLib/HTrain.c	/^static int nItems;      \/* num items in pool *\/$/;"	v	file:
nItems	HTKLib/HTrain.h	/^   int nItems;       \/* number of items stored *\/$/;"	m	struct:__anon108
nItems	HTKTools/HList.c	/^static int nItems  = 10;         \/* num items per line *\/$/;"	v	file:
nJoins	HTKTools/HHEd.c	/^static int nJoins;                     \/* current num mixs in joinSet *\/$/;"	v	file:
nLModel	HLMLib/LPMerge.c	/^   int     nLModel;          \/* number of LMs to merge *\/$/;"	m	struct:__anon1	file:
nLModel	HLMTools/LAdapt.c	/^static int     nLModel;                     \/* number of loaded LMs *\/$/;"	v	file:
nLModel	HLMTools/LMerge.c	/^static int       nLModel;                \/* number of loaded LMs *\/$/;"	v	file:
nLModel	HLMTools/LPlex.c	/^static int     nLModel;             \/* number of loaded LMs *\/$/;"	v	file:
nLabs	HTKTools/HResults.c	/^static int nLabs;$/;"	v	file:
nLats	HTKLib/HArc.h	/^  int nLats;$/;"	m	struct:ArcInfoStruct
nLogHmms	HTKTools/HSmooth.c	/^static int nLogHmms;       \/* number of logical HMM's *\/$/;"	v	file:
nMembers	HTKLib/HUtil.h	/^   int nMembers;		\/* cardinality of set *\/$/;"	m	struct:__anon39
nMix	HTKLib/HModel.h	/^   int nMix;            \/* num mixtures in this stream *\/$/;"	m	struct:__anon61
nMix	HTKLib/HModel.h	/^   short nMix;           \/* num mixtures M in set *\/$/;"	m	struct:__anon60
nMix	HTKTools/HMMIRest.c	/^static int nMix = 0;  \/*  total # of gaussians. *\/$/;"	v	file:
nModels	HTKLib/HLM.h	/^   int nModels;                 \/* Number of component language models *\/$/;"	m	struct:intpltlm
nNewPhones	HTKTools/HDMan.c	/^static int nNewPhones = 0;               \/* num new phones encountered *\/$/;"	v	file:
nNumLats	HTKTools/HMMIRest.c	/^int nNumLats = 0;$/;"	v
nOOV	HLMTools/LPlex.c	/^   int nOOV;                \/* number of OOVs *\/$/;"	m	struct:__anon33	file:
nObs	HTKLib/HParm.h	/^   int nObs;                  \/* Number of table observations *\/$/;"	m	struct:__anon122
nOpen	HLMLib/LGBase.h	/^   int nOpen;              \/* num open files *\/$/;"	m	struct:__anon5
nPDFs	HTKLib/HFBLat.c	/^static int nPDFs[SMAX];  \/*rely on it being initialised to zeros.*\/$/;"	v	file:
nParm	HLMLib/LCMap.c	/^static int nParm = 0;$/;"	v	file:
nParm	HLMLib/LGBase.c	/^static int nParm = 0;$/;"	v	file:
nParm	HLMLib/LModel.c	/^static int nParm = 0;$/;"	v	file:
nParm	HLMLib/LPCalc.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMLib/LPMerge.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMLib/LUtil.c	/^static int nParm = 0;$/;"	v	file:
nParm	HLMLib/LWMap.c	/^static int nParm = 0;$/;"	v	file:
nParm	HLMTools/Cluster.c	/^static int          nParm = 0;              \/* total num params *\/$/;"	v	file:
nParm	HLMTools/HLMCopy.c	/^static int nParm = 0;                  \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LAdapt.c	/^static int nParm = 0;   \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LBuild.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LFoF.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LGCopy.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LGList.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LGPrep.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LLink.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LMerge.c	/^static int nParm = 0;                  \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LNewMap.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LNorm.c	/^static int nParm = 0;                  \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LPlex.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LSubset.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKLib/HAdapt.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HArc.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HDict.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HExactMPE.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HFB.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HFBLat.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HGraf.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HGraf.null.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HGraf_WIN32.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HLM.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HLat.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HMap.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HModel.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HNLM.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKLib/HNet.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HParm.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HRNLM.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKLib/HRec.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HShell.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HTrain.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HUtil.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKTools/HBuild.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HCompV.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HCopy.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HDMan.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HERest.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HHEd.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HInit.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HLEd.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HLRescore.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HLStats.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HList.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HMMIRest.c	/^static int nParm = 0;                \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HParse.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HQuant.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HRest.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HResults.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HSGen.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HSLab.c	/^static int nParm = 0;                \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HSmooth.c	/^static int nParm = 0;        \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HVite.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nPaths	HTKLib/HLat.c	/^   LogDouble nPaths;     \/* number of paths from start node *\/$/;"	m	struct:_StatsInfo	file:
nPhone	HTKTools/HDMan.c	/^   short nPhone;$/;"	m	struct:__anon160	file:
nPhones	HTKTools/HSmooth.c	/^static int nPhones;          \/* number of monophones *\/$/;"	v	file:
nPhyHmms	HTKTools/HSmooth.c	/^static int nPhyHmms;       \/* number of physical HMM's *\/$/;"	v	file:
nPron	HTKTools/HDMan.c	/^   short nPron;$/;"	m	struct:__anon161	file:
nRef	HTKTools/HResults.c	/^static int nRef,nTest;$/;"	v	file:
nRows	HTKLib/HParm.c	/^   int nRows;        \/* number of rows used in this block *\/$/;"	m	struct:pblock	file:
nRules	HLMTools/LGPrep.c	/^   int nRules;                \/* number of rules *\/$/;"	m	struct:__anon28	file:
nSamples	HTKLib/HParm.c	/^   long nSamples;     \/* num samples in original (WAVEFORM only) *\/$/;"	m	struct:__anon76	file:
nSamples	HTKLib/HParm.h	/^   long nSamples;             \/* Number of source samples *\/$/;"	m	struct:__anon122
nSamples	HTKLib/HWave.c	/^   int32  nSamples;$/;"	m	struct:__anon100	file:
nSamples	HTKLib/HWave.c	/^   int32  nSamples;$/;"	m	struct:__anon101	file:
nSamples	HTKLib/HWave.c	/^   int32 nSamples;$/;"	m	struct:__anon107	file:
nSamples	HTKLib/HWave.c	/^   long nSamples;       \/* No of samples in data *\/$/;"	m	struct:_Wave	file:
nSamples	HTKLib/HWave.c	/^   unsigned int nSamples;$/;"	m	struct:__anon106	file:
nSamples	HTKTools/HList.c	/^   long nSamples;$/;"	m	struct:__anon153	file:
nSamples	HTKTools/HSLab.c	/^static long nSamples;        \/* number of samples *\/$/;"	v	file:
nSeg	HTKTools/HRest.c	/^static int nSeg;           \/* num training segments *\/$/;"	v	file:
nSets	HLMTools/LGPrep.c	/^   int nSets;                 \/* number of word sets actually defined *\/$/;"	m	struct:__anon28	file:
nSize	HLMLib/LModel.h	/^   int nSize;                \/* model order 1=unigram, 2=bigram, etc *\/$/;"	m	struct:__anon16
nSize	HLMLib/LPCalc.h	/^   int          nSize;                \/* model order *\/$/;"	m	struct:__anon2
nSize	HLMTools/HLMCopy.c	/^static int       nSize = 0;              \/* output n-gram size *\/$/;"	v	file:
nSize	HLMTools/LAdapt.c	/^static int nSize     = 3;           \/* ngram size *\/$/;"	v	file:
nSize	HLMTools/LFoF.c	/^static int        nSize = 0;        \/* ngram size N *\/$/;"	v	file:
nSize	HLMTools/LGCopy.c	/^static int nSize     = 0;           \/* ngram size *\/$/;"	v	file:
nSize	HLMTools/LGPrep.c	/^static int nSize     = 3;           \/* ngram size *\/$/;"	v	file:
nSize	HLMTools/LMerge.c	/^static int       nSize = 0;              \/* output ngram size *\/$/;"	v	file:
nSize	HLMTools/LNorm.c	/^static int       nSize = 0;              \/* output n-gram size *\/$/;"	v	file:
nSnt	HTKTools/HMMIRest.c	/^static int nSnt      = 0;        \/* num sentences from current speaker *\/$/;"	v	file:
nStates	HTKTools/HInit.c	/^static int nStates;              \/* number of states in hmm *\/$/;"	v	file:
nStates	HTKTools/HRest.c	/^static int nStates;        \/* numStates of hmm *\/$/;"	v	file:
nStreams	HTKTools/HInit.c	/^static int nStreams;             \/* number of streams in hmm *\/$/;"	v	file:
nStreams	HTKTools/HRest.c	/^static int nStreams;       \/* numStreams of hmm *\/$/;"	v	file:
nStreams	HTKTools/HSmooth.c	/^static int nStreams;             \/* number of data streams *\/$/;"	v	file:
nTest	HTKTools/HResults.c	/^static int nRef,nTest;$/;"	v	file:
nThresh	HTKLib/HRec.c	/^   LogFloat nThresh;        \/* Cutoff for non-best tokens *\/$/;"	m	struct:precinfo	file:
nToPlay	HTKLib/HAudio.c	/^   int nToPlay;$/;"	m	struct:_AudioOut	file:
nTok	HLMTools/LPlex.c	/^   int nTok;                \/* total number of tokens *\/$/;"	m	struct:__anon33	file:
nTokUsed	HTKTools/HRest.c	/^static int nTokUsed;       \/* actual number of tokens used *\/$/;"	v	file:
nToks	HTKLib/HRec.c	/^   int nToks;               \/* Maximum tokens to propagate (0==1) *\/$/;"	m	struct:precinfo	file:
nToks	HTKTools/HVite.c	/^static int nToks = 0;             \/* Number of tokens for N best *\/$/;"	v	file:
nTrans	HTKTools/HVite.c	/^static int nTrans = 1;            \/* Number of transcriptions for N best *\/$/;"	v	file:
nType	HTKTools/HParse.c	/^   NodeType nType;   \/* the type of this node *\/$/;"	m	struct:_NodeInfo	file:
nUse	HTKLib/HModel.h	/^   int nUse;               \/* num logical hmm's sharing this def *\/$/;"	m	struct:__anon64
nUse	HTKLib/HModel.h	/^   int nUse;            \/* usage counter *\/$/;"	m	struct:__anon56
nUse	HTKLib/HModel.h	/^   int nUse;            \/* usage counter *\/$/;"	m	struct:__anon62
nUse	HTKLib/HModel.h	/^  int nUse;                         \/* usage counter *\/$/;"	m	struct:_AdaptXForm
nUse	HTKLib/HModel.h	/^  int nUse;            \/* usage counter *\/$/;"	m	struct:__anon65
nUse	HTKLib/HModel.h	/^  int nUse;            \/* usage counter *\/$/;"	m	struct:__anon68
nUse	HTKLib/HModel.h	/^  int nUse;            \/* usage counter *\/$/;"	m	struct:__anon69
nUse	HTKLib/HModel.h	/^  int nUse;            \/* usage counter *\/$/;"	m	struct:__anon70
nUse	HTKTools/HParse.c	/^   int nUse;         \/* num sharing this LinkSet *\/$/;"	m	struct:__anon154	file:
nUsed	HTKLib/HParm.c	/^   int nUsed;         \/* num columns used in each row of the parm block *\/$/;"	m	struct:__anon76	file:
nUtt	HLMTools/LPlex.c	/^   int nUtt;                \/* number of utterances *\/$/;"	m	struct:__anon33	file:
nVB	HTKTools/HLEd.c	/^static int nVB = 0;                 \/* number of non-interword boundaries *\/$/;"	v	file:
nVar	HTKTools/HMMIRest.c	/^static long int nVar = 0;     \/* # total of vars *\/$/;"	v	file:
nWB	HTKTools/HLEd.c	/^static int nWB = 0;                 \/* number of interword boundaries *\/$/;"	v	file:
nWeight	HTKTools/HMMIRest.c	/^static int nWeight = 0;  \/*  total # of weights. *\/$/;"	v	file:
nWords	HLMTools/LPlex.c	/^static int     nWords;              \/* number of words in list *\/$/;"	v	file:
nWords	HTKTools/HDMan.c	/^static int nWords = 0;               \/* number of words in word list *\/$/;"	v	file:
nWrd	HLMTools/LPlex.c	/^   int nWrd;                \/* number of words predicted *\/$/;"	m	struct:__anon33	file:
n_hmm	HTKLib/HNet.h	/^   n_hmm=2,             \/* Node Instance represents HMM *\/$/;"	e	enum:__anon126
n_lcontext	HTKLib/HNet.h	/^   n_lcontext=16,       \/* Multiplication factor for context id *\/$/;"	e	enum:__anon126
n_nocontext	HTKLib/HNet.h	/^   n_nocontext=15,      \/* binary and with this to remove context ids *\/$/;"	e	enum:__anon126
n_rcontext	HTKLib/HNet.h	/^   n_rcontext=16384     \/* Multiplication factor for context id *\/$/;"	e	enum:__anon126
n_tr0	HTKLib/HNet.h	/^   n_tr0=4,             \/* Entry token reaches exit in t=0 *\/$/;"	e	enum:__anon126
n_unused	HTKLib/HNet.h	/^   n_unused,            \/* Node Instance not yet assigned *\/$/;"	e	enum:__anon126
n_wd0	HTKLib/HNet.h	/^   n_wd0=1,             \/* Exit token reaches word node in t=0 *\/$/;"	e	enum:__anon126
n_wdstart	HTKLib/HNet.h	/^   n_wdstart=8,         \/* Temporary wdstart node *\/$/;"	e	enum:__anon126
n_word	HTKLib/HNet.h	/^   n_word=4,            \/* Node Instance represents word end (or null) *\/$/;"	e	enum:__anon126
na	HTKLib/HNet.h	/^   int na;                      \/* Number of arcs *\/$/;"	m	struct:lattice
nact	HTKLib/HRec.c	/^   int nact;                \/* Number of active instances *\/$/;"	m	struct:precinfo	file:
nact	HTKLib/HRec.h	/^   int nact;                \/* Number of active models *\/$/;"	m	struct:vrecinfo
nae	HTKTools/HLStats.c	/^static int nae=0;                \/* Number of accumulators created *\/$/;"	v	file:
nalign	HTKLib/HRec.c	/^   int nalign;              \/* Current number of align records *\/$/;"	m	struct:precinfo	file:
name	HLMLib/LCMap.h	/^   char *name;     	     	\/* name of class map *\/$/;"	m	struct:__anon21
name	HLMLib/LModel.h	/^   char  *name;              \/* textual description and header *\/$/;"	m	struct:__anon16
name	HLMLib/LUtil.c	/^   char * name;$/;"	m	struct:hdrField	file:
name	HLMLib/LUtil.h	/^   char *name;                 \/* Label Name *\/$/;"	m	struct:_NameHolder
name	HLMLib/LWMap.h	/^   char    *name;        \/* name of map *\/$/;"	m	struct:__anon20
name	HTKLib/HLM.h	/^   char *name;                  \/* Name used for identifying lm *\/$/;"	m	struct:lmodel
name	HTKLib/HLabel.c	/^   LabId name;$/;"	m	struct:__anon135	file:
name	HTKLib/HLabel.h	/^   char * name;             \/* Label Name *\/$/;"	m	struct:_NameCell
name	HTKLib/HLat.c	/^   char name[MAXFNAMELEN];$/;"	m	struct:_LLFInfo	file:
name	HTKLib/HMem.h	/^   char *name;          \/*            name of this memory heap            *\/$/;"	m	struct:__anon73
name	HTKLib/HModel.c	/^   char *name;$/;"	m	struct:__anon41	file:
name	HTKLib/HShell.h	/^   char *name;          \/* name of param - upper case always *\/$/;"	m	struct:__anon87
name	HTKLib/HShell.h	/^   char name[256];      \/* file name for error messages *\/$/;"	m	struct:__anon84
name	HTKLib/esignal.h	/^    char        *name;          \/* identifying character string *\/$/;"	m	struct:FieldSpec
name	HTKTools/HDMan.c	/^   char *name;                  \/* full path of dictionary file *\/$/;"	m	struct:__anon162	file:
name	HTKTools/HLStats.c	/^   LabId name;                   \/* Name *\/$/;"	m	struct:cntr	file:
name	HTKTools/HLStats.c	/^   LabId name;                   \/* Name *\/$/;"	m	struct:wordinfo	file:
name	HTKTools/HList.c	/^   char *name;$/;"	m	struct:__anon153	file:
name	HTKTools/HResults.c	/^   char *name;$/;"	m	struct:_Spkr	file:
nameTab	HLMLib/LUtil.h	/^  NameHolder **nameTab;        \/* the actual table *\/$/;"	m	struct:__anon23
namecellHeap	HTKLib/HLabel.c	/^static MemHeap namecellHeap;         \/* heap for name cells *\/$/;"	v	file:
names	HTKTools/HResults.c	/^static LabId *names;$/;"	v	file:
namlen	HTKLib/HNLM.h	/^    int32 namlen;$/;"	m	struct:matheader
natReadOrder	HLMLib/LGBase.c	/^static Boolean natReadOrder = FALSE;    \/* Preserve natural read byte order *\/$/;"	v	file:
natReadOrder	HLMLib/LModel.c	/^static Boolean natReadOrder = FALSE;    \/* Preserve natural read byte order *\/$/;"	v	file:
natReadOrder	HTKLib/HShell.c	/^static Boolean natReadOrder = FALSE;     \/* Preserve natural mach read order*\/$/;"	v	file:
natReadOrder	HTKLib/HWave.c	/^static Boolean natReadOrder = FALSE;    \/* Preserve natural read byte order*\/$/;"	v	file:
natWriteOrder	HLMLib/LGBase.c	/^static Boolean natWriteOrder = FALSE;   \/* Preserve natural write byte order *\/$/;"	v	file:
natWriteOrder	HLMLib/LModel.c	/^static Boolean natWriteOrder = FALSE;   \/* Preserve natural write byte order *\/$/;"	v	file:
natWriteOrder	HTKLib/HParm.c	/^static Boolean natWriteOrder = FALSE; \/* Preserve natural write byte order*\/$/;"	v	file:
natWriteOrder	HTKLib/HShell.c	/^static Boolean natWriteOrder = FALSE;    \/* Preserve natural mach write order*\/$/;"	v	file:
natWriteOrder	HTKLib/HWave.c	/^static Boolean natWriteOrder = FALSE;   \/* Preserve natural write byte order*\/$/;"	v	file:
nbestentry	HTKLib/HRec.c	/^struct nbestentry {$/;"	s	file:
nboff	HLMLib/LModel.c	/^   int nboff;           \/* times computed using the back-off weight *\/$/;"	m	struct:_AccessInfo	file:
nc	HTKLib/HNet.h	/^   int nc;         \/* Number of contexts *\/$/;"	m	struct:hmmsetcxtinfo
ncells	HTKLib/HGraf.c	/^static unsigned int  ncells, dispWIDE, dispHIGH, dispDEEP;$/;"	v	file:
ncf	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
ncf	HTKLib/HNet.h	/^   int ncf;        \/* Number of context free models *\/$/;"	m	struct:hmmsetcxtinfo
nci	HTKLib/HNet.h	/^   int nci;        \/* Number of context independent models *\/$/;"	m	struct:hmmsetcxtinfo
nclass	HTKLib/HRNLM.h	/^    int num_layer, dim_fea, nclass, inputlayersize, outputlayersize;$/;"	m	struct:_RNNLM
ncn	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
ncols	HTKLib/HRNLM.h	/^    int nrows, ncols, sizes;$/;"	m	struct:_Layer
nconv	HTKTools/HHEd.c	/^static int nconv;$/;"	v	file:
ndx	HLMLib/LCMap.h	/^   int ndx;                \/* index of class *\/$/;"	m	struct:clEntry
ndx	HLMLib/LModel.h	/^   LM_Id   ndx;             \/* word index *\/$/;"	m	struct:_SMEntry
ndx	HLMLib/LModel.h	/^   LM_Id ndx;               \/* word index *\/$/;"	m	struct:_FLEntry
ndx	HLMLib/LWMap.h	/^   int ndx;                \/* index of word in map *\/$/;"	m	struct:MAPENTRY
ndx	HLMTools/LGList.c	/^   int  ndx;$/;"	m	struct:fitem	file:
negBuf	HLMTools/LGPrep.c	/^static ShiftReg negBuf;             \/* N-grams from matched source text *\/$/;"	v	file:
nend	HTKLib/HNet.c	/^   int nend;        \/* Number of models in ends chain *\/$/;"	m	struct:pronholder	file:
nentry	HTKLib/HLM.h	/^typedef struct nentry {         \/* HLM NGram history *\/$/;"	s
nep_cmp	HLMLib/LModel.c	/^static int nep_cmp(const void *v1,const void *v2)$/;"	f	file:
nep_cmp	HTKLib/HLM.c	/^static int nep_cmp(const void *v1,const void *v2)$/;"	f	file:
net	HTKLib/HNet.h	/^   char *net;			\/* Network file name (NULL==unknown) *\/$/;"	m	struct:lattice
net	HTKLib/HRec.c	/^   Network *net;            \/* Recognition network *\/$/;"	m	struct:precinfo	file:
netHeap	HTKTools/HVite.c	/^static MemHeap netHeap;$/;"	v	file:
netName	HTKTools/HParse.c	/^   LabId netName;    \/* variable name (LHS of rule) *\/$/;"	m	struct:_SubNetDef	file:
netReset	HTKLib/HRNLM.c	/^static void netReset(RNNLM* rnnlm)   \/* cleans hidden layer activation + bptt history *\/$/;"	f	file:
netdict	HTKBook/htkbook-pdf.tex	/^\\include{discmods}$/;"	i
netdict	HTKBook/htkbook.tex	/^\\include{discmods}$/;"	i
network	HTKTools/HParse.c	/^   HPNetwork network;  \/* sub-network (RHS of rule) *\/ $/;"	m	struct:_SubNetDef	file:
neu0	HTKLib/HRNLM.h	/^    struct neuron *neu0;		\/*neurons in input layer *\/$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::neuron
neu0_ac_fea	HTKLib/HRNLM.h	/^    real *layer0_fea, *neu0_ac_fea, *layerN_class, *neuN_ac_class;$/;"	m	struct:_RNNLM
neu0_ac_hist	HTKLib/HRNLM.h	/^    real *layer0_hist, *neu0_ac_hist, **layers, **neu_ac;$/;"	m	struct:_RNNLM
neu0_topic	HTKLib/HRNLM.h	/^    struct neuron *neu0_topic;$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::neuron
neu0b	HTKLib/HRNLM.h	/^    struct neuron *neu0b;$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::neuron
neu1	HTKLib/HRNLM.h	/^    struct neuron *neu1;		\/*neurons in hidden layer *\/$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::neuron
neu1_ac_succ	HTKLib/HRNLM.h	/^    real **neu1_ac_succ, **neu_ac_succ;$/;"	m	struct:_RNNLM
neu1b	HTKLib/HRNLM.h	/^    struct neuron *neu1b;$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::neuron
neu1b2	HTKLib/HRNLM.h	/^    struct neuron *neu1b2;$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::neuron
neu2	HTKLib/HRNLM.h	/^    struct neuron *neu2;		\/*neurons in output layer *\/$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::neuron
neu2b	HTKLib/HRNLM.h	/^    struct neuron *neu2b;$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::neuron
neuN_ac_class	HTKLib/HRNLM.h	/^    real *layer0_fea, *neu0_ac_fea, *layerN_class, *neuN_ac_class;$/;"	m	struct:_RNNLM
neu_ac	HTKLib/HRNLM.h	/^    real *layer0_hist, *neu0_ac_hist, **layers, **neu_ac;$/;"	m	struct:_RNNLM
neu_ac_succ	HTKLib/HRNLM.h	/^    real **neu1_ac_succ, **neu_ac_succ;$/;"	m	struct:_RNNLM
neuc	HTKLib/HRNLM.h	/^    struct neuron *neuc;		\/*neurons in hidden layer *\/$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::neuron
neucb	HTKLib/HRNLM.h	/^    struct neuron *neucb;$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::neuron
neuron	HTKLib/HRNLM.h	/^struct neuron {$/;"	s
newData	HTKTools/HSLab.c	/^static Boolean newData=FALSE;$/;"	v	file:
newDir	HTKTools/HERest.c	/^static char * newDir = NULL;     \/* directory to store new hmm def files *\/$/;"	v	file:
newDir	HTKTools/HHEd.c	/^static char * newDir = NULL;     \/* directory to store new hmm def files *\/$/;"	v	file:
newDir	HTKTools/HLEd.c	/^static char * newDir    = NULL;     \/* dest label file directory *\/$/;"	v	file:
newDir	HTKTools/HMMIRest.c	/^static char * newDir = NULL;     \/* directory to store new hmm def files *\/$/;"	v	file:
newDir	HTKTools/HSmooth.c	/^static char * newDir = NULL;     \/* directory to store new hmm def files *\/$/;"	v	file:
newExt	HTKTools/HERest.c	/^static char * newExt = NULL;     \/* extension of new reestimated hmm files *\/$/;"	v	file:
newExt	HTKTools/HHEd.c	/^static char * newExt = NULL;     \/* extension of new edited hmm files *\/$/;"	v	file:
newExt	HTKTools/HLEd.c	/^static char * newExt    = "lab";    \/* dest label file extension *\/$/;"	v	file:
newExt	HTKTools/HMMIRest.c	/^static char * newExt = NULL;     \/* extension of new reestimated hmm files *\/$/;"	v	file:
newExt	HTKTools/HSmooth.c	/^static char * newExt = NULL;     \/* extension of new reestimated hmm files *\/$/;"	v	file:
newLM	HLMTools/LAdapt.c	/^static BackOffLM *newLM;            \/* the generated LM *\/$/;"	v	file:
newLabFile	HTKTools/HSLab.c	/^static Boolean newLabFile   = FALSE;   \/* forcing the creation of a new (empty) label file *\/$/;"	v	file:
newLabs	HTKTools/HLEd.c	/^static FILE *newLabs = NULL;        \/* list of newly created labels *\/$/;"	v	file:
newList	HTKTools/HDMan.c	/^static LabId newList[MAXPVOC];       \/* list of new phones encountered *\/$/;"	v	file:
newModel	HTKTools/HInit.c	/^static Boolean  newModel = TRUE;    \/* enable initial uniform segmentation *\/$/;"	v	file:
newPhones	HTKTools/HDMan.c	/^static FILE *newPhones = NULL;       \/* file of newly created phones *\/$/;"	v	file:
newWords	HLMTools/LAdapt.c	/^static int newWords  =  100000;     \/* max new words to accommodate *\/$/;"	v	file:
newWords	HLMTools/LGPrep.c	/^static int newWords  =  100000;     \/* max new words to accommodate *\/$/;"	v	file:
newWords	HLMTools/LSubset.c	/^static int      newWords = 1000; \/* new words from class map *\/$/;"	v	file:
newc	HTKLib/HRNLM.h	/^    float *i, *f, *newc, *zi, *fc, *o;  \/* *c *z from GRU layer defination *\/$/;"	m	struct:_Layer
newln	HTKLib/HLat.c	/^      LNode *newln;$/;"	m	union:_SubLNode::__anon45	file:
next	HLMLib/LCMap.h	/^   struct clEntry *next;   \/* next class in list *\/$/;"	m	struct:clEntry	typeref:struct:clEntry::clEntry
next	HLMLib/LGBase.h	/^   GFLink next;            \/* next file to open + ... *\/$/;"	m	struct:gramfile
next	HLMLib/LGBase.h	/^   UInt *next;             \/* next free slot in pool *\/$/;"	m	struct:__anon6
next	HLMLib/LUtil.c	/^   struct hdrField * next;$/;"	m	struct:hdrField	typeref:struct:hdrField::hdrField	file:
next	HLMLib/LUtil.h	/^   struct _NameHolder *next;   \/* Chain *\/$/;"	m	struct:_NameHolder	typeref:struct:_NameHolder::_NameHolder
next	HLMTools/HLMCopy.c	/^   struct dictlist *next;$/;"	m	struct:dictlist	typeref:struct:dictlist::dictlist	file:
next	HLMTools/LGList.c	/^   struct fitem * next;$/;"	m	struct:fitem	typeref:struct:fitem::fitem	file:
next	HLMTools/LGPrep.c	/^   struct ruledef *next;$/;"	m	struct:ruledef	typeref:struct:ruledef::ruledef	file:
next	HLMTools/LPlex.c	/^   Equiv *next;$/;"	m	struct:_Equiv	file:
next	HTKLib/HAdapt.c	/^   struct _AInfo *next;            \/* next external file name in list *\/$/;"	m	struct:_AInfo	typeref:struct:_AInfo::_AInfo	file:
next	HTKLib/HAdapt.c	/^   struct _AccCache *next;$/;"	m	struct:_AccCache	typeref:struct:_AccCache::_AccCache	file:
next	HTKLib/HAdapt.c	/^   struct _ObsCache *next;$/;"	m	struct:_ObsCache	typeref:struct:_ObsCache::_ObsCache	file:
next	HTKLib/HArc.h	/^  CorrN *next;$/;"	m	struct:_CorrN
next	HTKLib/HAudio.c	/^   struct mmapibuf *next;$/;"	m	struct:mmapibuf	typeref:struct:mmapibuf::mmapibuf	file:
next	HTKLib/HDict.h	/^   Pron next;      \/* Next pronunciation of word *\/$/;"	m	struct:_WordPron
next	HTKLib/HDict.h	/^   Word next;       \/* next word in hash table chain *\/$/;"	m	struct:_DictEntry
next	HTKLib/HGraf.h	/^   BtnLink next;$/;"	m	struct:_HButton
next	HTKLib/HLabel.h	/^   struct _LabList *next;   \/* Next label list *\/$/;"	m	struct:_LabList	typeref:struct:_LabList::_LabList
next	HTKLib/HLabel.h	/^   struct _MLFEntry *next;    \/* next in chain *\/$/;"	m	struct:_MLFEntry	typeref:struct:_MLFEntry::_MLFEntry
next	HTKLib/HLabel.h	/^   struct _NameCell *next;  \/* Chain *\/$/;"	m	struct:_NameCell	typeref:struct:_NameCell::_NameCell
next	HTKLib/HLat.c	/^   LLFInfo *next;$/;"	m	struct:_LLFInfo	file:
next	HTKLib/HLat.c	/^   SubLArc *next;$/;"	m	struct:_SubLArc	file:
next	HTKLib/HLat.c	/^   SubLNode *next;$/;"	m	struct:_SubLNode	file:
next	HTKLib/HMem.c	/^   struct _MemHeapRec *next;$/;"	m	struct:_MemHeapRec	typeref:struct:_MemHeapRec::_MemHeapRec	file:
next	HTKLib/HMem.h	/^   BlockP next;         \/*           next block in chain                  *\/$/;"	m	struct:_Block
next	HTKLib/HModel.c	/^  XFDirLink next;          \/* next directory name in list *\/$/;"	m	struct:_XFDirInfo	file:
next	HTKLib/HModel.h	/^   ILink next;$/;"	m	struct:_ItemRec
next	HTKLib/HModel.h	/^   MILink next;            \/* next external file name in list *\/$/;"	m	struct:_MMFInfo
next	HTKLib/HModel.h	/^   MLink next;             \/* next cell in hash table *\/$/;"	m	struct:_MacroDef
next	HTKLib/HModel.h	/^   struct _PtrMap *next;   \/* next cell in hash table *\/$/;"	m	struct:_PtrMap	typeref:struct:_PtrMap::_PtrMap
next	HTKLib/HNet.c	/^   struct pronholder *next;$/;"	m	struct:pronholder	typeref:struct:pronholder::pronholder	file:
next	HTKLib/HNet.h	/^   struct sublatdef *next;  \/* Next sublat at this level *\/$/;"	m	struct:sublatdef	typeref:struct:sublatdef::sublatdef
next	HTKLib/HParm.c	/^   struct channelinfo *next;  \/* Next channel record *\/$/;"	m	struct:channelinfo	typeref:struct:channelinfo::channelinfo	file:
next	HTKLib/HParm.c	/^   struct pblock *next; \/* Next block *\/$/;"	m	struct:pblock	typeref:struct:pblock::pblock	file:
next	HTKLib/HRNLM.h	/^    struct _HashSlot* next;$/;"	m	struct:_HashSlot	typeref:struct:_HashSlot::_HashSlot
next	HTKLib/HShell.c	/^   struct _ConfigEntry *next;$/;"	m	struct:_ConfigEntry	typeref:struct:_ConfigEntry::_ConfigEntry	file:
next	HTKLib/HShell.c	/^   struct _VersionEntry *next;$/;"	m	struct:_VersionEntry	typeref:struct:_VersionEntry::_VersionEntry	file:
next	HTKLib/HTrain.h	/^   IBLink next;      \/* next block in chain *\/$/;"	m	struct:_ItemBlock
next	HTKLib/HVQ.h	/^   VQTable next;        \/* used internally for housekeeping *\/$/;"	m	struct:_VQTabRec
next	HTKTools/HBuild.c	/^   struct _GramEntry *next;$/;"	m	struct:_GramEntry	typeref:struct:_GramEntry::_GramEntry	file:
next	HTKTools/HBuild.c	/^   struct _WordFllr *next;$/;"	m	struct:_WordFllr	typeref:struct:_WordFllr::_WordFllr	file:
next	HTKTools/HCopy.c	/^   TrPtr next;                  \/* pointer to next in list *\/$/;"	m	struct:_TrList	file:
next	HTKTools/HDMan.c	/^   struct _ScriptItem *next;$/;"	m	struct:_ScriptItem	typeref:struct:_ScriptItem::_ScriptItem	file:
next	HTKTools/HHEd.c	/^   CLink next;                  \/* next item in group *\/$/;"	m	struct:_CRec	file:
next	HTKTools/HHEd.c	/^   QLink next;$/;"	m	struct:_QEnt	file:
next	HTKTools/HHEd.c	/^   struct _CoList *next;     \/* next component in the linked list *\/$/;"	m	struct:_CoList	typeref:struct:_CoList::_CoList	file:
next	HTKTools/HHEd.c	/^   struct _IPat *next;$/;"	m	struct:_IPat	typeref:struct:_IPat::_IPat	file:
next	HTKTools/HHEd.c	/^   struct _Node *next;          \/* doubly linked chain of *\/$/;"	m	struct:_Node	typeref:struct:_Node::_Node	file:
next	HTKTools/HHEd.c	/^   struct _Tree *next;          \/* next tree in list *\/$/;"	m	struct:_Tree	typeref:struct:_Tree::_Tree	file:
next	HTKTools/HLEd.c	/^   struct _Context *next;$/;"	m	struct:_Context	typeref:struct:_Context::_Context	file:
next	HTKTools/HLEd.c	/^   struct _FindAcc *next;$/;"	m	struct:_FindAcc	typeref:struct:_FindAcc::_FindAcc	file:
next	HTKTools/HLEd.c	/^   struct _ScriptItem *next;$/;"	m	struct:_ScriptItem	typeref:struct:_ScriptItem::_ScriptItem	file:
next	HTKTools/HParse.c	/^   struct _SubNetDef *next;$/;"	m	struct:_SubNetDef	typeref:struct:_SubNetDef::_SubNetDef	file:
next	HTKTools/HResults.c	/^   Equiv *next;$/;"	m	struct:_Equiv	file:
next	HTKTools/HResults.c	/^   struct _Spkr *next;$/;"	m	struct:_Spkr	typeref:struct:_Spkr::_Spkr	file:
next	HTKTools/HResults.c	/^   struct _SpotRec *next;$/;"	m	struct:_SpotRec	typeref:struct:_SpotRec::_SpotRec	file:
next	HTKTools/HSmooth.c	/^   WALink next;      \/* chain for wt accs *\/$/;"	m	struct:_ChWtAcc	file:
nextGram	HLMLib/LGBase.h	/^   UInt nextGram[MAXNG];   \/* next gram to read from inset *\/  $/;"	m	struct:__anon5
nextOutSym	HTKTools/HDMan.c	/^   LabId nextOutSym;            \/* next input output sym - for lookahead *\/$/;"	m	struct:__anon162	file:
nextSpkr	HTKTools/HCompV.c	/^   struct SpkrAccListItem *nextSpkr;     \/* next pointer *\/$/;"	m	struct:SpkrAccListItem	typeref:struct:SpkrAccListItem::SpkrAccListItem	file:
nextValid	HLMLib/LGBase.h	/^   Boolean nextValid;      \/* true if nextGram is valid *\/$/;"	m	struct:__anon5
nextWord	HTKTools/HDMan.c	/^   LabId nextWord;              \/* next input word - for lookahead *\/$/;"	m	struct:__anon162	file:
nextWt	HLMLib/LGBase.h	/^   float nextWt;           \/* weight of next gram *\/$/;"	m	struct:__anon5
nextarg	HTKLib/HShell.c	/^static int nextarg=1;         \/* next arg to return in GetxxxArg *\/$/;"	v	file:
nfe	HLMLib/LModel.h	/^   LM_Id nfe;               \/* number of FLEntry *\/$/;"	m	struct:_FLEntry
nfi	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nfllrs	HTKTools/HBuild.c	/^   int nfllrs;$/;"	m	struct:__anon164	file:
nfree	HLMLib/LCMap.h	/^   int nfree;		     	\/* num records in free list *\/$/;"	m	struct:__anon21
ng	HLMTools/LAdapt.c	/^   UInt ng[MAXNG+1];    \/* ng[0] is oldest word *\/$/;"	m	struct:__anon34	file:
ng	HLMTools/LGPrep.c	/^   UInt ng[MAXNG+1];          \/* ng[0] is oldest word *\/$/;"	m	struct:__anon29	file:
ng_full	HLMLib/LGBase.h	/^   int ng_full;            \/* byte size of expanded N-gram ie N+1 ints *\/$/;"	m	struct:__anon3
ng_size	HLMLib/LGBase.h	/^   int ng_size;            \/* byte size of squashed N-gram records *\/$/;"	m	struct:__anon3
ngb	HLMTools/LAdapt.c	/^   NGBuffer *ngb;       \/* output ngram buffer *\/$/;"	m	struct:__anon34	file:
ngb	HLMTools/LGCopy.c	/^static NGBuffer   *ngb;             \/* output ngram buffer *\/$/;"	v	file:
ngb	HLMTools/LGPrep.c	/^   NGBuffer *ngb;             \/* output ngram buffer *\/$/;"	m	struct:__anon29	file:
ngbHeap	HLMTools/LGCopy.c	/^static MemHeap    ngbHeap;          \/* memory for NGBuffers *\/$/;"	v	file:
ngbHeap	HLMTools/LGPrep.c	/^static MemHeap ngbHeap;             \/* memory for NGBuffers *\/$/;"	v	file:
ngbSize	HLMTools/LAdapt.c	/^static int ngbSize   = 2000000;     \/* ngram buffer size *\/$/;"	v	file:
ngbSize	HLMTools/LGCopy.c	/^static int ngbSize   = 2000000;     \/* ngram buffer size *\/$/;"	v	file:
ngbSize	HLMTools/LGPrep.c	/^static int ngbSize   = 2000000;     \/* ngram buffer size *\/$/;"	v	file:
ngen	HTKTools/HSGen.c	/^static int ngen = 100;              \/* num sents to gen *\/$/;"	v	file:
nglm	HTKLib/HLM.h	/^   Ptr *nglm;                   \/* Back-off N-gram LM for MLP LM prob normalization *\/$/;"	m	struct:mlplm
nglm	HTKLib/HLM.h	/^   Ptr *nglm;                   \/* Back-off N-gram LM for RNNLM prob normalization *\/$/;"	m	struct:__anon124
ngram	HTKLib/HLM.h	/^      NGramLM *ngram;$/;"	m	union:lmodel::__anon125
ngramaprox	HTKTools/HLRescore.c	/^static int  ngramaprox = 3;$/;"	v	file:
ngramlm	HTKLib/HLM.h	/^typedef struct ngramlm {$/;"	s
ngs	HLMLib/LGBase.h	/^   NGSource ngs[MAXINF];   \/* currently open sources *\/$/;"	m	struct:__anon5
nhits	HLMLib/LModel.c	/^   int nhits;           \/* times available *\/$/;"	m	struct:_AccessInfo	file:
nid	HTKLib/HVQ.h	/^   short nid,lid,rid;   \/* used for mapping between mem and ext def *\/$/;"	m	struct:_VQNodeRec
nil	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nin	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nistAlign	HTKTools/HResults.c	/^static Boolean nistAlign = FALSE;     \/* use NIST alignment & penalties *\/$/;"	v	file:
nistFormat	HTKTools/HResults.c	/^static Boolean nistFormat = FALSE;    \/* use NIST formatting *\/$/;"	v	file:
nlinks	HTKLib/HNet.h	/^   int nlinks;          \/* Number of nodes connected to this one *\/$/;"	m	struct:_NetNode
nll	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nmiss	HLMLib/LModel.c	/^   int nmiss;           \/* times not available *\/$/;"	m	struct:_AccessInfo	file:
nmp	HTKLib/HRec.c	/^   int nmp;$/;"	m	struct:psetinfo	file:
nn	HTKLib/HNet.h	/^   int nn;                      \/* Number of nodes *\/$/;"	m	struct:lattice
nnl	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nnlm	HTKLib/HNLM.h	/^typedef struct nnlm {$/;"	s
nnlmOrigFormat	HTKLib/HLM.c	/^static Boolean nnlmOrigFormat = FALSE;  \/* Set to TRUE for backward compatability *\/$/;"	v	file:
no	HTKTools/HHEd.c	/^   struct _Node *no;            \/* no subtree *\/$/;"	m	struct:_Node	typeref:struct:_Node::_Node	file:
no	HTKTools/HHEd.c	/^static AccSum yes,no;           \/* global accs for yes - no branches *\/$/;"	v	file:
noAlias	HTKTools/HHEd.c	/^static Boolean noAlias = FALSE;  \/* set to zap all aliases in hmmlist *\/$/;"	v	file:
noBounds	HTKTools/HLEd.c	/^static Boolean noBounds = FALSE;    \/* suppress boundary times if TRUE *\/$/;"	v	file:
noNumEscapes	HTKLib/HShell.c	/^static Boolean noNumEscapes = FALSE;     \/* Prevent writing in \\012 format *\/$/;"	v	file:
noTable	HTKLib/HParm.c	/^   Boolean noTable;    \/* no need for table access *\/$/;"	m	struct:_ParmBuf	file:
noTokenSurvived	HTKLib/HRec.h	/^   Boolean noTokenSurvived; \/* Set when no valid final token produced *\/$/;"	m	struct:vrecinfo
node	HTKLib/HNet.h	/^   NetNode *node;       \/* Node in network *\/$/;"	m	struct:_NetLink
node	HTKLib/HRec.c	/^   NetNode *node;       \/* Node for which alignment information present *\/$/;"	m	struct:align	file:
node	HTKLib/HRec.c	/^   NetNode *node;       \/* Position of instance within network *\/$/;"	m	struct:_NetInst	file:
node	HTKLib/HRec.h	/^   NetNode *node;       \/* Word level traceback info *\/$/;"	m	struct:path
nodeHeap	HTKLib/HNet.h	/^   MemHeap nodeHeap;  \/* a heap for allocating nodes *\/$/;"	m	struct:__anon128
nodeHeap	HTKTools/HParse.c	/^static MemHeap nodeHeap;$/;"	v	file:
nodeIndex	HTKLib/HModel.h	/^  int nodeIndex;            \/* index number of node *\/$/;"	m	struct:_RegNode
nodeIndex	HTKTools/HHEd.c	/^   short  nodeIndex;         \/* node index number *\/$/;"	m	struct:__anon167	file:
nodeInfoHeap	HTKTools/HParse.c	/^static MemHeap nodeInfoHeap;$/;"	v	file:
nodeNum	HTKTools/HParse.c	/^   int  nodeNum;     \/* store node numbers *\/$/;"	m	struct:_NodeInfo	file:
nodeOcc	HTKLib/HModel.h	/^  float nodeOcc;            \/* occupancy for this node *\/$/;"	m	struct:_RegNode
node_hmm	HTKLib/HRec.c	53;"	d	file:
node_tr0	HTKLib/HRec.c	55;"	d	file:
node_wd0	HTKLib/HRec.c	56;"	d	file:
node_word	HTKLib/HRec.c	54;"	d	file:
nodetype	HTKLib/HRNLM.h	/^    int nodetype;$/;"	m	struct:_Layer
nodetype	HTKLib/HRNLM.h	/^    int traincritmode, nodetype;$/;"	m	struct:_RNNLM
nonFlooredConst	HTKTools/HMMIRest.c	/^static int totalConst=0,nonFlooredConst=0; \/*TODO: print.*\/$/;"	v	file:
nonKeys	HTKTools/HResults.c	/^static int nonKeys=0;         \/* count of nonKeyWords encountered *\/$/;"	v	file:
noov	HTKLib/HLM.h	/^   int noov;                    \/* accumumalte of number of OOV words *\/$/;"	m	struct:lmpplexacc
nphones	HTKLib/HDict.h	/^   short nphones;  \/* Number of phones in pronuciation *\/$/;"	m	struct:_WordPron
nphones	HTKLib/HNet.c	/^   short nphones;   \/* Number of phones for this instance *\/$/;"	m	struct:pronholder	file:
nphr	HTKTools/HResults.c	/^   int nsyms,nphr,phrcor;$/;"	m	struct:_Spkr	file:
nphr	HTKTools/HResults.c	/^static long nphr  = 0;     \/* Total phrases *\/$/;"	v	file:
nprons	HTKLib/HDict.h	/^   int nprons;          \/* total number of prons *\/$/;"	m	struct:__anon74
nprons	HTKLib/HDict.h	/^   int nprons;      \/* number of prons for this word *\/$/;"	m	struct:_DictEntry
npth	HTKLib/HRec.c	/^   int npth;                \/* Current number of path records *\/$/;"	m	struct:precinfo	file:
nrows	HTKLib/HRNLM.h	/^    int nrows, ncols, sizes;$/;"	m	struct:_Layer
nsample	HTKLib/HRNLM.c	/^static int nsample = 0;$/;"	v	file:
nse	HLMLib/LModel.h	/^   LM_Id nse;               \/* number of SMEntry *\/$/;"	m	struct:_FLEntry
nse	HTKLib/HLM.h	/^   lmCnt nse;                   \/* Number of ngrams for this entry *\/$/;"	m	struct:nentry
nsent	HTKLib/HLM.h	/^   int nsent;                   \/* accumumalte of number of sentences *\/$/;"	m	struct:lmpplexacc
nsize	HTKLib/HLM.h	/^   int nsize;                   \/* Unigram==1, Bigram==2, Trigram==3 *\/$/;"	m	struct:ngramlm
nsp	HTKLib/HRec.c	/^   int nsp;$/;"	m	struct:psetinfo	file:
nstart	HTKLib/HNet.c	/^   int nstart;      \/* Number of models in starts chain *\/$/;"	m	struct:pronholder	file:
nsucclayer	HTKLib/HRNLM.h	/^    int succeedwords, nsucclayer, succmergelayer;$/;"	m	struct:_RNNLM
nsyms	HTKTools/HResults.c	/^   int nsyms,nphr,phrcor;$/;"	m	struct:_Spkr	file:
nsyms	HTKTools/HResults.c	/^static long nsyms = 0;     \/* Total symbols *\/$/;"	v	file:
ntr	HTKLib/HRec.c	/^   int ntr;$/;"	m	struct:psetinfo	file:
nulClass	HLMTools/LPlex.c	/^static LabId  nulClass;             \/* Id of NULCLASS phone label *\/$/;"	v	file:
nulClass	HTKTools/HResults.c	/^static LabId nulClass;                \/* Id of NULCLASS phone label *\/$/;"	v	file:
nulName	HLMTools/LPlex.c	/^static char   *nulName = "???";     \/* name of null class *\/$/;"	v	file:
nulName	HTKTools/HResults.c	/^static char * nulName = "???";        \/* name of null class *\/$/;"	v	file:
nullId	HTKTools/HLStats.c	/^static LabId nullId;                \/* id of !NULL label in ngram *\/$/;"	v	file:
nullLab	HTKTools/HLRescore.c	/^static LabId nullLab;           \/* !NULL LabId *\/$/;"	v	file:
nullNode	HTKTools/HParse.c	/^typedef enum {unknown, wdInternal, wdExternal, wdBegin, wdEnd, nullNode} NodeType;$/;"	e	enum:__anon156	file:
nullOutput	HTKTools/HDMan.c	/^static Boolean nullOutput = FALSE;   \/* suppress generation of output dict *\/$/;"	v	file:
nullWord	HTKLib/HDict.h	/^   Word nullWord;       \/* dummy null word\/node *\/$/;"	m	struct:__anon74
nullWord	HTKLib/HLat.c	/^static LabId nullWord;          \/* null word in Lattices (!NULL) *\/$/;"	v	file:
nullWord	HTKLib/HNet.h	/^   Word nullWord;     \/* Word for output when word==NULL *\/$/;"	m	struct:__anon128
null_token	HTKLib/HRec.c	/^const Token null_token={LZERO,0.0,NULL,NULL};$/;"	v
numAccesses	HLMLib/LUtil.h	/^  long numAccesses;            \/* access statistics *\/$/;"	m	struct:__anon23
numAccesses	HTKLib/HLabel.c	/^static long numAccesses = 0;$/;"	v	file:
numActive	HTKTools/HDMan.c	/^static int numActive;                \/* num active input dictionaries *\/$/;"	v	file:
numCepCoef	HTKLib/HParm.c	/^   int numCepCoef;            \/* Number of cepstral coef *\/$/;"	m	struct:__anon76	file:
numChan	HTKLib/HWave.c	/^   int32 numChan;        \/* number of channels *\/$/;"	m	struct:__anon103	file:
numChannels	HTKLib/HWave.c	/^   short numChannels;$/;"	m	struct:__anon100	file:
numChannels	HTKLib/HWave.c	/^   short numChannels;$/;"	m	struct:__anon101	file:
numChannels	HTKLib/HWave.c	/^   short numChannels;$/;"	m	struct:__anon105	file:
numChans	HTKLib/HParm.c	/^   int numChans;              \/* Number of filter bank channels *\/$/;"	m	struct:__anon76	file:
numChans	HTKLib/HSigP.h	/^   int numChans;        \/* number of channels *\/$/;"	m	struct:__anon129
numChild	HTKLib/HModel.h	/^  int numChild;             \/* number of children - 0 if terminal *\/$/;"	m	struct:_RegNode
numClasses	HTKLib/HModel.h	/^  int numClasses;      \/* number of baseclasses *\/$/;"	m	struct:__anon65
numClust	HTKLib/HTrain.h	/^   int numClust;   \/* num cluster nodes *\/$/;"	m	struct:__anon110
numComps	HTKTools/HList.c	/^   int numComps;$/;"	m	struct:__anon153	file:
numConfigParms	HTKLib/HShell.c	/^static int numConfigParms = 0;$/;"	v	file:
numCons	HTKTools/HDMan.c	/^   int numCons;                 \/* number of context defs *\/$/;"	m	struct:__anon162	file:
numElem	HTKLib/HMem.h	/^   size_t numElem;      \/* #elems in blk             #bytes in blk        *\/$/;"	m	struct:_Block
numFields	HLMLib/LUtil.c	/^   int numFields;$/;"	m	struct:lmFileHdrRec	file:
numFiles	HTKLib/HModel.h	/^   int numFiles;           \/* total number of ext files *\/$/;"	m	struct:_HMMSet
numFllrs	HTKTools/HBuild.c	/^   int numFllrs;$/;"	m	struct:_GramEntry	file:
numFree	HTKLib/HMem.h	/^   size_t numFree;      \/* #free elements            #free bytes          *\/$/;"	m	struct:_Block
numLLFs	HTKLib/HLat.c	/^static int numLLFs = 0;$/;"	v	file:
numLat	HTKLib/HFBLat.h	/^  Lattice *numLat; \/* for MPE. *\/$/;"	m	struct:__anon54
numLatDir	HTKTools/HMMIRest.c	/^static char *numLatDir [MAXLATS];  \/*Numerator-alignment lattices.*\/$/;"	v	file:
numLatIncluded	HTKLib/HArc.h	/^  Boolean numLatIncluded; \/*if TRUE and this is a denominator lat, means the num lat$/;"	m	struct:ArcInfoStruct
numLatSubDirPat	HTKTools/HMMIRest.c	/^static char numLatSubDirPat[MAXSTRLEN] = "\\0";  \/* path mask of numerator lattices *\/$/;"	v	file:
numLatsLoaded	HTKLib/HLat.c	/^static int numLatsLoaded = 0;$/;"	v	file:
numLink	HTKLib/HNet.h	/^   int numLink;$/;"	m	struct:__anon128
numLinkSets	HTKTools/HParse.c	/^static long numLinkSets = 0;     \/* usage counters *\/$/;"	v	file:
numLinks	HTKTools/HParse.c	/^   short numLinks;   \/* number of links in set *\/$/;"	m	struct:__anon154	file:
numLinks	HTKTools/HParse.c	/^static long numLinks = 0;$/;"	v	file:
numLists	HTKLib/HLabel.h	/^   int numLists;           \/* num label lists (default=1) *\/$/;"	m	struct:__anon116
numLogHMM	HTKLib/HModel.h	/^   int numLogHMM;          \/* Num of logical HMM's *\/$/;"	m	struct:_HMMSet
numMLFs	HTKLib/HLabel.c	/^static int      numMLFs = 0;     \/* number of MLF files opened *\/$/;"	v	file:
numMacros	HTKLib/HModel.h	/^   int numMacros;          \/* num macros used in this set *\/$/;"	m	struct:_HMMSet
numMissing	HTKTools/HDMan.c	/^static int numMissing = 0;           \/* num words not found *\/$/;"	v	file:
numMix	HTKLib/HModel.h	/^   int numMix;             \/* Number of mixture components in HMMSet *\/$/;"	m	struct:_HMMSet
numNode	HTKLib/HNet.h	/^   int numNode;$/;"	m	struct:__anon128
numNodes	HTKLib/HModel.h	/^  int numNodes;        \/* number of non-terminal nodes in tree *\/$/;"	m	struct:RegTree
numNodes	HTKLib/HVQ.h	/^   short numNodes;      \/* total num nodes in all sub trees *\/$/;"	m	struct:_VQTabRec
numNodes	HTKTools/HParse.c	/^static long numNodes = 0;$/;"	v	file:
numNuisanceDim	HTKLib/HAdapt.c	/^static int numNuisanceDim = 0;$/;"	v	file:
numOut	HTKTools/HDMan.c	/^static int numOut = 0;               \/* num words processed *\/$/;"	v	file:
numOutMLF	HTKLib/HLabel.c	/^static int numOutMLF = 0;                   \/* number of output MLFs *\/ $/;"	v	file:
numParm	HTKLib/HAudio.c	/^static int numParm = 0;$/;"	v	file:
numParm	HTKLib/HLabel.c	/^static int numParm = 0;$/;"	v	file:
numParm	HTKLib/HMath.c	/^static int numParm = 0;$/;"	v	file:
numParm	HTKLib/HMem.c	/^static int numParm = 0;$/;"	v	file:
numParm	HTKLib/HSigP.c	/^static int numParm = 0;$/;"	v	file:
numParm	HTKLib/HVQ.c	/^static int numParm = 0;$/;"	v	file:
numParm	HTKLib/HWave.c	/^static int numParm = 0;$/;"	v	file:
numPhyHMM	HTKLib/HModel.h	/^   int numPhyHMM;          \/* Num of distinct physical HMM's *\/$/;"	m	struct:_HMMSet
numS	HTKTools/HList.c	/^static int numS = 1;             \/* number of streams *\/$/;"	v	file:
numSamples	HTKLib/HAudio.c	/^   int numSamples;$/;"	m	struct:_AudioIn	file:
numSamples	HTKLib/HAudio.c	/^   int numSamples;$/;"	m	struct:_AudioOut	file:
numSet	HTKTools/HSLab.c	/^static int numSet;              \/* number of alternative transcriptions *\/$/;"	v	file:
numSharedMix	HTKLib/HModel.h	/^   int numSharedMix;       \/* Number of shared mixtures in HMMSet *\/$/;"	m	struct:_HMMSet
numSharedStates	HTKLib/HModel.h	/^   int numSharedStates;    \/* Number of shared states in HMMSet *\/$/;"	m	struct:_HMMSet
numSpkrs	HTKTools/HResults.c	/^static int  numSpkrs  = 0;$/;"	v	file:
numStates	HTKLib/HModel.h	/^   int numStates;          \/* Number of states in HMMSet *\/$/;"	m	struct:_HMMSet
numStates	HTKLib/HModel.h	/^   short numStates;        \/* includes entry and exit states *\/$/;"	m	struct:__anon64
numTNodes	HTKLib/HModel.h	/^  int numTNodes;       \/* number of terminal nodes in tree *\/$/;"	m	struct:RegTree
numTests	HLMLib/LUtil.h	/^  long numTests;               \/* more access statistics *\/$/;"	m	struct:__anon23
numTests	HLMTools/LPlex.c	/^static int     numTests;            \/* number of tests to perform *\/$/;"	v	file:
numTests	HTKLib/HLabel.c	/^static long numTests = 0;$/;"	v	file:
numTransP	HTKLib/HModel.h	/^   int numTransP;          \/* Number of distinct transition matrices *\/$/;"	m	struct:_HMMSet
numTreeClust	HTKTools/HHEd.c	/^static int numTreeClust;        \/* number of clusters in tree *\/$/;"	v	file:
numWdBegin	HTKTools/HParse.c	/^static int numWdBegin=0;              \/* number of WORD_BEGIN nodes *\/$/;"	v	file:
numWdEnd	HTKTools/HParse.c	/^static int numWdEnd=0;                \/* number of WORD_END nodes *\/$/;"	v	file:
numWords	HTKLib/HLM.h	/^   lmCnt numWords;              \/* Number of words for language model *\/$/;"	m	struct:matbilm
numWrites	HTKLib/HAudio.c	/^   int numWrites;$/;"	m	struct:_AudioOut	file:
numXForms	HTKLib/HModel.h	/^  int numXForms;       \/* number of transforms in this xformset *\/$/;"	m	struct:__anon69
num_index	HTKLib/HFBLat.h	/^  float num_index; \/*make sure set. *\/$/;"	m	struct:__anon54
num_layer	HTKLib/HRNLM.h	/^    int num_layer, dim_fea, nclass, inputlayersize, outputlayersize;$/;"	m	struct:_RNNLM
num_topic	HTKLib/HRNLM.h	/^    int num_topic;$/;"	m	struct:_RNNLM
nwe	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nwi	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nword	HTKLib/HLM.h	/^   int nword;                   \/* accumumalte of number of words *\/$/;"	m	struct:lmpplexacc
nwords	HTKLib/HDict.h	/^   int nwords;          \/* total number of words *\/$/;"	m	struct:__anon74
nwords	HTKTools/HBuild.c	/^   int nwords;$/;"	m	struct:__anon164	file:
nxl	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nxt	HLMLib/LGBase.h	/^   UInt nxt[MAXNG];         \/* next expanded N-gram (no count) *\/$/;"	m	struct:__anon4
nxtInst	HTKLib/HRec.c	/^   NetInst *nxtInst;        \/* Inst used to select next in step sequence *\/$/;"	m	struct:precinfo	file:
nxtpath	HTKLib/HRec.c	/^struct nxtpath$/;"	s	file:
nz	HTKLib/HAudio.c	/^static int nz=0;$/;"	v	file:
o	HTKLib/HRNLM.h	/^    float *i, *f, *newc, *zi, *fc, *o;  \/* *c *z from GRU layer defination *\/$/;"	m	struct:_Layer
o	HTKLib/HTrain.h	/^   Observation o;       \/* used as an 'i\/o channel' to segstore *\/$/;"	m	struct:_SegStoreRec
oCnt	HTKLib/HParm.c	/^   int oCnt;              \/* Number of observations processed in session *\/$/;"	m	struct:channelinfo	file:
oStack	HTKTools/HCopy.c	/^static MemHeap oStack;          \/* output stack *\/$/;"	v	file:
oStreamFN	HTKTools/HLRescore.c	/^static char *oStreamFN = NULL;  \/* LM prob. stream output filename *\/$/;"	v	file:
oStreamFP	HTKLib/HLM.h	/^   FILE *oStreamFP;             \/* output LM prob. stream file pointer *\/$/;"	m	struct:lmpplexacc
object	HTKLib/HRNLM.h	/^    void*   object;  \/*  can store anything *\/$/;"	m	struct:_HashSlot
objects	HTKLib/Makefile	/^objects = HGraf.o esig_asc.o \\$/;"	m
objectsize	HTKLib/HRNLM.h	/^    unsigned int objectsize;$/;"	m	struct:__anon91
obs	HTKLib/HAdapt.c	/^   Vector obs;$/;"	m	struct:_ObsCache	file:
obs	HTKLib/HRec.c	/^   Observation *obs;         \/* Current Observation *\/$/;"	m	struct:precinfo	file:
obs	HTKTools/HCompV.c	/^static Observation obs;             \/* storage for observations  *\/$/;"	v	file:
obs	HTKTools/HQuant.c	/^static Observation obs;             \/* storage for observations  *\/$/;"	v	file:
obs	HTKTools/HVite.c	/^static Observation obs;           \/* current observation *\/$/;"	v	file:
obsFmt	HTKTools/HList.c	/^static Boolean obsFmt  = FALSE;  \/* print observation format *\/$/;"	v	file:
obsVec	HTKLib/HAdapt.c	/^   Vector  obsVec;$/;"	m	struct:__anon94	file:
obyte_order	HTKLib/HAudio.c	/^   char *obyte_order;$/;"	m	struct:_AudioIn	file:
obyte_order	HTKLib/HAudio.c	/^   char *obyte_order;$/;"	m	struct:_AudioOut	file:
oc	HTKLib/HAdapt.c	/^   ObsCache *oc;         \/* observation cache for input transform *\/$/;"	m	struct:__anon95	file:
occ	HTKLib/HAdapt.c	/^   double occ;  $/;"	m	struct:__anon92	file:
occ	HTKLib/HAdapt.c	/^   float occ;$/;"	m	struct:__anon94	file:
occ	HTKLib/HFBLat.c	/^   float occ;$/;"	m	struct:__anon90	file:
occ	HTKLib/HTrain.h	/^   Vector occ;       \/* array[1..N] of state occupation *\/$/;"	m	struct:__anon111
occ	HTKLib/HTrain.h	/^   float occ;        \/* occ for states sharing this mpdf *\/$/;"	m	struct:__anon113
occ	HTKLib/HTrain.h	/^   float occ;        \/* occ for states sharing this mpdf *\/$/;"	m	struct:__anon114
occ	HTKLib/HTrain.h	/^   float occ;        \/* occ for states sharing this pdf *\/$/;"	m	struct:__anon112
occ	HTKTools/HHEd.c	/^   float  occ;$/;"	m	struct:_AccSum	file:
occ	HTKTools/HHEd.c	/^   float occ;                   \/* total occupation count *\/$/;"	m	struct:_Node	file:
occ	HTKTools/HSmooth.c	/^   float occ;        \/* occ for states sharing this pdf *\/$/;"	m	struct:_ChWtAcc	file:
occStatsLoaded	HTKTools/HHEd.c	/^static Boolean occStatsLoaded = FALSE; \/* set when RO\/LS has loaded occ stats *\/$/;"	v	file:
occa	HTKLib/HFB.h	/^  Vector *occa;       \/* array[1..Q][1..Nq] of occ probs (trace only) *\/$/;"	m	struct:__anon138
occr	HTKTools/HRest.c	/^static Vector occr;        \/* array[1..nStates-1] of occ count for cur time *\/$/;"	v	file:
occs	HTKTools/HHEd.c	/^static float occs[2];           \/* array[Boolean]of occupation counts *\/$/;"	v	file:
occt	HTKLib/HFB.h	/^  Vector occt;        \/* occ probs for current time t *\/$/;"	m	struct:__anon138
occurrence	HTKLib/esignal.h	/^    short       occurrence;     \/* REQUIRED, GLOBAL, OPTIONAL, etc. *\/$/;"	m	struct:FieldSpec
off	HTKTools/HCopy.c	/^static HTime off = 0.0;         \/* length of files appended so far *\/$/;"	v	file:
offset	HTKLib/HLabel.h	/^   long offset;   \/* offset into MLF file *\/$/;"	m	struct:__anon117
offset	HTKLib/esignal.h	/^    double      scale, offset;  \/* scale factor and offset relating$/;"	m	struct:FieldSpec
oflags	HTKTools/HCompV.c	/^static char oflags[MAXSTRLEN] = "m";     \/* export flags for CMV *\/  $/;"	v	file:
ofmt	HTKTools/HLEd.c	/^static FileFormat ofmt=UNDEFF;      \/* Label output file format *\/$/;"	v	file:
ofmt	HTKTools/HLRescore.c	/^static FileFormat ofmt=UNDEFF;  \/* Label output file format *\/$/;"	v	file:
ofmt	HTKTools/HSLab.c	/^static FileFormat ofmt=UNDEFF;      \/* Label output file format *\/$/;"	v	file:
ofmt	HTKTools/HVite.c	/^static FileFormat ofmt=UNDEFF;    \/* Label output file format *\/$/;"	v	file:
old_classes	HTKLib/HRNLM.h	/^    int old_classes;$/;"	m	struct:_RNNLM
oldincludedir	HTKLib/Makefile	/^oldincludedir = \/usr\/include$/;"	m
oldincludedir	HTKTools/Makefile	/^oldincludedir = \/usr\/include$/;"	m
oldmap	HTKTools/HLEd.c	/^static char oldmap[] = " RCFMDXZBEISWVLGTY ";$/;"	v	file:
omap	HLMTools/LGCopy.c	/^static WordMap    *omap = NULL;     \/* output buffer map *\/$/;"	v	file:
omap	HLMTools/LSubset.c	/^static WordMap  *omap;           \/* the ouput word\/class map *\/$/;"	v	file:
omapFN	HLMTools/LAdapt.c	/^static char *omapFN  = "wmap";      \/* output word map file name *\/$/;"	v	file:
omapFN	HLMTools/LGCopy.c	/^static char *omapFN  = NULL;        \/* output map filename *\/$/;"	v	file:
omapFN	HLMTools/LGPrep.c	/^static char *omapFN  = NULL;        \/* output word map filename *\/$/;"	v	file:
omapFN	HLMTools/LSubset.c	/^static char     *omapFN;         \/* output map filename *\/$/;"	v	file:
one_iter	HTKLib/HRNLM.h	/^    int one_iter;$/;"	m	struct:_RNNLM
ooo	HTKLib/HRec.c	/^   Boolean ooo;         \/* Instance potentially out of order *\/$/;"	m	struct:_NetInst	file:
oosNodeClass	HTKLib/HRNLM.c	/^static int oosNodeClass=-1;         \/*  default : derived implicitly from output list *\/$/;"	v	file:
oosNodeWord	HTKLib/HRNLM.c	/^static char* oosNodeWord="<OOS>";$/;"	v	file:
oov	HLMTools/LPlex.c	/^   OOVEntry oov[MAX_OOV];   \/* array of OOVs *\/$/;"	m	struct:__anon33	file:
op	HTKTools/HDMan.c	/^   EdOp op;$/;"	m	struct:__anon159	file:
op	HTKTools/HLEd.c	/^   EdOp op;$/;"	m	struct:__anon142	file:
op	HTKTools/HSLab.c	/^   OpType op;           \/* the operation carried out *\/$/;"	m	struct:__anon147	file:
openviron	HTKBook/htkbook-pdf.tex	/^\\part{HTK in Depth}$/;"	i
openviron	HTKBook/htkbook.tex	/^\\part{HTK in Depth}$/;"	i
optSet	HTKLib/HModel.h	/^   Boolean optSet;         \/* true if global options have been set *\/$/;"	m	struct:_HMMSet
origMLPNSize	HTKLib/HLM.c	/^static int origMLPNSize = 4;            \/* Allow specification MLP SIZE on command line *\/$/;"	v	file:
orphanMacFile	HTKLib/HModel.c	/^static char orphanMacFile[100];         \/* last resort file for new macros *\/$/;"	v	file:
osamples	HTKLib/HAudio.c	/^   long osamples;            \/* Sample rate *\/$/;"	m	struct:_AudioIn	file:
osamples	HTKLib/HAudio.c	/^   long osamples;            \/* Sample rate *\/$/;"	m	struct:_AudioOut	file:
ospfn	HTKTools/HSLab.c	/^static char *ospfn = "noname.wav";         \/* the speech file name on the command line *\/$/;"	v	file:
ot	HTKLib/HFB.h	/^  Observation ot;      \/* Observation at time t ... *\/$/;"	m	struct:__anon136
ot2	HTKLib/HFB.h	/^  Observation ot2;     \/* Cepstral Mean Normalised obervation, used in$/;"	m	struct:__anon136
otprob	HTKLib/HArc.h	/^  float ****otprob; \/* [myArc->t_start..myArc->t_end][0..(S>1?S:0)][2..Nq-1][0..(M>1)?M:0] *\/$/;"	m	struct:_Acoustic
otprob	HTKLib/HFB.h	/^  float *****otprob;  \/* array[1..T][1..Q][2..Nq-1][0..S][0..M] of prob *\/$/;"	m	struct:__anon138
outBufPos	HTKLib/HAudio.c	/^   int outBufPos;            \/* Position to read out of buffer *\/$/;"	m	struct:_AudioIn	file:
outCMapRaw	HLMLib/LCMap.c	/^static Boolean outCMapRaw = FALSE;       \/* Output file in raw mode *\/$/;"	v	file:
outCMapRaw	HLMTools/Cluster.c	/^static Boolean     outCMapRaw = FALSE;      \/* Output classes in raw mode *\/$/;"	v	file:
outCMapRawTrap	HLMTools/Cluster.c	/^static Boolean     outCMapRawTrap = FALSE;  \/* Has this been changed by config file? *\/$/;"	v	file:
outConn	HTKLib/HAudio.c	/^   char outConn[30];   $/;"	m	struct:_AudioOut	file:
outDictFn	HLMTools/HLMCopy.c	/^static char      *outDictFn = NULL;      \/* dictionary to write *\/$/;"	v	file:
outDir	HTKTools/HCompV.c	/^static char *outDir=NULL;           \/* HMM output directory *\/$/;"	v	file:
outDir	HTKTools/HInit.c	/^static char *outDir=NULL;           \/* HMM output directory *\/$/;"	v	file:
outDir	HTKTools/HRest.c	/^static char * outDir = NULL;     \/* output macro file directory, if any *\/$/;"	v	file:
outFN	HLMTools/LAdapt.c	/^static char *outFN   = NULL;        \/* output LM filename *\/$/;"	v	file:
outLabDir	HTKTools/HCopy.c	/^static char *outLabDir = NULL;  \/* output label dir *\/$/;"	v	file:
outLayerLogNorm	HTKLib/HRNLM.c	/^static LogFloat outLayerLogNorm = -1;$/;"	v	file:
outMLF	HTKLib/HLabel.c	/^static FILE *outMLF = NULL;                 \/* output MLF file, if any *\/ $/;"	v	file:
outMLFSet	HTKLib/HLabel.c	/^static OutMLFEntry outMLFSet[MAXMLFS];      \/* array of output MLFs *\/$/;"	v	file:
outMapped	HLMTools/LGCopy.c	/^static Boolean outMapped = FALSE;   \/* output mapped IDs only *\/$/;"	v	file:
outPStats	HTKTools/HResults.c	/^static Boolean outPStats  = FALSE;    \/* enable phoneme statistics *\/$/;"	v	file:
outP_arr	HTKLib/HNLM.h	/^   float *outP_arr;             \/* Output prob array cache - only for most recent call *\/$/;"	m	struct:nnlm
outP_arr	HTKLib/HRNLM.h	/^    float *outP_arr;$/;"	m	struct:_RNNLM
outRow	HTKLib/HParm.c	/^   int outRow;         \/*   of next row to return (may be in any block) *\/$/;"	m	struct:_ParmBuf	file:
outSilWarn	HTKLib/HParm.c	/^   Boolean outSilWarn;        \/* Give Warning when SilMeas *\/$/;"	m	struct:__anon76	file:
outSpkrPat	HTKLib/HAdapt.h	/^  char *outSpkrPat;$/;"	m	struct:__anon37
outStream	HLMTools/LPlex.c	/^FILE *outStream;$/;"	v
outStreamFN	HLMTools/LPlex.c	/^static char *outStreamFN = NULL;$/;"	v	file:
outSym	HTKLib/HDict.h	/^   LabId outSym;   \/* Output symbol generated when pronunciation recognised *\/$/;"	m	struct:_WordPron
outTrans	HTKTools/HResults.c	/^static Boolean outTrans   = FALSE;    \/* enable transcription output *\/$/;"	v	file:
outWMapRaw	HLMLib/LWMap.c	/^static Boolean outWMapRaw = FALSE;   \/* Output file in raw mode *\/$/;"	v	file:
outXForm	HTKLib/HAdapt.c	/^static AdaptXForm* outXForm = NULL;$/;"	v	file:
outXForm	HTKLib/HAdapt.h	/^  AdaptXForm *outXForm;$/;"	m	struct:__anon37
outXFormDir	HTKLib/HAdapt.h	/^  char *outXFormDir;$/;"	m	struct:__anon37
outXFormExt	HTKLib/HAdapt.h	/^  char *outXFormExt;$/;"	m	struct:__anon37
out_num_word	HTKLib/HNLM.h	/^   int out_num_word;            \/* Output layer vocab size *\/$/;"	m	struct:nnlm
out_num_word	HTKLib/HRNLM.h	/^    int     out_num_word;           \/*  output vocab size *\/$/;"	m	struct:_RNNLM
out_oos_nodeid	HTKLib/HRNLM.h	/^    int out_oos_nodeid;             \/*  position of oos node in out_vocab *\/$/;"	m	struct:_RNNLM
out_vocab	HTKLib/HRNLM.h	/^    HashTable out_vocab;            \/*  output vocab*\/$/;"	m	struct:_RNNLM
outbuf	HTKTools/HDMan.c	/^static DBuffer outbuf;               \/* the output buffer with its global script *\/$/;"	v	file:
outfile	HTKTools/HDMan.c	/^static FILE *outfile = NULL;         \/* The output file *\/$/;"	v	file:
outfn	HTKTools/HCompV.c	/^static char *outfn=NULL;            \/* output HMM file name (name only) *\/$/;"	v	file:
outfn	HTKTools/HInit.c	/^static char *outfn=NULL;            \/* output HMM file name (name only) *\/$/;"	v	file:
outfn	HTKTools/HRest.c	/^static char *outfn=NULL;         \/* output definition file name *\/$/;"	v	file:
outlierThresh	HTKTools/HHEd.c	/^static float outlierThresh = -1.0;     \/* outlier threshold set by RO cmd *\/$/;"	v	file:
outmap	HTKLib/HNLM.h	/^   String2IndexMap outmap;	\/* Output String to Index Map *\/$/;"	m	struct:nnlm
outp	HTKLib/HRec.c	/^   LogFloat outp;           \/* State\/mixture output likelihood *\/$/;"	m	struct:precomp	file:
outprob	HTKTools/HRest.c	/^static Matrix outprob;     \/* array[2..nStates-1][1..maxT] of output prob *\/$/;"	v	file:
outputContainOOS	HTKLib/HRNLM.c	/^static Boolean outputContainOOS= TRUE;$/;"	v	file:
outputlayersize	HTKLib/HRNLM.h	/^    int num_layer, dim_fea, nclass, inputlayersize, outputlayersize;$/;"	m	struct:_RNNLM
outsym	HTKTools/HDMan.c	/^   LabId outsym;                \/* name of output symbol if any *\/$/;"	m	struct:__anon161	file:
outx	HTKLib/HAudio.c	/^   int inx,outx;         \/* in\/out indices - wrap modulo size *\/$/;"	m	struct:__anon53	file:
owner	HTKLib/HModel.h	/^   HLink owner;      \/* HMM owning this item *\/$/;"	m	struct:_ItemRec
owner	HTKLib/HModel.h	/^   struct _HMMSet *owner;  \/* owner of this model *\/$/;"	m	struct:__anon64	typeref:struct:__anon64::_HMMSet
pCntr	HTKTools/HLStats.c	/^   Cntr *pCntr;                  \/* Physical counter *\/$/;"	m	struct:wordinfo	file:
pCollThresh	HTKLib/HRec.h	/^   int pCollThresh;         \/* Max path records created before collection *\/$/;"	m	struct:vrecinfo
pCountLimit	HTKTools/HLStats.c	/^static int pCountLimit  = -1;       \/* max occurrences to list for pCount *\/$/;"	v	file:
pHead	HTKLib/HAudio.c	/^   mmApiBuf *pHead;         \/* Head of buffer list *\/$/;"	m	struct:_AudioOut	file:
pInfo	HTKLib/HFB.h	/^  PruneInfo *pInfo;   \/* pruning information *\/$/;"	m	struct:__anon138
pLab	HLMTools/LPlex.c	/^static LabId pLab[LBUF_SIZE];       \/* label array *\/$/;"	v	file:
pListFN	HTKTools/HDMan.c	/^static char *pListFN = NULL;         \/* name of phone list file *\/$/;"	v	file:
pNoRef	HTKLib/HRec.c	/^   Path pNoRef;             \/* Head of PathNoRef linked list *\/$/;"	m	struct:precinfo	file:
pNoTail	HTKLib/HRec.c	/^   Path pNoTail;            \/* Tail of PathNoRef linked list *\/$/;"	m	struct:precinfo	file:
pSize	HTKTools/HLStats.c	/^static int pSize;                \/* Number of physical labels *\/$/;"	v	file:
pTab	HTKTools/HLStats.c	/^static Cntr *pTab;               \/* Table of physical counts *\/$/;"	v	file:
pTail	HTKLib/HAudio.c	/^   mmApiBuf *pTail;         \/* Tail of buffer list *\/$/;"	m	struct:_AudioOut	file:
pYesRef	HTKLib/HRec.c	/^   Path pYesRef;            \/* Head of PathYesRef linked list *\/$/;"	m	struct:precinfo	file:
pYesTail	HTKLib/HRec.c	/^   Path pYesTail;           \/* Tail of PathYesRef linked list *\/$/;"	m	struct:precinfo	file:
paInfo	HTKLib/HAdapt.c	/^   AInfo *paInfo;        \/* parent transform information *\/$/;"	m	struct:__anon95	file:
paSpkrPat	HTKLib/HAdapt.h	/^  char *paSpkrPat;$/;"	m	struct:__anon37
paXForm	HTKLib/HAdapt.h	/^  AdaptXForm *paXForm;$/;"	m	struct:__anon37
paXForm	HTKLib/HFB.h	/^  AdaptXForm *paXForm;\/* current parent transform (if any) *\/$/;"	m	struct:__anon139
paXForm	HTKLib/HFBLat.h	/^  AdaptXForm *paXForm;\/* current parent transform (if any) *\/$/;"	m	struct:__anon54
paXFormDir	HTKLib/HAdapt.h	/^  char *paXFormDir;$/;"	m	struct:__anon37
paXFormExt	HTKLib/HAdapt.h	/^  char *paXFormExt;$/;"	m	struct:__anon37
paac	HTKLib/HAdapt.c	/^   AccCache *paac;       \/* accummulator cache for parent transform *\/$/;"	m	struct:__anon95	file:
pact	HLMTools/LGPrep.c	/^   float pact;                \/* % applic factor *\/$/;"	m	struct:ruledef	file:
padStartWord	HTKLib/HLM.c	/^static Boolean padStartWord = FALSE;    \/* Padding start word for MLP LM *\/$/;"	v	file:
paoc	HTKLib/HAdapt.c	/^   ObsCache *paoc;       \/* observation cache for parent transform *\/$/;"	m	struct:__anon95	file:
parMode	HTKTools/HERest.c	/^static int parMode   = -1;       \/* enable one of the \/\/ modes *\/$/;"	v	file:
parMode	HTKTools/HMMIRest.c	/^static int parMode   = -1;       \/* enable one of the parallel modes *\/$/;"	v	file:
param	HTKLib/HShell.c	/^   ConfParam param;$/;"	m	struct:_ConfigEntry	file:
params	HTKLib/HAudio.c	/^   long params[2];           \/* parameter array *\/$/;"	m	struct:_AudioIn	file:
params	HTKLib/HAudio.c	/^   long params[6];           \/* parameter array *\/$/;"	m	struct:_AudioOut	file:
parc	HTKLib/HNet.h	/^   ArcId parc;         \/* Next arc preceding end node *\/$/;"	m	struct:larc
parc	HTKLib/HNet.h	/^   ArcId parc;$/;"	m	struct:larc_s
parc	HTKLib/HNet.h	/^   EArcId parc;        \/* Next arc preceding end node *\/$/;"	m	struct:larc_e
parent	HLMLib/LModel.h	/^   struct _FLEntry *parent; \/* parent FLEntry - used when reconstructing context *\/$/;"	m	struct:_FLEntry	typeref:struct:_FLEntry::_FLEntry
parent	HTKTools/HHEd.c	/^   struct _Node *parent;        \/* parent of this node *\/$/;"	m	struct:_Node	typeref:struct:_Node::_Node	file:
parentLarc	HTKLib/HArc.h	/^  LArc *parentLarc; \/*the word arc in the Lattice from which this was derived.*\/$/;"	m	struct:_Arc
parentXForm	HTKLib/HModel.h	/^   AdaptXForm *parentXForm;$/;"	m	struct:_HMMSet
parentXForm	HTKLib/HModel.h	/^  struct _AdaptXForm *parentXForm;  \/* parent transform, NULL if no parent parenttransform *\/$/;"	m	struct:_AdaptXForm	typeref:struct:_AdaptXForm::_AdaptXForm
parmHeap	HTKLib/HParm.c	/^static MemHeap parmHeap;                \/* HParm no longer uses gstack *\/$/;"	v	file:
parms	HTKLib/HAudio.c	/^   SSPlayParams parms;$/;"	m	struct:_AudioOut	file:
parms	HTKLib/HAudio.c	/^   SSRecordParams parms;$/;"	m	struct:_AudioIn	file:
parsePhysicalHMM	HTKLib/HUtil.c	/^static Boolean parsePhysicalHMM = FALSE;$/;"	v	file:
pat	HTKTools/HHEd.c	/^   char *pat;$/;"	m	struct:_IPat	file:
patHash	HTKLib/HLabel.h	/^   unsigned patHash;    \/* hash of pattern if not general *\/$/;"	m	struct:_MLFEntry
patList	HTKTools/HHEd.c	/^   IPat *patList;               $/;"	m	struct:_QEnt	file:
patType	HTKLib/HLabel.h	/^   MLFPatType patType;  \/* type of pattern *\/$/;"	m	struct:_MLFEntry
path	HTKLib/HRec.c	/^   Path *path;          \/* Route (word level) through network *\/$/;"	m	struct:reltoken	file:
path	HTKLib/HRec.h	/^   Path *path;		\/* Route (word level) through network *\/$/;"	m	struct:token
path	HTKLib/HRec.h	/^struct path$/;"	s
pathHeap	HTKLib/HRec.c	/^   MemHeap pathHeap;        \/* Path heap *\/$/;"	m	struct:precinfo	file:
pathPattern	HTKTools/HCompV.c	/^static char pathPattern[MAXSTRLEN];      \/* path mask *\/$/;"	v	file:
pattern	HTKLib/HLabel.h	/^   char *pattern;       \/* pattern to match for this definition *\/$/;"	m	struct:_MLFEntry
pattern	HTKLib/HUtil.c	/^static char pattern[PAT_LEN];  \/* A copy of the last pattern parsed *\/$/;"	v	file:
pattern	HTKTools/HLEd.c	/^   LabId *pattern;      \/* pattern to find *\/$/;"	m	struct:_FindAcc	file:
pb	HTKTools/HCopy.c	/^static ParmBuf pb;              \/* main parmBuf; cat input, xform wv to this *\/$/;"	v	file:
pbStatMap	HTKLib/HParm.c	/^static char * pbStatMap[] = { $/;"	v	file:
pbValid	HTKLib/HShell.h	/^   Boolean pbValid;     \/* true if putback holds char *\/$/;"	m	struct:__anon84
pblock	HTKLib/HParm.c	/^typedef struct pblock {$/;"	s	file:
pbuf	HTKLib/HFB.h	/^  ParmBuf pbuf;       \/* parameter buffer *\/$/;"	m	struct:__anon136
pbuf	HTKTools/HDMan.c	/^   Pronunciation pbuf;          \/* and its pronunciation - for lookahead *\/$/;"	m	struct:__anon162	file:
pbuf	HTKTools/HInit.c	/^static ParmBuf pbuf;             \/* Currently input parm buffer *\/$/;"	v	file:
pbuf	HTKTools/HRest.c	/^static ParmBuf pbuf;             \/* Currently input parm buffer *\/$/;"	v	file:
pbuf2	HTKLib/HFB.h	/^  ParmBuf pbuf2;      \/* a second parameter buffer (if required) *\/$/;"	m	struct:__anon136
pclose	HTKLib/HShell.c	921;"	d	file:
pcra	HTKLib/HNet.h	/^   EArcId pcra;        \/*  to easy deletetion *\/$/;"	m	struct:larc_e
pde	HTKLib/HFB.c	/^static Boolean pde = FALSE;  \/* partial distance elimination *\/$/;"	v	file:
pde1BlockEnd	HTKLib/HModel.c	/^static int pde1BlockEnd = 13;          \/* size of PDE blocks *\/$/;"	v	file:
pde2BlockEnd	HTKLib/HModel.c	/^static int pde2BlockEnd = 26;          \/* size of PDE blocks *\/$/;"	v	file:
pdeTh1	HTKLib/HModel.c	/^static LogFloat pdeTh1 = -5.0;         \/* threshold for 1\/3 PDE *\/$/;"	v	file:
pdeTh2	HTKLib/HModel.c	/^static LogFloat pdeTh2 = 0.0;          \/* threshold for 2\/3 PDE *\/$/;"	v	file:
pdf	HTKLib/HModel.h	/^   StreamElem *pdf;     \/* array[1..numStreams] of StreamElem *\/$/;"	m	struct:__anon62
pen	HTKLib/HLM.h	/^   LogFloat pen;                \/* Word insertion penalty *\/$/;"	m	struct:lmodel
period	HTKTools/HList.c	/^   HTime period;$/;"	m	struct:__anon153	file:
permHeap	HLMTools/LPlex.c	/^MemHeap permHeap;                   \/* Stores global stats *\/$/;"	v
permHeap	HTKTools/HLEd.c	/^static MemHeap permHeap;            \/* Permanent storage *\/$/;"	v	file:
permHeap	HTKTools/HResults.c	/^MemHeap permHeap;                     \/* Stores global stats *\/$/;"	v
phnInsPen	HTKLib/HExactMPE.c	/^static float phnInsPen = 0.0;    \/* repeat of config also used in HFBLat.c *\/$/;"	v	file:
phnInsPen	HTKLib/HFBLat.c	/^static float phnInsPen = 0.0;                 \/* Insertion penalty for each phone, not subject to lm scaling.  Normally zero, but setting it to e.g.$/;"	v	file:
phone	HTKLib/HArc.h	/^  LabId phone;         \/* phone-in-context. *\/$/;"	m	struct:_Arc
phone	HTKTools/HDMan.c	/^   LabId phone[MAXPHONES];$/;"	m	struct:__anon160	file:
phoneStr	HTKTools/HResults.c	/^static char * phoneStr  = "WORD";     \/* label for phone level stats *\/$/;"	v	file:
phonebuf	HTKTools/HParse.c	/^static LabId phonebuf[MAXPHONES];   \/* space to store the current pronunciation *\/$/;"	v	file:
phones	HTKLib/HDict.h	/^   LabId *phones;  \/* Array[0..nphones-1] of phones *\/$/;"	m	struct:_WordPron
phones	HTKLib/HNet.c	/^   LabId *phones;   \/* Phone sequence for the instance *\/$/;"	m	struct:pronholder	file:
phones	HTKLib/HNet.c	/^   LabId *phones;$/;"	m	struct:pinstinfo	file:
phonesHeap	HTKLib/HDict.h	/^   MemHeap phonesHeap;  \/* for arrays of phones   *\/$/;"	m	struct:__anon74
phonesOut	HTKLib/HAudio.c	/^static Boolean phonesOut = TRUE;$/;"	v	file:
phraseStr	HTKTools/HResults.c	/^static char * phraseStr = "SENT";     \/* label for phrase level stats *\/$/;"	v	file:
phrcor	HTKTools/HResults.c	/^   int nsyms,nphr,phrcor;$/;"	m	struct:_Spkr	file:
phrcor	HTKTools/HResults.c	/^static long phrcor= 0;     \/* Phrase correct *\/$/;"	v	file:
pinstinfo	HTKLib/HNet.c	/^typedef struct pinstinfo {$/;"	s	file:
pipe_logfile	HLMTools/Cluster.c	/^static Boolean      pipe_logfile;           \/* HShell file handling - using pipe? *\/$/;"	v	file:
pk	HTKLib/HParm.c	/^   ParmKind pk;       \/* Type of source - split into parmKind and *\/$/;"	m	struct:hparmsrcdef	file:
pk	HTKLib/HParm.h	/^   ParmKind pk;          \/* parm kind of this obs (bk or DISCRETE) *\/$/;"	m	struct:__anon120
pkind	HTKLib/HModel.c	/^   ParmKind pkind;      \/* samp kind when sym==PARMKIND *\/$/;"	m	struct:__anon42	file:
pkind	HTKLib/HModel.h	/^   ParmKind pkind;         \/* kind of obs vector components *\/$/;"	m	struct:_HMMSet
pkind	HTKLib/HModel.h	/^  ParmKind pkind;      \/* parameter kind for xform to be applied to *\/$/;"	m	struct:__anon70
playPort	HTKLib/HAudio.c	/^   ALport playPort;          \/* SGI audio port *\/$/;"	m	struct:_AudioOut	file:
playVol	HTKTools/HSLab.c	/^static short playVol = 0;    \/* the volume for playing samples *\/$/;"	v	file:
plotBuf	HTKTools/HSLab.c	/^static int *plotBuf;         \/* buffer to store waveform samples to plot *\/$/;"	v	file:
pmap	HTKLib/HModel.h	/^   PtrMap ** pmap;         \/* Array[0..PTRHASHSIZE-1]OF PtrMap* *\/$/;"	m	struct:_HMMSet
pmean	HTKLib/HRNLM.c	/^static Vector hists, mean, pmean, pvar, var;$/;"	v	file:
pmkmap	HTKLib/HParm.c	/^static char *pmkmap[] = {"WAVEFORM", "LPC", "LPREFC", "LPCEPSTRA", $/;"	v	file:
pnlen	HTKLib/HRec.c	/^   int pnlen;               \/* Number of PathNoRef list *\/$/;"	m	struct:precinfo	file:
pnum	HTKLib/HDict.h	/^   short pnum;     \/* Pronunciation number 1..nprons *\/$/;"	m	struct:_WordPron
pobcaStack	HTKLib/HAdapt.c	/^static MemHeap pobcaStack; \/* parent obscache *\/$/;"	v	file:
pool	HLMLib/LGBase.h	/^   UInt *pool;             \/* array[0..used-1] of ngrams *\/$/;"	m	struct:__anon6
poolsize	HLMLib/LGBase.h	/^   int poolsize;           \/* number of N-gram slots in pool *\/$/;"	m	struct:__anon6
popen	HTKLib/HShell.c	920;"	d	file:
pos	HTKLib/HArc.h	/^  int pos;       \/*the position of this phone in the word arc.*\/$/;"	m	struct:_Arc
pos	HTKLib/HNLM.h	/^    fpos_t pos;             \/* The location of the matrix in the file.*\/$/;"	m	struct:matinfo
posBuf	HLMTools/LGPrep.c	/^static ShiftReg posBuf;             \/* N-grams from edited text *\/$/;"	v	file:
position	HTKLib/HUtil.c	/^static char *position;         \/*  and the current position in copy *\/$/;"	v	file:
position	HTKLib/esignal.h	/^    int     position;$/;"	m	struct:Annot
postFrames	HTKLib/HParm.c	/^   int postFrames;$/;"	m	struct:__anon76	file:
ppinfo	HTKLib/HLM.h	/^   LMPPlexAcc *ppinfo;          \/* LM perplexity information *\/$/;"	m	struct:lmodel
pr	HTKLib/HFB.h	/^  LogDouble pr;        \/* log prob of current utterance *\/$/;"	m	struct:__anon136
pr	HTKLib/HFB.h	/^  LogDouble pr;       \/* log prob of current utterance *\/$/;"	m	struct:__anon138
pr	HTKLib/HFBLat.h	/^  LogDouble pr;$/;"	m	struct:__anon54
prC	HTKLib/HTrain.c	/^static int muC,vaC,trC,wtC,prC;$/;"	v	file:
prData	HTKTools/HList.c	/^static Boolean prData  = TRUE;   \/* print data *\/$/;"	v	file:
prScale	HTKTools/HLRescore.c	/^static double prScale = 1.0;    \/* pronunciation scale factor *\/$/;"	v	file:
prScale	HTKTools/HVite.c	/^static double prScale = 1.0;      \/* pronunciation scale factor *\/$/;"	v	file:
preEmph	HTKLib/HParm.c	/^   float preEmph;             \/* PreEmphasis Coef *\/$/;"	m	struct:__anon76	file:
preFrames	HTKLib/HParm.c	/^   int preFrames;$/;"	m	struct:__anon76	file:
preQual	HTKLib/HModel.h	/^  Boolean preQual;     \/* is this applied prior to qualifiers? *\/$/;"	m	struct:__anon70
preQual	HTKLib/HParm.c	/^   Boolean preQual;$/;"	m	struct:__anon76	file:
prec	HTKLib/HArc.h	/^  HArc *prec;$/;"	m	struct:_Arc
precTrans	HTKLib/HArc.h	/^  ArcTrans *precTrans;$/;"	m	struct:_Arc
precTrans	HTKLib/HArc.h	/^  CorrA *precTrans;$/;"	m	struct:_CorrN
precinfo	HTKLib/HRec.c	/^struct precinfo {$/;"	s	file:
precomp	HTKLib/HRec.c	/^typedef struct precomp$/;"	s	file:
pred	HTKLib/HLabel.h	/^   LLink pred;              \/* Preceding label *\/$/;"	m	struct:_Label
pred	HTKLib/HNet.h	/^   ArcId pred;         \/* Linked list of arcs preceding node *\/$/;"	m	struct:lnode
pred	HTKTools/HParse.c	/^   LinkSet *pred;    \/* predecessors to this node *\/$/;"	m	struct:_Node	file:
prefix	HTKLib/Makefile	/^prefix = \/usr\/local$/;"	m
prefix	HTKTools/Makefile	/^prefix = \/usr\/local$/;"	m
present	HTKLib/esignal.h	/^    Bool	present;	\/* is OPTIONAL field present in record? *\/$/;"	m	struct:FieldSpec
prev	HTKLib/HArc.h	/^  CorrN *prev;$/;"	m	struct:_CorrN
prev	HTKLib/HAudio.c	/^   struct mmapibuf *prev;$/;"	m	struct:mmapibuf	typeref:struct:mmapibuf::mmapibuf	file:
prev	HTKLib/HRec.c	/^   Align *prev;         \/* Previous align record *\/$/;"	m	struct:align	file:
prev	HTKLib/HRec.c	/^   NBestEntry *prev;$/;"	m	struct:nbestentry	file:
prev	HTKLib/HRec.c	/^   Path *prev;          \/* Previous word record *\/$/;"	m	struct:nxtpath	file:
prev	HTKLib/HRec.h	/^   Path *prev;		\/* Previous word record *\/$/;"	m	struct:path
prev	HTKTools/HHEd.c	/^   struct _Node *prev;          \/* leaf nodes *\/$/;"	m	struct:_Node	typeref:struct:_Node::_Node	file:
pri	HTKLib/HRec.c	/^static PRecInfo *pri;$/;"	v	file:
pri	HTKLib/HRec.h	/^   PRecInfo *pri;           \/* Private recognition information *\/$/;"	m	struct:vrecinfo
prid	HTKLib/HRec.c	/^   int prid;                \/* Unique pri identifier *\/$/;"	m	struct:precinfo	file:
printMean	HTKLib/HRNLM.c	/^void printMean(int ndim)$/;"	f
printOOV	HLMTools/LPlex.c	/^static Boolean printOOV = FALSE;    \/* print uniqe OOV's and their frequencies *\/$/;"	v	file:
printVariance	HTKLib/HRNLM.c	/^void printVariance (int ndim)$/;"	f
printVersionInfo	HTKLib/HShell.c	/^static Boolean printVersionInfo = FALSE; \/* request version info *\/$/;"	v	file:
printnum	HTKLib/HRNLM.c	/^static int printnum = 20;$/;"	v	file:
prlike	HTKLib/HNet.h	/^   LogFloat prlike;    \/* Pronunciation likelihood of arc *\/$/;"	m	struct:larc
prob	HLMLib/LModel.c	/^   double prob;         \/* sum of prob   returned *\/$/;"	m	struct:_AccessInfo	file:
prob	HLMLib/LModel.h	/^   LM_Prob prob;            \/* probability *\/$/;"	m	struct:_SMEntry
prob	HLMLib/LModel.h	/^  float  prob;               \/* log probability of word: word|class *\/$/;"	m	struct:__anon15
prob	HTKLib/HDict.h	/^   LogFloat prob;  \/* Log probability of pronunciation *\/$/;"	m	struct:_WordPron
prob	HTKLib/HLM.h	/^   float prob;                  \/* probability *\/$/;"	m	struct:sentry
prob	HTKLib/HModel.h	/^   float prob;           \/* mixture prob scaled by maxP *\/$/;"	m	struct:__anon59
prob	HTKLib/HRNLM.h	/^    real prob;$/;"	m	struct:vocab_word
prob	HTKLib/HTrain.h	/^   LogFloat prob;    \/* PreComputed Mixture Log Prob *\/$/;"	m	struct:__anon115
prob	HTKLib/HTrain.h	/^   float *prob;      \/* PreComputed mixture Log Probs *\/$/;"	m	struct:__anon112
prob	HTKTools/HDMan.c	/^   float prob;$/;"	m	struct:__anon160	file:
prob2	HLMLib/LModel.c	/^   double prob2;        \/* sum of prob^2 returned *\/$/;"	m	struct:_AccessInfo	file:
probScale	HTKLib/HFBLat.c	/^static float probScale = 1.0;                 \/* Scales the state-output and lm probabilities.  Leave this alone for normal usage. *\/$/;"	v	file:
probType	HLMLib/LModel.h	/^   LMProbType probType;      \/* probability type *\/$/;"	m	struct:__anon16
probs	HTKLib/HModel.h	/^   TMProb *probs;        \/* array[1..M] of TMProb *\/$/;"	m	struct:__anon60
processText	HLMTools/LAdapt.c	/^static Boolean processText = TRUE;    \/* generate model from raw text data *\/$/;"	v	file:
prog_vc_id	HLMTools/HLMCopy.c	/^char *prog_vc_id = "$Id: HLMCopy.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
prog_version	HLMTools/HLMCopy.c	/^char *prog_version = "!HVER!HLMCopy:   3.4.1 [CUED 12\/03\/09]";$/;"	v
progress	HLMLib/LPMerge.c	/^   int     progress;         \/* progress tracking *\/$/;"	m	struct:__anon1	file:
projSize	HTKLib/HModel.h	/^   short projSize;         \/* dimension of vector to update *\/$/;"	m	struct:_HMMSet
pron	HTKLib/HDict.h	/^   Pron pron;       \/* first pronunciation *\/$/;"	m	struct:_DictEntry
pron	HTKLib/HNet.c	/^   Pron pron;       \/* Actual pronunciation *\/$/;"	m	struct:pronholder	file:
pron	HTKLib/HNet.c	/^   Pron pron;$/;"	m	struct:pinstinfo	file:
pron	HTKLib/HNet.h	/^      Pron   pron;      \/* Word represented (may == null) *\/$/;"	m	union:_NetNode::__anon127
pron	HTKTools/HDMan.c	/^   Pronunciation pron[MAXPRONS];$/;"	m	struct:__anon161	file:
pronHeap	HTKLib/HDict.h	/^   MemHeap pronHeap;    \/* for WordPron structs   *\/$/;"	m	struct:__anon74
pronholder	HTKLib/HNet.c	/^typedef struct pronholder$/;"	s	file:
pronsUsed	HTKTools/HDMan.c	/^   int pronsUsed;               \/* num prons actually used *\/$/;"	m	struct:__anon162	file:
protectStaks	HTKLib/HMem.c	/^static Boolean protectStaks = FALSE;    \/* enable stack protection *\/$/;"	v	file:
protectStk	HTKLib/HMem.h	/^   Boolean protectStk;  \/*  MSTAK only, prevents disposal below Stack Top *\/$/;"	m	struct:__anon73
prototypes	configure	/^   function prototypes and stuff, but not '\\xHH' hex character constants.$/;"	f
prscale	HTKLib/HNet.h	/^   float prscale;		\/* Pronunciation scale factor *\/$/;"	m	struct:lattice
pruneInArcsPerSec	HTKTools/HLRescore.c	/^static LogDouble pruneInArcsPerSec = 0.0;  \/* arcs per second threshold (-t) *\/$/;"	v	file:
pruneInLat	HTKTools/HLRescore.c	/^static Boolean pruneInLat = FALSE;  \/* -t *\/$/;"	v	file:
pruneInThresh	HTKTools/HLRescore.c	/^static LogDouble pruneInThresh = - LZERO;  \/* beam for pruning (-t) *\/$/;"	v	file:
pruneInc	HTKLib/HFB.c	/^   LogDouble pruneInc;       \/* pruning threshold increment *\/$/;"	m	struct:__anon133	file:
pruneInc	HTKTools/HERest.c	/^static LogDouble pruneInc = 0.0;         \/* pruning threshold increment *\/$/;"	v	file:
pruneInit	HTKLib/HFB.c	/^   LogDouble pruneInit;      \/* pruning threshold initially *\/$/;"	m	struct:__anon133	file:
pruneInit	HTKTools/HERest.c	/^static LogDouble pruneInit = NOPRUNE;    \/* pruning threshold initially *\/$/;"	v	file:
pruneLim	HTKLib/HFB.c	/^   LogDouble pruneLim;       \/* pruning threshold limit *\/$/;"	m	struct:__anon133	file:
pruneLim	HTKTools/HERest.c	/^static LogDouble pruneLim = NOPRUNE;     \/* pruning threshold limit *\/$/;"	v	file:
pruneOutArcsPerSec	HTKTools/HLRescore.c	/^static LogDouble pruneOutArcsPerSec = 0.0; \/* arcs per second threshold (-u) *\/$/;"	v	file:
pruneOutLat	HTKTools/HLRescore.c	/^static Boolean pruneOutLat = FALSE; \/* -u *\/$/;"	v	file:
pruneOutThresh	HTKTools/HLRescore.c	/^static LogDouble pruneOutThresh = - LZERO; \/* beam for pruning (-u) *\/$/;"	v	file:
pruneSetting	HTKLib/HFB.c	/^} pruneSetting = { NOPRUNE, 0.0, NOPRUNE, 10.0 };$/;"	v	typeref:struct:__anon133	file:
pruneThresh	HTKLib/HFB.h	/^  LogDouble pruneThresh;    \/* pruning threshold currently *\/$/;"	m	struct:__anon137
pruneWords	HLMTools/LAdapt.c	/^static Boolean pruneWords = FALSE;    \/* prune input text according to word list *\/$/;"	v	file:
psSum	HTKTools/HSGen.c	/^static double psSum;    \/* total log prob of all sentences *\/$/;"	v	file:
pscale	HTKLib/HRec.c	/^   float pscale;            \/* Pronunciation probs scale factor *\/$/;"	m	struct:precinfo	file:
psetinfo	HTKLib/HRec.c	/^struct psetinfo$/;"	s	file:
psi	HTKLib/HRec.c	/^   PSetInfo *psi;           \/* HMMSet information *\/$/;"	m	struct:precinfo	file:
psi	HTKTools/HVite.c	/^static PSetInfo *psi;             \/* Private data used by HRec *\/$/;"	v	file:
psum	HLMTools/LGPrep.c	/^   float psum;                \/* accumulator *\/$/;"	m	struct:ruledef	file:
ptr	HLMLib/LUtil.h	/^   void *ptr;                  \/* General-purpose ptr *\/$/;"	m	struct:_NameHolder
ptr	HTKLib/HModel.h	/^   Ptr ptr;                \/* the structure *\/$/;"	m	struct:_PtrMap
ptr	HTKTools/HSLab.c	/^   LLink ptr;           \/* pointer to the label last modified (if any) *\/$/;"	m	struct:__anon147	file:
ptype	HLMLib/LPCalc.h	/^   LMProbType   ptype;                \/* probability type *\/$/;"	m	struct:__anon2
putWtActive	HTKLib/HModel.c	/^static Boolean putWtActive;   \/* false until a weight is output *\/$/;"	v	file:
putback	HTKLib/HShell.h	/^   int putback;         \/* put back character *\/$/;"	m	struct:__anon84
pvar	HTKLib/HRNLM.c	/^static Vector hists, mean, pmean, pvar, var;$/;"	v	file:
pxd	HTKLib/HRec.c	/^   Boolean pxd;         \/* External propagation done this frame *\/$/;"	m	struct:_NetInst	file:
pylen	HTKLib/HRec.c	/^   int pylen;               \/* Number of PathYesRef list *\/$/;"	m	struct:precinfo	file:
qDms	HTKLib/HFB.h	/^  short *qDms;        \/* array[1..Q] of minimum model duration *\/$/;"	m	struct:__anon138
qHead	HTKLib/HAudio.c	/^   mmApiBuf *qHead;         \/* Head of buffer waiting to be filled list *\/$/;"	m	struct:_AudioIn	file:
qHead	HTKTools/HHEd.c	/^static QLink qHead = NULL;      \/* Head of question list *\/$/;"	v	file:
qHi	HTKLib/HArc.h	/^  int *qHi;     \/* [t], highest q active at time t *\/$/;"	m	struct:ArcInfoStruct
qHi	HTKLib/HFB.h	/^  short *qHi;               \/* array[1..T] of top of pruning beam *\/$/;"	m	struct:__anon137
qIds	HTKLib/HFB.h	/^  LabId  *qIds;       \/* array[1..Q] of logical HMM names (in qList) *\/$/;"	m	struct:__anon138
qLo	HTKLib/HArc.h	/^  int *qLo;     \/* [t], lowest q active at time t *\/$/;"	m	struct:ArcInfoStruct
qLo	HTKLib/HFB.h	/^  short *qLo;               \/* array[1..T] of bottom of pruning beam *\/$/;"	m	struct:__anon137
qName	HTKTools/HHEd.c	/^   LabId qName;                 \/* an expanded list of model names *\/$/;"	m	struct:_QEnt	file:
qTail	HTKLib/HAudio.c	/^   mmApiBuf *qTail;         \/* Tail of buffer waiting to be filled list *\/$/;"	m	struct:_AudioIn	file:
qTail	HTKTools/HHEd.c	/^static QLink qTail = NULL;      \/* Tail of question list *\/$/;"	v	file:
qcksrtM	HTKLib/HRec.c	/^static void qcksrtM(float *array,int l,int r,int M)$/;"	f	file:
qen	HTKLib/HParm.c	/^   int qen;            \/* final row in main block qualified (last valid row) *\/$/;"	m	struct:_ParmBuf	file:
qs_CmpGFile	HLMLib/LGBase.c	/^static int qs_CmpGFile(const void *p1, const void *p2)$/;"	f	file:
qs_CmpNGram	HLMLib/LGBase.c	/^static int qs_CmpNGram(const void *p1, const void *p2)$/;"	f	file:
qs_cmpSize	HLMLib/LGBase.c	/^static int        qs_cmpSize;   \/* must set before using this routine *\/$/;"	v	file:
qs_cneBuf	HLMLib/LModel.c	/^static CNEntry *qs_cneBuf;      \/* global table of read CNEntry *\/$/;"	v	file:
qs_inset	HLMLib/LGBase.c	/^static NGInputSet *qs_inset;    \/* input set *\/$/;"	v	file:
qs_wmap	HLMLib/LGBase.c	/^static WordMap    *qs_wmap;     \/* word list to access mapentries *\/$/;"	v	file:
qsa	HTKLib/HRec.c	/^   LogFloat *qsa;           \/* Array form performing qsort *\/$/;"	m	struct:precinfo	file:
qsn	HTKLib/HRec.c	/^   int qsn;                 \/* Sizeof qsa *\/$/;"	m	struct:precinfo	file:
qst	HTKLib/HParm.c	/^   int qst;            \/* next row in main block to qualify (qst>qwin) *\/$/;"	m	struct:_ParmBuf	file:
quest	HTKTools/HHEd.c	/^   QLink quest;                 \/* question used to do split *\/$/;"	m	struct:_Node	file:
questHeap	HTKTools/HHEd.c	/^static MemHeap questHeap;   \/* Heap holds all questions *\/$/;"	v	file:
quiet	HTKTools/HSGen.c	/^static Boolean quiet = FALSE;       \/* suppress sentence output *\/$/;"	v	file:
qwin	HTKLib/HParm.c	/^   int qwin;           \/* Width of qualify window (needed on each side) *\/$/;"	m	struct:_ParmBuf	file:
r	HTKLib/HParm.c	/^   ShortVec r;        \/* raw speech vector *\/$/;"	m	struct:__anon76	file:
r	HTKLib/HRNLM.h	/^    float *r, *z, *c, *h_;$/;"	m	struct:_Layer
r	HTKTools/HParse.c	/^   LabId r;$/;"	m	struct:__anon157	file:
rOK	HTKLib/HAudio.c	77;"	d	file:
rOR	HTKLib/HAudio.c	79;"	d	file:
rPthHeap	HTKLib/HRec.c	/^   MemHeap rPthHeap;        \/* NxtPath heap *\/$/;"	m	struct:precinfo	file:
rTokHeap	HTKLib/HRec.c	/^   MemHeap rTokHeap;        \/* RelToken heap *\/$/;"	m	struct:precinfo	file:
rUR	HTKLib/HAudio.c	78;"	d	file:
rand_seed	HTKLib/HRNLM.h	/^    int rand_seed;$/;"	m	struct:_RNNLM
rank	HTKLib/esignal.h	/^    short       rank;           \/* number of dimensions *\/$/;"	m	struct:Array
rank	HTKLib/esignal.h	/^    short       rank;           \/* number of dimensions *\/$/;"	m	struct:FieldSpec
rawBuffer	HTKLib/HParm.c	/^   char *rawBuffer;   \/* buffer for external data *\/$/;"	m	struct:__anon76	file:
rawEnergy	HTKLib/HParm.c	/^   Boolean rawEnergy;         \/* Use raw energy before preEmp and ham *\/$/;"	m	struct:__anon76	file:
rawMITFormat	HTKLib/HLM.c	/^static Boolean rawMITFormat = FALSE;    \/* Don't use HTK quoting and escapes *\/$/;"	v	file:
rawMITFormat	HTKLib/HRNLM.c	/^static Boolean rawMITFormat = TRUE;$/;"	v	file:
rawMode	HTKTools/HDMan.c	/^   Boolean rawMode;             \/* Raw input mode *\/$/;"	m	struct:__anon162	file:
rawOut	HTKTools/HList.c	/^static Boolean rawOut = FALSE;   \/* raw output i.e no numbering *\/$/;"	v	file:
rbuf	HTKLib/HAudio.c	/^   ReplayBuf rbuf;           \/* replay buffer (if needed) *\/$/;"	m	struct:_AudioIn	file:
rc	HTKLib/HAudio.c	/^   UMSAudioDevice_ReturnCode rc;$/;"	m	struct:_AudioIn	file:
rc	HTKLib/HAudio.c	/^   UMSAudioDevice_ReturnCode rc;$/;"	m	struct:_AudioOut	file:
rc	HTKLib/HNet.c	/^   NetNode **rc;    \/* Right contexts - linked to word end nodes *\/$/;"	m	struct:pronholder	file:
readClassAllocation	HTKLib/HRNLM.c	/^static Boolean readClassAllocation = TRUE;$/;"	v	file:
readWord	HTKLib/HRNLM.c	/^static void readWord(char *word, FILE *fin)$/;"	f	file:
read_all_hdrs	HTKLib/HNLM.c	/^void read_all_hdrs(FILE *stream, int a_layers, int *mlp_layer_size, MLPWeightFile *weight)$/;"	f
real	HTKLib/HRNLM.h	/^typedef double real;	\/*	 doubles for NN weights *\/$/;"	t
real	HTKLib/esignal.h	/^typedef struct {Schar	real, imag;}	ScharComplex;$/;"	m	struct:__anon50
real	HTKLib/esignal.h	/^typedef struct {double	real, imag;}	DoubleComplex;$/;"	m	struct:__anon46
real	HTKLib/esignal.h	/^typedef struct {float	real, imag;}	FloatComplex;$/;"	m	struct:__anon47
real	HTKLib/esignal.h	/^typedef struct {long	real, imag;}	LongComplex;$/;"	m	struct:__anon48
real	HTKLib/esignal.h	/^typedef struct {short	real, imag;}	ShortComplex;$/;"	m	struct:__anon49
recPort	HTKLib/HAudio.c	/^   ALport recPort;           \/* SGI audio port *\/$/;"	m	struct:_AudioIn	file:
rec_freq	HLMTools/Cluster.c	/^static int          rec_freq = 1000;        \/* Frequency we write recovery files (0 = off) *\/$/;"	v	file:
recfn	HTKTools/HResults.c	/^static char *recfn;                   \/* rec file name (test) *\/$/;"	v	file:
recid	HTKTools/HResults.c	/^static char recid[5][255];            \/* upto 5 identifiers for *\/$/;"	v	file:
recidUsed	HTKTools/HResults.c	/^static int recidUsed = 0;             \/* number of test identifiers set *\/$/;"	v	file:
recnum	HTKLib/esignal.h	/^    long    recnum;$/;"	m	struct:Annot
ref	HTKTools/HResults.c	/^static LabList *ref,*test;            \/* the labels being compared *\/$/;"	v	file:
refList	HTKLib/HNet.h	/^   SubLatDef *refList;          \/* List of all SubLats referring to this lat *\/$/;"	m	struct:lattice
refid	HTKTools/HResults.c	/^static char * refid=NULL;             \/* identifiers for reference material *\/$/;"	v	file:
refine	HTKBook/htkbook-pdf.tex	/^\\include{adapt}$/;"	i
refine	HTKBook/htkbook.tex	/^\\include{adapt}$/;"	i
reftex	HTKBook/Makefile	/^reftex =     HTKRef\/Cluster.tex  HTKRef\/HInit.tex    HTKRef\/HResults.tex    \\$/;"	m
regA	HTKTools/HSLab.c	/^   int   regA, regB;       \/* marked regions on the screen (if any) *\/$/;"	m	struct:__anon145	file:
regAcc	HTKLib/HAdapt.c	/^   RegAcc *regAcc;       \/* accumulate information for generating transform *\/$/;"	m	struct:__anon95	file:
regB	HTKTools/HSLab.c	/^   int   regA, regB;       \/* marked regions on the screen (if any) *\/$/;"	m	struct:__anon145	file:
regHeap	HTKTools/HVite.c	/^static MemHeap regHeap;$/;"	v	file:
regTree	HTKLib/HModel.h	/^  RegTree regTree;     \/* the regression tree used for transform *\/$/;"	m	struct:__anon66
regnMarked	HTKTools/HSLab.c	/^static Boolean regnMarked = FALSE;     \/* region marked *\/$/;"	v	file:
reltoken	HTKLib/HRec.c	/^typedef struct reltoken$/;"	s	file:
relu	HTKLib/HRNLM.c	/^void relu (real *ac, real reluratio, int start, int end)$/;"	f
reluij	HTKLib/HRNLM.c	/^void reluij (float *ac, float ratio, int num)$/;"	f
reluratio	HTKLib/HRNLM.h	/^    float reluratio;$/;"	m	struct:_Layer
reluratio	HTKLib/HRNLM.h	/^    real cuedversion, reluratio, lognormconst;$/;"	m	struct:_RNNLM
remDup	HLMTools/HLMCopy.c	/^static Boolean   remDup = TRUE;          \/* Don't add duplicate prons *\/$/;"	v	file:
remDupPron	HTKLib/HNet.c	/^Boolean remDupPron=TRUE;$/;"	v
reorderComps	HTKLib/HModel.c	/^static Boolean reorderComps=FALSE;      \/* re-order mixture components (PDE) *\/$/;"	v	file:
repHeap	HTKTools/HVite.c	/^static MemHeap repHeap;$/;"	v	file:
replay	HTKTools/HList.c	/^static Boolean replay = FALSE;   \/* replay audio *\/$/;"	v	file:
replay	HTKTools/HVite.c	/^static Boolean replay = FALSE;    \/* enable audio replay *\/$/;"	v	file:
report	HTKLib/HGraf.c	/^static XEvent        report;$/;"	v	file:
required	HTKTools/HDMan.c	/^static LabId required;               \/* current required word *\/$/;"	v	file:
rff	HTKTools/HResults.c	/^static FileFormat rff   = UNDEFF;     \/* ff of reference transcription files *\/$/;"	v	file:
rgain	HTKLib/HAudio.c	/^   long rgain;$/;"	m	struct:_AudioIn	file:
rgain	HTKLib/HAudio.c	/^   long rgain;$/;"	m	struct:_AudioOut	file:
rid	HTKLib/HVQ.h	/^   short nid,lid,rid;   \/* used for mapping between mem and ext def *\/$/;"	m	struct:_VQNodeRec
right	HTKLib/HVQ.h	/^   VQNode left,right;   \/* offspring, only right is used in linTree *\/$/;"	m	struct:_VQNodeRec
right	HTKTools/HHEd.c	/^   HLink left,right;            \/* physical names of constituent biphones *\/$/;"	m	struct:__anon166	file:
rlev	HTKTools/HResults.c	/^static int rlev=0;                    \/* Label level to be used as ref *\/$/;"	v	file:
rmax	HTKLib/HRec.c	/^static const RelToken rmax={0.0,0.0,NULL$/;"	v	file:
rnlm	HTKLib/HLM.h	/^      RNLM *rnlm;$/;"	m	union:lmodel::__anon125
rnnInfoStack	HTKLib/HRNLM.c	/^static MemHeap rnnInfoStack;       \/* Local stack to for MLP info *\/$/;"	v	file:
rnnLM	HTKLib/HLM.h	/^typedef enum { boNGram=1, matBigram, mlpLM, intpltLM, rnnLM, hlmModel } LMType;$/;"	e	enum:__anon123
rnnlm	HTKLib/HLM.h	/^   Ptr rnnlm;                   \/* similar to MLPLM->mlp, will hold RNNLM in HRNLM.c *\/$/;"	m	struct:__anon124
rnnlmLMStateSize	HTKLib/HLM.c	/^static int rnnlmLMStateSize = 2;        \/* RNNLM effective LM state size, used together$/;"	v	file:
rnnlmMinHVDist	HTKLib/HLM.c	/^static double rnnlmMinHVDist = 0.00001; \/* RNNLM history vector distance threshold *\/$/;"	v	file:
rnnlmUseHVDist	HTKLib/HLM.c	/^static Boolean rnnlmUseHVDist = FALSE;  \/* RNNLM using history vector distance in lattice expansion *\/$/;"	v	file:
rnnlm_fhist	HTKLib/HLM.h	/^   Vector rnnlm_fhist;          \/* Vector representation v_{i-1, ..., 1} for partial FUTURE$/;"	m	struct:__anon124
rnnlm_fhist	HTKLib/HLM.h	/^   Vector rnnlm_fhist;          \/* Vector representation v_{i-1, ..., 1} for partial FUTURE$/;"	m	struct:nentry
rnnlm_file	HTKLib/HRNLM.h	/^    char rnnlm_file[MAX_STRING];$/;"	m	struct:_RNNLM
rnnlm_hist	HTKLib/HLM.h	/^   Vector rnnlm_hist;           \/* Vector representation v_{i-2, ..., 1} for partial CURRENT$/;"	m	struct:__anon124
rnnlm_hist	HTKLib/HLM.h	/^   Vector rnnlm_hist;           \/* Vector representation v_{i-2, ..., 1} for partial CURRENT$/;"	m	struct:nentry
rnnrandom	HTKLib/HRNLM.c	/^static real rnnrandom(real min, real max)$/;"	f	file:
rnull	HTKLib/HRec.c	/^static const RelToken rnull={LZERO,0.0,NULL$/;"	v	file:
roCounter	HTKTools/HVite.c	/^static int roCounter = 0;         \/* Counter for audio output name *\/$/;"	v	file:
roPrefix	HTKTools/HVite.c	/^static char * roPrefix=NULL;      \/* Prefix for direct audio output name *\/$/;"	v	file:
roSuffix	HTKTools/HVite.c	/^static char * roSuffix=NULL;      \/* Suffix for direct audio output name *\/$/;"	v	file:
root	HLMLib/LModel.h	/^   FLEntry root;             \/* the actual LM tree *\/$/;"	m	struct:__anon16
root	HTKLib/HModel.h	/^  RegNode *root;       \/* pointer to the root node of the tree *\/$/;"	m	struct:RegTree
root	HTKTools/HHEd.c	/^   Node *root;                  \/* root of tree *\/$/;"	m	struct:_Tree	file:
rootFN	HLMTools/LAdapt.c	/^static char *rootFN  = "gram";      \/* gbase root file name *\/$/;"	v	file:
rootFN	HLMTools/LGCopy.c	/^static char *rootFN  = "data";      \/* gbase root file name *\/$/;"	v	file:
rootFN	HLMTools/LGPrep.c	/^static char *rootFN  = "gram";      \/* gbase root filename *\/$/;"	v	file:
rootW	HTKLib/HGraf.c	/^static Window        rootW, theWindow;                   $/;"	v	file:
rows	HTKLib/HNLM.h	/^    int rows;            \/* Number of rows.*\/$/;"	m	struct:matinfo
rset	HLMTools/LGPrep.c	/^static RuleSet rset;                \/* rule set if any *\/$/;"	v	file:
rtree	HTKLib/HModel.h	/^  RegTree *rtree;                   \/* regression tree to be used for adaptation *\/$/;"	m	struct:_AdaptXForm
ruleFN	HLMTools/LGPrep.c	/^static char *ruleFN  = NULL;        \/* file containing edit rules *\/$/;"	v	file:
ruledef	HLMTools/LGPrep.c	/^typedef struct ruledef{    \/* rule definition *\/$/;"	s	file:
s	HTKLib/HParm.c	/^   Vector s;          \/* speech vector *\/$/;"	m	struct:__anon76	file:
s	HTKLib/HRNLM.h	/^    float *c_hw, *s, *sc;$/;"	m	struct:_Layer
s	HTKLib/HShell.h	/^   char *s;$/;"	m	union:__anon86
s	HTKLib/HUtil.h	/^   int s;            \/* current stream index 1..S *\/$/;"	m	struct:__anon38
sAudioIn	HTKLib/HAudio.c	/^static AudioIn sAudioIn=NULL;$/;"	v	file:
sAudioOut	HTKLib/HAudio.c	/^static AudioOut sAudioOut=NULL;$/;"	v	file:
sBuf	HTKLib/HRec.c	/^   TokenSet *sBuf;          \/* Buffer Array[2..N-1] of tokset for StepHMM1_N *\/$/;"	m	struct:psetinfo	file:
sCnt	HTKLib/HParm.c	/^   int sCnt;              \/* Number of files processed in current session *\/$/;"	m	struct:channelinfo	file:
sEnd	HTKTools/HSLab.c	/^static long sStart, sEnd;                  \/* the start and end sample currently visible on the screen *\/$/;"	v	file:
sIdx	HTKLib/HModel.h	/^   int sIdx;            \/* State index *\/$/;"	m	struct:__anon62
sLeft	HTKLib/HNet.h	/^   Boolean sLeft;  \/* Seen left context dependency *\/$/;"	m	struct:hmmsetcxtinfo
sMagic	HTKLib/HAudio.c	/^static DWORD sMagic=-1;$/;"	v	file:
sPre	HTKLib/HRec.c	/^   PreComp *sPre;           \/* Array[1..nsp] State PreComps *\/$/;"	m	struct:psetinfo	file:
sProb	HTKTools/HHEd.c	/^   float sProb;                 \/* likelihood of split cluster *\/$/;"	m	struct:_Node	file:
sRight	HTKLib/HNet.h	/^   Boolean sRight; \/* Seen right context dependency *\/$/;"	m	struct:hmmsetcxtinfo
sSet	HTKTools/HSmooth.c	/^static StreamElem **sSet;    \/* array[1..aSize]of stream *\/$/;"	v	file:
sSetStack	HTKTools/HSmooth.c	/^static MemHeap sSetStack;$/;"	v	file:
sStart	HTKTools/HSLab.c	/^static long sStart, sEnd;                  \/* the start and end sample currently visible on the screen *\/$/;"	v	file:
sa	HTKTools/HCompV.c	/^   SpkrAcc *sa;                          \/* speaker accumulate *\/$/;"	m	struct:SpkrAccListItem	file:
salist	HTKTools/HCompV.c	/^static SpkrAccListItem *salist = NULL;   \/* global speaker accumulate list *\/$/;"	v	file:
sampFreqs	HTKLib/HAudio.c	/^static float sampFreqs[NUM_SAMP_FREQS] = {$/;"	v	file:
sampKind	HTKLib/HWave.c	/^   short sampKind;$/;"	m	struct:__anon107	file:
sampPeriod	HTKLib/HAudio.c	/^   HTime sampPeriod;         \/* sampling period in 100ns units *\/$/;"	m	struct:_AudioIn	file:
sampPeriod	HTKLib/HParm.c	/^   HTime sampPeriod;  \/* Either 0.0 or the fixed sample rate of source *\/$/;"	m	struct:hparmsrcdef	file:
sampPeriod	HTKLib/HSigP.h	/^   long sampPeriod;     \/* sample period *\/$/;"	m	struct:__anon129
sampPeriod	HTKLib/HWave.c	/^   HTime sampPeriod;    \/* Sample period in 100ns units *\/$/;"	m	struct:_Wave	file:
sampPeriod	HTKLib/HWave.c	/^   int32 sampPeriod;  \/* sample period in usecs *\/$/;"	m	struct:__anon102	file:
sampPeriod	HTKLib/HWave.c	/^   int32 sampPeriod;$/;"	m	struct:__anon107	file:
sampPeriod	HTKTools/HList.c	/^static HTime sampPeriod;         \/* raw audio input only *\/$/;"	v	file:
sampPeriod	HTKTools/HSLab.c	/^static HTime sampPeriod;     \/* the sample period *\/$/;"	v	file:
sampRate	HTKLib/HWave.c	/^   int32 sampRate;       \/* sample rate code *\/$/;"	m	struct:__anon103	file:
sampRate	HTKLib/HWave.c	/^   int32 sampRate;    \/* sample rate in Hertz *\/$/;"	m	struct:__anon102	file:
sampRate	HTKLib/HWave.c	/^   short sampRate;$/;"	m	struct:__anon100	file:
sampRate	HTKLib/HWave.c	/^   short sampRate;$/;"	m	struct:__anon101	file:
sampSize	HTKLib/HWave.c	/^   short sampSize;   \/* sample size in bits (16) *\/$/;"	m	struct:__anon102	file:
sampSize	HTKLib/HWave.c	/^   short sampSize;$/;"	m	struct:__anon106	file:
sampSize	HTKLib/HWave.c	/^   short sampSize;$/;"	m	struct:__anon107	file:
sampSize	HTKTools/HList.c	/^   int sampSize;$/;"	m	struct:__anon153	file:
samplesPt	HTKTools/HSLab.c	/^static float samplesPt;      \/* samples per point of the graphics screen *\/$/;"	v	file:
saveAsVQ	HTKTools/HCopy.c	/^Boolean saveAsVQ = FALSE;$/;"	v
saveAudioOut	HTKTools/HVite.c	/^static Boolean saveAudioOut=FALSE;\/* Save rec output from direct audio *\/$/;"	v	file:
saveBaseClass	HTKLib/HModel.c	/^static Boolean saveBaseClass = FALSE;   \/* save base classes *\/ $/;"	v	file:
saveBinary	HTKLib/HAdapt.h	/^  Boolean saveBinary;$/;"	m	struct:__anon37
saveBinary	HTKLib/HModel.c	/^static Boolean saveBinary = FALSE;      \/* save HMM defs in binary *\/$/;"	v	file:
saveBinary	HTKTools/HCompV.c	/^static Boolean saveBinary = FALSE;  \/* save output in binary  *\/$/;"	v	file:
saveBinary	HTKTools/HERest.c	/^static Boolean saveBinary = FALSE;  \/* save output in binary  *\/$/;"	v	file:
saveBinary	HTKTools/HInit.c	/^static Boolean saveBinary = FALSE;  \/* save output in binary  *\/$/;"	v	file:
saveBinary	HTKTools/HMMIRest.c	/^static Boolean saveBinary = FALSE;  \/* save output HMMs in binary  *\/$/;"	v	file:
saveBinary	HTKTools/HRest.c	/^static Boolean saveBinary = FALSE;  \/* save output in binary  *\/$/;"	v	file:
saveBinary	HTKTools/HSmooth.c	/^static Boolean saveBinary = FALSE;  \/* save output in binary  *\/$/;"	v	file:
saveBinary	HTKTools/HVite.c	/^static Boolean saveBinary=FALSE;  \/* Save tmf in binary format *\/$/;"	v	file:
saveCompressed	HTKLib/HParm.c	/^   Boolean saveCompressed;    \/* If LPREFC save as IREFC else _C *\/$/;"	m	struct:__anon76	file:
saveCompressed	HTKLib/HParm.h	/^   Boolean saveCompressed;    \/* Save in compressed format *\/$/;"	m	struct:__anon122
saveFiles	HLMTools/LAdapt.c	/^static Boolean saveFiles = TRUE;      \/* save intermediate files *\/ $/;"	v	file:
saveFmt	HLMLib/LPCalc.h	/^   LMFileFmt    saveFmt;              \/* output LM file format *\/$/;"	m	struct:__anon2
saveFmt	HLMTools/HLMCopy.c	/^static LMFileFmt saveFmt = LMF_BINARY;   \/* LM file format *\/$/;"	v	file:
saveFmt	HLMTools/LMerge.c	/^static LMFileFmt saveFmt = DEF_SAVEFMT;  \/* LM file format *\/$/;"	v	file:
saveFmt	HLMTools/LNorm.c	/^static LMFileFmt saveFmt = LMF_BINARY;   \/* LM file format *\/$/;"	v	file:
saveGlobOpts	HTKLib/HModel.c	/^static Boolean saveGlobOpts = TRUE;     \/* save ~o with HMM defs *\/$/;"	v	file:
saveHMMSet	HTKTools/HHEd.c	/^static Boolean saveHMMSet   = TRUE;    \/* Save the HMMSet *\/$/;"	v	file:
saveInputXForm	HTKLib/HModel.c	/^static Boolean saveInputXForm = TRUE;   \/* save input xforms with models set *\/$/;"	v	file:
saveLatBin	HTKTools/HParse.c	/^static Boolean saveLatBin=FALSE;      \/* save lattice in binary *\/ $/;"	v	file:
saveLatLM	HTKTools/HParse.c	/^static Boolean saveLatLM=FALSE;       \/* output lattice probabilities *\/$/;"	v	file:
saveRegTree	HTKLib/HModel.c	/^static Boolean saveRegTree = FALSE;     \/* save regression classes and tree *\/ $/;"	v	file:
saveSemiTiedBinary	HTKLib/HAdapt.c	/^static Boolean saveSemiTiedBinary = FALSE;$/;"	v	file:
saveSpkrModels	HTKLib/HAdapt.c	/^static Boolean saveSpkrModels = FALSE;$/;"	v	file:
saveWeights	HTKLib/HRNLM.c	/^static void saveWeights(RNNLM* rnnlm)$/;"	f	file:
saveWithCRC	HTKLib/HParm.c	/^   Boolean saveWithCRC;       \/* Append check sum on save *\/$/;"	m	struct:__anon76	file:
saveWithCRC	HTKLib/HParm.h	/^   Boolean saveWithCRC;       \/* Save with CRC check added *\/$/;"	m	struct:__anon122
savedCommandLine	HTKLib/HShell.c	/^static char *savedCommandLine;$/;"	v	file:
sbindir	HTKLib/Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sbindir	HTKTools/Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sc	HTKLib/HRNLM.h	/^    float *c_hw, *s, *sc;$/;"	m	struct:_Layer
scIndex	HTKTools/HSLab.c	/^static short scIndex = 0;    \/* initial scaling index == 1.0*\/$/;"	v	file:
scString	HTKTools/HSLab.c	/^static char *scString[NUM_OF_SCALES] = {"x1", "x2", "x4", "x8", "x16", "x32"};$/;"	v	file:
scValues	HTKTools/HSLab.c	/^static float scValues[NUM_OF_SCALES] = {1.0, 2.0, 4.0, 8.0, 16.0, 32.0};$/;"	v	file:
sc_lmlike	HTKLib/HArc.h	/^  LogFloat sc_lmlike;$/;"	m	struct:_CorrA
scale	HTKLib/HLM.h	/^   float scale;                 \/* Language model scale *\/$/;"	m	struct:lmodel
scale	HTKLib/HRec.c	/^   float scale;             \/* LM (Net probs) scale factor *\/$/;"	m	struct:precinfo	file:
scale	HTKLib/esignal.h	/^    double      scale, offset;  \/* scale factor and offset relating$/;"	m	struct:FieldSpec
scale_btn	HTKTools/HSLab.c	/^static HButton *scale_btn;   \/* pointer to the amplitude scale button *\/$/;"	v	file:
scaledOcc	HTKLib/HFBLat.c	/^   float scaledOcc; \/*for MEE.*\/$/;"	m	struct:__anon90	file:
scaled_aclike	HTKLib/HArc.h	/^  float scaled_aclike; \/* scaled. *\/$/;"	m	struct:_CorrN
sccs	HTKLib/HShell.c	/^   char *sccs;$/;"	m	struct:_VersionEntry	file:
score	HTKLib/HLabel.h	/^   float score;             \/* primary score eg. logP *\/$/;"	m	struct:_Label
score	HTKLib/HLat.c	/^   LogFloat score;$/;"	m	struct:_SubLNode	file:
score	HTKLib/HNet.h	/^   double score;       \/* Field used for pruning *\/$/;"	m	struct:lnode
score	HTKLib/HNet.h	/^   float score;        \/* Field used for pruning\/sorting *\/$/;"	m	struct:larc
score	HTKLib/HRec.c	/^   double score;$/;"	m	struct:nbestentry	file:
score	HTKTools/HResults.c	/^   float score;                 \/* score for this hit *\/$/;"	m	struct:_SpotRec	file:
score	HTKTools/HResults.c	/^   int score;$/;"	m	struct:_Cell	file:
scribeMap	HTKLib/HLabel.c	/^static char *scribeMap[] = {"LBB:", "LBA:", "UTS:"};$/;"	v	file:
script	HTKLib/HShell.c	/^static FILE *script = NULL;   \/* script file if any *\/$/;"	v	file:
script	HTKTools/HDMan.c	/^   ScriptItem *script;          \/* edit script for this input dictionary *\/$/;"	m	struct:__anon162	file:
script	HTKTools/HLEd.c	/^static ScriptItem *script;          \/* linked list of edit commands *\/$/;"	v	file:
scriptBuf	HTKLib/HShell.c	/^static char scriptBuf[256];   \/* buffer for current script arg *\/$/;"	v	file:
scriptBufLoaded	HTKLib/HShell.c	/^static Boolean scriptBufLoaded = FALSE;$/;"	v	file:
scriptDir	HTKTools/HDMan.c	/^static char *scriptDir = NULL;       \/* directory to look for scripts *\/$/;"	v	file:
scriptcount	HTKLib/HShell.c	/^static int scriptcount = 0;   \/* num words in script *\/$/;"	v	file:
se	HTKLib/HLM.h	/^   SEntry *se;                  \/* Array[0..nse-1] of ngram probabilities *\/$/;"	m	struct:nentry
se	HTKLib/HUtil.h	/^   StateElem *se;    \/* ->current stateElem *\/$/;"	m	struct:__anon38
seIndexes	HTKLib/HRec.c	/^   short ***seIndexes;      \/* Array[1..ntr] of seIndexes *\/$/;"	m	struct:psetinfo	file:
se_buff	HLMLib/LModel.h	/^   SMEntry *se_buff;         \/* temp buffer *\/ \/* NB variable size! *\/$/;"	m	struct:__anon16
se_cmp	HTKLib/HLM.c	/^static int se_cmp(const void *v1,const void *v2)$/;"	f	file:
se_cmp	HTKTools/HLStats.c	/^int se_cmp(const void *v1,const void *v2)$/;"	f
sea	HLMLib/LModel.h	/^   struct _SMEntry *sea;    \/* sorted array [0..nse-1] of SMEntry *\/$/;"	m	struct:_FLEntry	typeref:struct:_FLEntry::_SMEntry
searchRNNVocab	HTKLib/HRNLM.c	/^int searchRNNVocab(RNNLM* rnnlm, char *word)$/;"	f
seen	HTKLib/HShell.h	/^   Boolean seen;        \/* set true when read by any module *\/$/;"	m	struct:__anon87
seen	HTKTools/HParse.c	/^   Boolean seen;     \/* flag used when scanning network *\/$/;"	m	struct:_NodeInfo	file:
segId	HTKTools/HCompV.c	/^static LabId  segId  = NULL;        \/* and its id *\/$/;"	v	file:
segId	HTKTools/HInit.c	/^static LabId  segId  = NULL;        \/* and its id *\/$/;"	v	file:
segId	HTKTools/HQuant.c	/^static LabId segId  = NULL;         \/* and its id *\/$/;"	v	file:
segId	HTKTools/HRest.c	/^static LabId  segId  = NULL;     \/* and its index *\/$/;"	v	file:
segLab	HTKTools/HCompV.c	/^static char *segLab = NULL;         \/* segment label if any *\/$/;"	v	file:
segLab	HTKTools/HInit.c	/^static char * segLab = NULL;        \/* segment label if any *\/$/;"	v	file:
segLab	HTKTools/HQuant.c	/^static char *segLab = NULL;         \/* segment label, if any *\/$/;"	v	file:
segLab	HTKTools/HRest.c	/^static char * segLab = NULL;     \/* segment label if any *\/$/;"	v	file:
segLen	HTKLib/HTrain.h	/^   int segLen;          \/* blkSize for each segment *\/$/;"	m	struct:_SegStoreRec
segReject	HTKTools/HRest.c	/^static Boolean segReject = TRUE; \/* Enable short train segment rejection *\/$/;"	v	file:
segStore	HTKTools/HInit.c	/^static SegStore segStore;        \/* Storage for data segments *\/$/;"	v	file:
segStore	HTKTools/HRest.c	/^static SegStore segStore;        \/* Storage for data segments *\/$/;"	v	file:
segmentStack	HTKTools/HInit.c	/^static MemHeap segmentStack;     \/* Used by segStore *\/$/;"	v	file:
segmentStack	HTKTools/HRest.c	/^static MemHeap segmentStack;     \/* Used by segStore *\/$/;"	v	file:
selfCalSilDet	HTKLib/HParm.c	/^   int selfCalSilDet;         \/* Self calibrating silence detection *\/$/;"	m	struct:__anon76	file:
semiTied	HTKLib/HModel.h	/^   AdaptXForm *semiTied;   \/* SemiTied transform associated with model set *\/$/;"	m	struct:_HMMSet
semiTied2InputXForm	HTKLib/HAdapt.c	/^static Boolean semiTied2InputXForm = FALSE;$/;"	v	file:
semiTiedFloorScale	HTKLib/HAdapt.c	/^static float semiTiedFloorScale = 0.1;$/;"	v	file:
semiTiedMacro	HTKLib/HAdapt.c	/^static char *semiTiedMacro = NULL;$/;"	v	file:
semiTiedMacro	HTKLib/HModel.h	/^   char *semiTiedMacro;  \/* macroname of semi-tied transform *\/$/;"	m	struct:_HMMSet
semiTiedVFloor	HTKLib/HAdapt.c	/^static Boolean semiTiedVFloor = TRUE;$/;"	v	file:
senId	HLMTools/LPlex.c	/^static LabId senId = NULL;          \/* sentence end marker *\/$/;"	v	file:
sent	HLMTools/LPlex.c	/^static PStats  sent;                \/* per utterance accumulators *\/$/;"	v	file:
sentMarker	HTKTools/HLEd.c	/^static LabId sentMarker=NULL;       \/* sentence bndary marker set by SB cmd *\/$/;"	v	file:
sent_end	HLMTools/Cluster.c	/^static char         sent_end[256];          \/* sentence end word *\/$/;"	v	file:
sent_start	HLMTools/Cluster.c	/^static char         sent_start[256];        \/* sentence start word *\/$/;"	v	file:
sentry	HTKLib/HLM.h	/^typedef struct sentry {         \/* HLM NGram probability *\/$/;"	s
seqno	HLMLib/LWMap.h	/^   int     seqno;        \/* sequence number *\/$/;"	m	struct:__anon20
sequenceStack	HTKTools/HInit.c	/^static MemHeap sequenceStack;    \/* For storage of sequences *\/$/;"	v	file:
set	HTKLib/HRec.c	/^   RelToken *set;            \/* Likelihood sorted array[0..nToks] of rtoks *\/$/;"	m	struct:tokenset	file:
set	HTKLib/HUtil.h	/^   Boolean *set;		\/* array[1..nMembers] of Boolean *\/$/;"	m	struct:__anon39
setHeap	HTKLib/HUtil.c	/^static MemHeap setHeap;$/;"	v	file:
set_ids	HLMTools/Cluster.c	/^void set_ids(int start, int end, int unk)$/;"	f
set_output_prefix	HLMTools/Cluster.c	/^void set_output_prefix(char *name)$/;"	f
setid	HLMTools/LGPrep.c	/^   int   setid;               \/* set index *\/$/;"	m	union:__anon25	file:
setlist	HLMTools/LGPrep.c	/^   SetDef **setlist;          \/* array[0..MAX_SETS-1] of -> SetDef *\/$/;"	m	struct:__anon28	file:
setup_all_counts	HLMTools/Cluster.c	/^void setup_all_counts(void)$/;"	f
setvocab	HTKLib/HRNLM.h	/^    Boolean   setvocab;             \/*  vocabulary hash table has been set ?  *\/$/;"	m	struct:_RNNLM
sgn	HTKLib/HMath.c	684;"	d	file:
sharedMix	HTKLib/HFB.c	/^static Boolean sharedMix = FALSE; \/* true if shared mixtures *\/$/;"	v	file:
sharedstatedir	HTKLib/Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
sharedstatedir	HTKTools/Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
showConfig	HTKLib/HShell.c	/^static Boolean showConfig = FALSE;       \/* show configuration params *\/$/;"	v	file:
show_MLV	HLMTools/Cluster.c	/^static Boolean     show_MLV=FALSE;          \/* Show MLV after each change *\/$/;"	v	file:
si	HTKLib/HUtil.h	/^   StateInfo *si;    \/* ->current stateInfo *\/$/;"	m	struct:__anon38
sideXForm	HTKLib/HParm.c	/^   AdaptXForm *sideXForm;$/;"	m	struct:__anon76	file:
sideXFormExt	HTKLib/HParm.c	/^   char* sideXFormExt;       \/* side XForm mask *\/$/;"	m	struct:__anon76	file:
sideXFormMask	HTKLib/HParm.c	/^   char* sideXFormMask;       \/* side XForm mask *\/$/;"	m	struct:__anon76	file:
sig	HTKLib/HAudio.c	/^   int sig;                  \/* signal if any *\/$/;"	m	struct:_AudioIn	file:
sigAudio	HTKLib/HAudio.c	/^static AudioIn sigAudio;  \/* Globals used for signalling *\/$/;"	v	file:
sigNum	HTKLib/HAudio.c	/^static int sigNum=NULLSIG;$/;"	v	file:
sigmoid	HTKLib/HRNLM.c	/^void sigmoid (real *ac, int start, int end)$/;"	f
sigmoidij	HTKLib/HRNLM.c	/^void sigmoidij (float *ac, int num)$/;"	f
sign	HLMLib/LUtil.c	/^static int sign(int r)$/;"	f	file:
sigpHeap	HTKLib/HSigP.c	/^static MemHeap sigpHeap;$/;"	v	file:
silDetCnt	HTKLib/HParm.c	/^   int silDetCnt;      \/* Number of silence frames in window *\/$/;"	m	struct:_ParmBuf	file:
silDiscard	HTKLib/HParm.c	/^   float silDiscard;          \/* Calibrate discard level *\/$/;"	m	struct:__anon76	file:
silFloor	HTKLib/HParm.c	/^   float silFloor;            \/* Silence floor in dBs *\/$/;"	m	struct:__anon76	file:
silGlchCount	HTKLib/HParm.c	/^   int silGlchCount;          \/*   of sil in spc acceptable as glitches *\/$/;"	m	struct:__anon76	file:
silId	HTKLib/HNet.c	/^   int silId;$/;"	m	struct:pinstinfo	file:
silMean	HTKLib/HParm.c	/^   float silMean;             \/* Mean silence energy (in dB) *\/$/;"	m	struct:__anon76	file:
silSeqCount	HTKLib/HParm.c	/^   int silSeqCount;           \/*   of silence before stopping *\/$/;"	m	struct:__anon76	file:
simpleDiffs	HTKLib/HParm.c	/^   Boolean simpleDiffs;       \/* Use simple differences for delta calcs *\/$/;"	m	struct:__anon76	file:
size	HLMLib/LCMap.h	/^   int size;               \/* size of class *\/$/;"	m	struct:clEntry
size	HLMLib/LGBase.h	/^   int size;               \/* size of fof table *\/$/;"	m	struct:__anon7
size	HLMLib/LWMap.h	/^   int     size;         \/* size of array *\/$/;"	m	struct:__anon20
size	HLMLib/LWMap.h	/^   int size;             \/* size of lookup array *\/$/;"	m	struct:__anon19
size	HLMTools/Cluster.c	/^   int       size; \/* Number of bigrams with this word in *\/$/;"	m	struct:__anon31	file:
size	HTKLib/HAudio.c	/^   int size;              \/* Size of buffer *\/$/;"	m	struct:mmapibuf	file:
size	HTKLib/HAudio.c	/^   int used,size;        \/* used in data, size of data *\/$/;"	m	struct:__anon53	file:
size	HTKLib/HParm.c	/^   int size;          \/* Sample size fields *\/$/;"	m	struct:hparmsrcdef	file:
size	HTKLib/HWave.c	/^   int32 size;        \/* size of rest of chunk *\/$/;"	m	struct:__anon104	file:
size	HTKLib/HWave.c	/^   int32 size;$/;"	m	struct:__anon105	file:
size	HTKTools/HHEd.c	/^   int size;                    \/* number of non terminal nodes *\/$/;"	m	struct:_Tree	file:
sizes	HTKLib/HRNLM.h	/^    int nrows, ncols, sizes;$/;"	m	struct:_Layer
skipOOV	HLMTools/LPlex.c	/^static Boolean skipOOV  = TRUE;     \/* discard OOV in computation *\/$/;"	v	file:
skipend	HTKLib/HFB.h	/^  int skipend;$/;"	m	struct:__anon139
skipendInit	HTKLib/HFB.c	/^static int skipendInit   = -1;$/;"	v	file:
skipstart	HTKLib/HFB.h	/^  int skipstart;      \/* Skipover region - debugging only *\/$/;"	m	struct:__anon139
skipstartInit	HTKLib/HFB.c	/^static int skipstartInit = -1;$/;"	v	file:
slaHeap	HTKLib/HLat.c	/^static MemHeap slaHeap, slnHeap;\/* MHEAPs for use in LatExpand() *\/$/;"	v	file:
slat	HTKLib/HNet.c	/^static Lattice *slat;   \/* Used by qsort cmp routines *\/$/;"	v	file:
slnHeap	HTKLib/HLat.c	/^static MemHeap slaHeap, slnHeap;\/* MHEAPs for use in LatExpand() *\/$/;"	v	file:
smfactor	HTKLib/HRNLM.h	/^    float smfactor;$/;"	m	struct:_Layer
smvalue	HTKTools/HLRescore.c	/^static float smvalue = 1.0;$/;"	v	file:
snum	HTKTools/HHEd.c	/^   short snum;$/;"	m	struct:_Node	file:
socket	HTKLib/HAudio.c	/^   int socket;$/;"	m	struct:_AudioIn	file:
socket	HTKLib/HAudio.c	/^   int socket;$/;"	m	struct:_AudioOut	file:
softmax	HTKLib/HRNLM.c	/^void softmax (real *ac, int start, int end)$/;"	f
softmax_vf_vf	HTKLib/HNLM.c	/^void softmax_vf_vf(int n, const float* in_vec, float* out_vec)$/;"	f
softmaxij	HTKLib/HRNLM.c	/^void softmaxij (float *ac, int num)$/;"	f
softmaxij_sm	HTKLib/HRNLM.c	/^void softmaxij_sm (float *ac, int num, float smfactor)$/;"	f
sort	HLMLib/LWMap.h	/^   int sort;               \/* for sorting (gives lexical ordering) *\/$/;"	m	struct:MAPENTRY
sortFirst	HTKTools/HLEd.c	/^static Boolean sortFirst = FALSE;   \/* Sort on loading *\/$/;"	v	file:
sortLattice	HTKTools/HLRescore.c	/^static Boolean sortLattice = TRUE;         \/* sort lattice nodes by time & posterior *\/$/;"	v	file:
sortTab	HLMLib/LWMap.c	/^static LabId *sortTab;               \/* global temp used by qsort *\/$/;"	v	file:
sort_order	HLMTools/Cluster.c	/^static int          sort_order = SORT_WMAP; \/* Order words are considered in *\/$/;"	v	file:
sort_uni	HLMTools/Cluster.c	/^static int         *sort_uni;               \/* Sort unigrams by count *\/$/;"	v	file:
source	HLMLib/LWMap.h	/^   char    *source;      \/* description of sources *\/$/;"	m	struct:__anon20
source	HTKLib/HLM.c	/^static Source source;           \/* input file *\/$/;"	v	file:
source	HTKLib/HLat.c	/^   Source source;$/;"	m	struct:_LLFInfo	file:
source	HTKLib/HUtil.c	/^static Source *source;         \/* Current source for item list *\/$/;"	v	file:
source	HTKTools/HDMan.c	/^   LabId source;                \/* name of source dict *\/$/;"	m	struct:__anon160	file:
source	HTKTools/HDMan.c	/^   LabId source;                \/* name of source dict *\/$/;"	m	struct:__anon162	file:
source	HTKTools/HHEd.c	/^static Source source;      \/* the current input file *\/$/;"	v	file:
spDetCnt	HTKLib/HParm.c	/^   int spDetCnt;       \/* Number of speech frames in window *\/$/;"	m	struct:_ParmBuf	file:
spDetCur	HTKLib/HParm.c	/^   int spDetCur;       \/* Current speech detector frame *\/$/;"	m	struct:_ParmBuf	file:
spDetEn	HTKLib/HParm.c	/^   int spDetEn;        \/* row after last to return (MAX_INT == waiting) *\/$/;"	m	struct:_ParmBuf	file:
spDetEn	HTKLib/HParm.h	/^   int spDetEn;               \/* Frame number of last frame of buffer *\/$/;"	m	struct:__anon122
spDetFin	HTKLib/HParm.c	/^   int spDetFin;       \/* final row allowed to return (normally qen) *\/$/;"	m	struct:_ParmBuf	file:
spDetLst	HTKLib/HParm.c	/^   int spDetLst;       \/* Last frame of speech seen *\/$/;"	m	struct:_ParmBuf	file:
spDetParmsSet	HTKLib/HParm.c	/^   Boolean spDetParmsSet; \/* Speech detector parameters set *\/$/;"	m	struct:channelinfo	file:
spDetParmsSet	HTKLib/HParm.h	/^   Boolean spDetParmsSet;     \/* Parameters set for sp\/sil detector *\/$/;"	m	struct:__anon122
spDetSNR	HTKLib/HParm.c	/^   float spDetSNR;        \/* Measured\/set silence\/speech ratio (dB) *\/$/;"	m	struct:channelinfo	file:
spDetSNR	HTKLib/HParm.h	/^   float spDetSNR;            \/* Speech\/noise ratio for channel *\/$/;"	m	struct:__anon122
spDetSil	HTKLib/HParm.c	/^   float spDetSil;        \/* Measured\/set silence level for channel (dB) *\/$/;"	m	struct:channelinfo	file:
spDetSil	HTKLib/HParm.h	/^   float spDetSil;            \/* Silence level for channel *\/$/;"	m	struct:__anon122
spDetSp	HTKLib/HParm.c	/^   float spDetSp;         \/* Measured\/set speech level for channel (dB) *\/$/;"	m	struct:channelinfo	file:
spDetSp	HTKLib/HParm.h	/^   float spDetSp;             \/* Speech level for channel *\/$/;"	m	struct:__anon122
spDetSt	HTKLib/HParm.c	/^   int spDetSt;        \/* first row to return (MAX_INT == waiting) *\/$/;"	m	struct:_ParmBuf	file:
spDetSt	HTKLib/HParm.h	/^   int spDetSt;               \/* Frame number of first frame of buffer *\/$/;"	m	struct:__anon122
spDetThresh	HTKLib/HParm.c	/^   float spDetThresh;     \/* Measured\/set speech\/silence threshold (dB) *\/$/;"	m	struct:channelinfo	file:
spDetThresh	HTKLib/HParm.h	/^   float spDetThresh;         \/* Silence\/speech level threshold *\/$/;"	m	struct:__anon122
spPattern	HTKTools/HCompV.c	/^static char spPattern[MAXSTRLEN];        \/* speaker mask *\/$/;"	v	file:
spSum	HTKLib/HAdapt.c	/^   Vector spSum;$/;"	m	struct:__anon94	file:
spSumSq	HTKLib/HAdapt.c	/^   Vector spSumSq;$/;"	m	struct:__anon94	file:
spThresh	HTKLib/HParm.c	/^   float spThresh;            \/* Speech Threshold (in dB above sil level) *\/$/;"	m	struct:__anon76	file:
spVal	HTKLib/HParm.c	/^   float *spVal;       \/* Array of speech\/silence levels *\/$/;"	m	struct:_ParmBuf	file:
spcGlchCount	HTKLib/HParm.c	/^   int spcGlchCount;          \/*   of spc in sil acceptable as glitches *\/$/;"	m	struct:__anon76	file:
spcSeqCount	HTKLib/HParm.c	/^   int spcSeqCount;           \/* Number of frames for speech window *\/$/;"	m	struct:__anon76	file:
spcl_btn	HTKTools/HSLab.c	/^static HButton *spcl_btn;                 \/* pointer to special button *\/$/;"	v	file:
spcl_str	HTKTools/HSLab.c	/^static char spcl_str[SLEN] = "Command";   \/* special button string *\/$/;"	v	file:
spdf	HTKLib/HModel.h	/^   MixtureVector spdf;  \/* Mixture Vector *\/$/;"	m	struct:__anon61
speakerOut	HTKLib/HAudio.c	/^static Boolean speakerOut = FALSE;$/;"	v	file:
specialNull	HTKLib/HNet.c	/^static DictEntry specialNull;$/;"	v	file:
speechio	HTKBook/htkbook-pdf.tex	/^\\include{openviron}$/;"	i
speechio	HTKBook/htkbook.tex	/^\\include{openviron}$/;"	i
spfn	HTKTools/HSLab.c	/^static char spfn[SLEN] = "noname.wav";     \/* the speech (waveform) file name *\/$/;"	v	file:
spkrFails	HTKTools/HResults.c	/^static int  spkrFails = 0;     \/* num time spkr pattern fails to match *\/$/;"	v	file:
spkrHead	HTKTools/HResults.c	/^static Spkr *spkrHead = NULL;$/;"	v	file:
spkrMask	HTKTools/HResults.c	/^static char * spkrMask = NULL;        \/* non-null report on per spkr basis *\/$/;"	v	file:
splitNameHeap	HTKTools/HParse.c	/^MemHeap  splitNameHeap;$/;"	v
spotWidth	HTKTools/HResults.c	/^static int spotWidth = 66;$/;"	v	file:
spots	HTKTools/HResults.c	/^static SpotRec **spots;$/;"	v	file:
sqOffset	HLMLib/LGBase.c	/^static int sqOffset;                    \/* squash offset, this depends on byte *\/$/;"	v	file:
sqr	HTKTools/HHEd.c	/^   Vector sqr;                  \/* count statistics             *\/$/;"	m	struct:_AccSum	file:
squareSum	HTKTools/HCompV.c	/^   Covariance   squareSum;          \/* acc for sum of squares *\/$/;"	m	struct:__anon151	file:
squareSum	HTKTools/HCompV.c	/^   Vector squareSum;                     \/* variance structure for speaker *\/$/;"	m	struct:__anon152	file:
src	HLMLib/LGBase.h	/^   Source src;              \/* the input stream *\/$/;"	m	struct:__anon4
src	HLMTools/LGPrep.c	/^   FieldVec src;              \/* match part of rule *\/$/;"	m	struct:ruledef	file:
src	HTKLib/HParm.c	/^   Source src;        \/* Source to read HParm file from *\/$/;"	m	struct:__anon76	file:
src	HTKTools/HDMan.c	/^   Source src;                  \/* input file source *\/$/;"	m	struct:__anon162	file:
srcFF	HTKLib/HParm.c	/^   FileFormat srcFF;          \/* Source File format *\/ $/;"	m	struct:__anon76	file:
srcFF	HTKLib/HParm.h	/^   FileFormat srcFF;          \/* Source File format *\/ $/;"	m	struct:__anon122
srcFF	HTKTools/HCopy.c	/^FileFormat srcFF     = UNDEFF;   \/* I\/O configuration options *\/$/;"	v
srcFN	HLMTools/HLMCopy.c	/^static char      *srcFN = NULL;          \/* source file name *\/$/;"	v	file:
srcFN	HLMTools/LBuild.c	/^static char *srcFN   = NULL;        \/* input LM filename *\/$/;"	v	file:
srcFN	HLMTools/LNorm.c	/^static char      *srcFN = NULL;          \/* source file name *\/$/;"	v	file:
srcHdr	HTKTools/HList.c	/^static Boolean srcHdr  = FALSE;  \/* print source header info *\/$/;"	v	file:
srcLM	HLMTools/LBuild.c	/^static BackOffLM *srcLM = NULL;     \/* the source model if any *\/$/;"	v	file:
srcLabFF	HTKTools/HCopy.c	/^FileFormat srcLabFF  = UNDEFF;$/;"	v
srcPK	HTKLib/HParm.c	/^   ParmKind srcPK;            \/* Source ParmKind *\/ $/;"	m	struct:__anon76	file:
srcPK	HTKLib/HParm.h	/^   ParmKind srcPK;            \/* Source ParmKind *\/ $/;"	m	struct:__anon122
srcPK	HTKTools/HCopy.c	/^ParmKind srcPK       = ANON;$/;"	v
srcSampRate	HTKLib/HParm.c	/^   HTime srcSampRate;         \/* Source Sample Rate *\/ $/;"	m	struct:__anon76	file:
srcSampRate	HTKLib/HParm.h	/^   HTime srcSampRate;         \/* Source Sample Rate *\/ $/;"	m	struct:__anon122
srcSampRate	HTKTools/HCopy.c	/^HTime srcSampRate    = 0.0;$/;"	v
srcUsed	HTKLib/HParm.c	/^   int srcUsed;       \/* num columns which was used in source *\/$/;"	m	struct:__anon76	file:
srcVecSize	HTKLib/HParm.h	/^   int srcVecSize;            \/* Size of source vector *\/$/;"	m	struct:__anon122
srcdir	HTKLib/Makefile	/^srcdir = .$/;"	m
srcdir	HTKTools/Makefile	/^srcdir = .$/;"	m
sstId	HLMLib/LPCalc.c	/^static LabId  sstId;                          \/* sentence start marker *\/$/;"	v	file:
sstId	HLMTools/LGPrep.c	/^static LabId sstId = NULL;          \/* sentence start id *\/$/;"	v	file:
sstId	HLMTools/LPlex.c	/^static LabId sstId = NULL;          \/* sentence start marker *\/$/;"	v	file:
sstStr	HLMLib/LPCalc.c	/^static char   sstStr[256] = DEF_STARTWORD;    \/* sentence start marker *\/$/;"	v	file:
st	HTKTools/HCopy.c	/^static HTime st=0.0;            \/* start of samples to copy *\/$/;"	v	file:
st	HTKTools/HSLab.c	/^   long st, en;            \/* start and end sample of the previous zoom level *\/$/;"	m	struct:__anon145	file:
stHeap	HTKLib/HRec.c	/^   MemHeap *stHeap;         \/* Array[0..stHeapNum-1] of heaps for states *\/$/;"	m	struct:precinfo	file:
stHeapIdx	HTKLib/HRec.c	/^   short *stHeapIdx;        \/* Array[1..max] of state to heap index *\/$/;"	m	struct:psetinfo	file:
stHeapNum	HTKLib/HRec.c	/^   short stHeapNum;         \/* Number of separate state heaps *\/$/;"	m	struct:psetinfo	file:
stRow	HTKLib/HParm.c	/^   int stRow;        \/* absolute number of first row in this block *\/$/;"	m	struct:pblock	file:
start	HTKLib/HArc.h	/^  CorrN *start;$/;"	m	struct:_CorrA
start	HTKLib/HArc.h	/^  HArc *start; \/*The beginning and end of a dll of arcs.*\/$/;"	m	struct:ArcInfoStruct
start	HTKLib/HArc.h	/^  HArc *start;$/;"	m	struct:_ArcTrans
start	HTKLib/HFBLat.c	/^   int start;$/;"	m	struct:__anon89	file:
start	HTKLib/HLabel.h	/^   HTime start,end;         \/* Start and end times in 100ns units *\/$/;"	m	struct:_Label
start	HTKLib/HNet.h	/^   NodeId start;       \/* Node at start of word *\/$/;"	m	struct:larc
start	HTKLib/HNet.h	/^   NodeId start;       \/* Node at start of word *\/$/;"	m	struct:larc_e
start	HTKLib/HNet.h	/^   NodeId start;$/;"	m	struct:larc_s
startLMWord	HTKLib/HLat.c	/^static LabId startLMWord;       \/* word at start in LM (<s>) *\/$/;"	v	file:
startLMWord	HTKTools/HLRescore.c	/^static char *startLMWord;       \/* word at start in LM (<s>) *\/$/;"	v	file:
startLab	HTKTools/HLRescore.c	/^static LabId startLab;          \/* corresponding LabId *\/$/;"	v	file:
startWord	HTKLib/HLat.c	/^static LabId startWord;         \/* word at start of Lattice (!SENT_START) *\/$/;"	v	file:
startWord	HTKTools/HLRescore.c	/^static char *startWord;         \/* word at start of Lattice (!SENT_START) *\/$/;"	v	file:
start_class	HLMTools/Cluster.c	/^static int         start_class = 2;         \/* Which is the first 'real' class? *\/$/;"	v	file:
start_foll	HTKLib/HArc.h	/^  ArcTrans *start_foll; \/*The transition is in a dll w.r.t both the arcs it follows and the ones it precedes.*\/$/;"	m	struct:_ArcTrans
start_foll	HTKLib/HArc.h	/^  CorrA *start_foll;$/;"	m	struct:_CorrA
start_id	HLMTools/Cluster.c	/^static int         start_id=-1, end_id=-1;  \/* Start and end word ids *\/$/;"	v	file:
start_inst	HTKLib/HRec.c	/^   NetInst *start_inst;     \/* Inst that started a move *\/$/;"	m	struct:precinfo	file:
start_prec	HTKLib/HArc.h	/^  ArcTrans *start_prec; \/*the start_{foll,prec} dll is the list of the transitions attached to the same start node; *\/$/;"	m	struct:_ArcTrans
starti	HTKLib/HArc.h	/^  int starti;  \/* start & end of search beam. *\/$/;"	m	struct:_CorrN
starting_alpha	HTKLib/HRNLM.h	/^    real starting_alpha;$/;"	m	struct:_RNNLM
starts	HTKLib/HNet.c	/^   NetNode *starts; \/* Chain of initial models *\/$/;"	m	struct:pronholder	file:
statFN	HTKTools/HERest.c	/^static char * statFN;            \/* stats file, if any *\/$/;"	v	file:
statFN	HTKTools/HMMIRest.c	/^static char * statFN=0;            \/* stats file, if any *\/$/;"	v	file:
statFN	HTKTools/HSmooth.c	/^static char * statFN;            \/* stats file, if any *\/$/;"	v	file:
statHeap	HTKTools/HLStats.c	/^static MemHeap statHeap;            \/* Permenant stats storage *\/$/;"	v	file:
state	HTKLib/HNet.h	/^   int state;         \/* State number (-1==model_end) *\/$/;"	m	struct:lalign
state	HTKLib/HRec.c	/^   TokenSet *state;     \/* TokenSet[0..N-2] in state [1..N-1] for hmm *\/$/;"	m	struct:_NetInst	file:
state	HTKLib/HRec.c	/^   short state;         \/* State level traceback info *\/$/;"	m	struct:align	file:
state	HTKTools/HHEd.c	/^   int    state;             \/* state containing this component *\/$/;"	m	struct:_CoList	file:
state	HTKTools/HHEd.c	/^   int state;                   \/* state (or 0 if hmm tree) *\/$/;"	m	struct:_Tree	file:
state	HTKTools/HHEd.c	/^   short state;                 \/* state of clink *\/$/;"	m	struct:_CRec	file:
stateCounter	HTKLib/HModel.h	/^   int stateCounter;    \/* # of state occurrences *\/$/;"	m	struct:__anon62
states	HTKLib/HRec.c	/^   Boolean states;          \/* Keep track of state history *\/$/;"	m	struct:precinfo	file:
states	HTKTools/HVite.c	/^static Boolean states = FALSE;    \/* Keep track of state alignment *\/$/;"	v	file:
staticSemiTied	HTKLib/HAdapt.c	/^static Boolean staticSemiTied = FALSE;$/;"	v	file:
stats	HTKTools/HERest.c	/^static Boolean stats = FALSE;    \/* enable statistics reports *\/$/;"	v	file:
stats	HTKTools/HMMIRest.c	/^static Boolean stats = FALSE;    \/* enable statistics reports *\/$/;"	v	file:
stats	HTKTools/HSGen.c	/^static Boolean stats = FALSE;       \/* enable grammar stats estimation *\/$/;"	v	file:
stats	HTKTools/HSmooth.c	/^static Boolean stats = FALSE;    \/* enable statistics reports *\/$/;"	v	file:
status	HTKLib/HAudio.c	/^   AudioInStatus status;     \/* current status of this audio stream *\/$/;"	m	struct:_AudioIn	file:
status	HTKLib/HParm.c	/^   PBStatus status;    \/* status of this buffer *\/$/;"	m	struct:_ParmBuf	file:
stdBuf	HLMTools/LAdapt.c	/^static ShiftReg  stdBuf;            \/* used for normal N-gram processing *\/$/;"	v	file:
stdBuf	HLMTools/LGPrep.c	/^static ShiftReg stdBuf;             \/* used for normal N-gram processing *\/$/;"	v	file:
stdGC	HTKTools/HHEd.c	/^static float meanGC,stdGC;             \/* mean and stdev of GConst *\/$/;"	v	file:
ste	HTKLib/HUtil.h	/^   StreamElem *ste;  \/* ->current streamElem *\/$/;"	m	struct:__anon38
stenSet	HTKTools/HCopy.c	/^static Boolean stenSet=FALSE;   \/* set if either st or en set *\/$/;"	v	file:
step	HTKTools/HSLab.c	/^   float step;$/;"	m	struct:__anon149	file:
stindex	HTKLib/HShell.c	/^   long stindex;                        \/* start sample to extract *\/$/;"	m	struct:__anon140	file:
stopSignalled	HTKLib/HAudio.c	/^static volatile Boolean stopSignalled;$/;"	v	file:
store	HLMTools/Cluster.c	/^static bi_count    *store;                  \/* Store of current word w (w,*) pairs *\/$/;"	v	file:
storeMInfo	HTKLib/HAdapt.c	/^static Boolean storeMInfo = TRUE;      \/* whether original model information  is to be stored *\/$/;"	v	file:
store_idx	HLMTools/Cluster.c	/^static int          store_idx;              \/* Next index of second word in bigram *\/$/;"	v	file:
str	HTKLib/HGraf.h	/^   char *str;                 \/* string in button *\/$/;"	m	struct:_HButton
str	HTKTools/HCopy.c	/^   char *str;                   \/* output string *\/$/;"	m	struct:_TrList	file:
stream	HTKLib/HAudio.c	/^   SStream stream;$/;"	m	struct:_AudioIn	file:
stream	HTKLib/HAudio.c	/^   SStream stream;$/;"	m	struct:_AudioOut	file:
stream	HTKLib/HModel.h	/^   int stream;          \/* enables multi-stream semi-tied transforms *\/$/;"	m	struct:__anon56
stream	HTKTools/HHEd.c	/^   int    stream;            \/* stream for this component *\/$/;"	m	struct:_CoList	file:
streamMode	HLMTools/LPlex.c	/^static Boolean streamMode = FALSE;  \/* stream mode *\/$/;"	v	file:
string	HTKLib/HNLM.h	/^    char **string;$/;"	m	struct:string2indexmap
string2indexmap	HTKLib/HNLM.h	/^typedef struct string2indexmap {$/;"	s
stripContexts	HTKTools/HResults.c	/^static Boolean stripContexts = FALSE; \/* strip triphone contexts *\/$/;"	v	file:
stripTriPhones	HTKLib/HLabel.c	/^static Boolean stripTriPhones = FALSE;   \/* Enable triPhone stripping *\/$/;"	v	file:
strlen_LEVELSEP	HTKLib/HLabel.c	581;"	d	file:
strmProj	HTKLib/HTrain.c	/^Boolean strmProj = FALSE; $/;"	v
stroutp	HTKTools/HRest.c	/^static Vector **stroutp;   \/* array[1..maxT][2..nStates-1][1..nStreams] ...*\/$/;"	v	file:
structure	HTKLib/HModel.h	/^   Ptr structure;          \/* -> shared structure or HMM Def *\/$/;"	m	struct:_MacroDef
style	HTKLib/HParm.c	/^   CodeStyle style;   \/* style encoding *\/$/;"	m	struct:__anon76	file:
sub	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Cell	file:
sub	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Spkr	file:
sub	HTKTools/HResults.c	/^static long sub   = 0;     \/* Total substitutions *\/$/;"	v	file:
subLatEnd	HTKLib/HNet.c	/^char *subLatEnd="!)_SUBLAT",subLatEndBuf[MAXSTRLEN];$/;"	v
subLatEndBuf	HTKLib/HNet.c	/^char *subLatEnd="!)_SUBLAT",subLatEndBuf[MAXSTRLEN];$/;"	v
subLatId	HTKLib/HNet.h	/^   LabId subLatId;              \/* Lattice Identifier (for SubLats only) *\/$/;"	m	struct:lattice
subLatStart	HTKLib/HNet.c	/^char *subLatStart="!SUBLAT_(",subLatStartBuf[MAXSTRLEN];$/;"	v
subLatStartBuf	HTKLib/HNet.c	/^char *subLatStart="!SUBLAT_(",subLatStartBuf[MAXSTRLEN];$/;"	v
subLatWord	HTKLib/HDict.h	/^   Word subLatWord;     \/* special word for HNet subLats *\/$/;"	m	struct:__anon74
subList	HTKLib/HNet.h	/^   SubLatDef *subList;          \/* List of sublats in this lattice level *\/$/;"	m	struct:lattice
subNetHeap	HTKTools/HParse.c	/^static MemHeap subNetHeap;$/;"	v	file:
subNetId	HTKTools/HParse.c	/^static LabId  subNetId;$/;"	v	file:
subNetStoreHeap	HTKTools/HParse.c	/^MemHeap  subNetStoreHeap;$/;"	v
subPen	HTKTools/HResults.c	/^static const int subPen = 10;     \/* error penalties *\/$/;"	v	file:
subPenNIST	HTKTools/HResults.c	/^static const int subPenNIST = 4;  \/* NIST error penalties *\/$/;"	v	file:
subdir	HTKLib/HLabel.h	/^   char *subdir;     \/* Sub-directory to search for MLF_SIMPLE & MLF_FULL *\/$/;"	m	union:__anon118
subfields	HTKLib/esignal.h	/^    FieldList   subfields;      \/* field specs of subfields *\/$/;"	m	struct:FieldSpec
sublat	HTKLib/HNet.h	/^   SubLatDef *sublat;  \/* SubLat for node (if word==lat->voc->subLatWord) *\/$/;"	m	struct:lnode
sublatdef	HTKLib/HNet.h	/^typedef struct sublatdef {$/;"	s
sublatmarkers	HTKLib/HNet.c	/^Boolean sublatmarkers=FALSE;$/;"	v
succ	HTKLib/HLabel.h	/^   LLink succ;              \/* Successor label *\/$/;"	m	struct:_Label
succ	HTKTools/HParse.c	/^   LinkSet *succ;    \/* successors to this node *\/$/;"	m	struct:_Node	file:
succeedwords	HTKLib/HRNLM.h	/^    int succeedwords, nsucclayer, succmergelayer;$/;"	m	struct:_RNNLM
succlayers	HTKLib/HRNLM.h	/^    Layer *succlayers, *layer1_succ;$/;"	m	struct:_RNNLM
succlayersizes	HTKLib/HRNLM.h	/^    int *succlayersizes;$/;"	m	struct:_RNNLM
succmergelayer	HTKLib/HRNLM.h	/^    int succeedwords, nsucclayer, succmergelayer;$/;"	m	struct:_RNNLM
sum	HTKTools/HHEd.c	/^   Vector sum;                  \/* the sum, sqr and occupation  *\/$/;"	m	struct:_AccSum	file:
sumDur	HTKTools/HLStats.c	/^   float sumDur;                 \/* Total duration *\/$/;"	m	struct:wordinfo	file:
sum_of_all_bigram_counts	HLMTools/Cluster.c	/^static int         sum_of_all_bigram_counts;\/* Sum of all bigram counts *\/$/;"	v	file:
sum_of_all_uni_counts	HLMTools/Cluster.c	/^static int         sum_of_all_uni_counts;   \/* Sum of all unigram counts *\/$/;"	v	file:
svec	HTKLib/HModel.h	/^   StateElem *svec;        \/* array[2..numStates-1] of StateElem *\/  $/;"	m	struct:__anon64
sw	HTKLib/HAudio.c	/^   long sw;$/;"	m	struct:_AudioIn	file:
sw	HTKLib/HAudio.c	/^   long sw;$/;"	m	struct:_AudioOut	file:
swapXForm	HTKLib/HModel.h	/^  struct _AdaptXForm  *swapXForm;    \/* has this transform been swapped with parent *\/$/;"	m	struct:_AdaptXForm	typeref:struct:_AdaptXForm::_AdaptXForm
swapXForms	HTKLib/HAdapt.c	/^static Boolean swapXForms = FALSE;     \/* swap the transforms around after generating transform *\/$/;"	v	file:
swidth	HTKLib/HModel.h	/^   short swidth[SMAX];     \/* [0]=num streams,[i]=width of stream i *\/$/;"	m	struct:_HMMSet
swidth	HTKLib/HModel.h	/^  IntVec swidth;       \/* stream width size *\/$/;"	m	struct:__anon65
swidth	HTKLib/HParm.h	/^   short swidth[SMAX];   \/* [0]=num streams,[i]=width of stream i *\/$/;"	m	struct:__anon120
swidth	HTKLib/HVQ.h	/^   short swidth[SMAX];  \/* sw[0]=num streams, sw[i]=width of stream i *\/$/;"	m	struct:_VQTabRec
swidth	HTKTools/HQuant.c	/^static short swidth[SMAX];          \/* stream widths *\/$/;"	v	file:
swidth0	HTKTools/HCopy.c	/^int swidth0 = 1;$/;"	v
sym	HTKLib/HModel.c	/^   Symbol sym;          \/* the current input symbol *\/$/;"	m	struct:__anon42	file:
sym	HTKLib/HModel.c	/^   Symbol sym; } symMap[] = $/;"	m	struct:__anon41	file:
symMap	HTKLib/HModel.c	/^   Symbol sym; } symMap[] = $/;"	v	typeref:struct:__anon41	file:
symNames	HTKLib/HModel.c	/^static char *symNames[NULLSYM+1];$/;"	v	file:
symbol	HTKTools/HParse.c	/^static enum _Symbol symbol;         \/* Current symbol *\/$/;"	v	typeref:enum:_Symbol	file:
syn0	HTKLib/HRNLM.h	/^    struct synapse *syn0;		\/*weights between input and hidden layer *\/$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::synapse
syn0_topic	HTKLib/HRNLM.h	/^    struct synapse *syn0_topic;$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::synapse
syn0b	HTKLib/HRNLM.h	/^    struct synapse *syn0b;$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::synapse
syn1	HTKLib/HRNLM.h	/^    struct synapse *syn1;		\/*weights between hidden and output layer (or hidden and compression if compression>0) *\/$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::synapse
syn1b	HTKLib/HRNLM.h	/^    struct synapse *syn1b;$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::synapse
syn_d	HTKLib/HRNLM.h	/^    direct_t *syn_d;		\/*direct parameters between input and output layer (similar to Maximum Entropy model parameters) *\/$/;"	m	struct:_RNNLM
syn_d_topic	HTKLib/HRNLM.h	/^    struct synapse *syn_d_topic;$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::synapse
syn_db	HTKLib/HRNLM.h	/^    direct_t *syn_db;$/;"	m	struct:_RNNLM
synapse	HTKLib/HRNLM.h	/^struct synapse {$/;"	s
sync	HTKLib/HRNLM.h	/^    struct synapse *sync;		\/*weights between hidden and compression layer *\/$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::synapse
syncb	HTKLib/HRNLM.h	/^    struct synapse *syncb;$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::synapse
sysconfdir	HTKLib/Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
sysconfdir	HTKTools/Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
t	HTKLib/HArc.c	/^   struct _ArcList *t;$/;"	m	struct:_ArcList	typeref:struct:_ArcList::_ArcList	file:
t	HTKLib/HFBLat.c	/^   struct _CorrectArcList *t;$/;"	m	struct:_CorrectArcList	typeref:struct:_CorrectArcList::_CorrectArcList	file:
t	HTKLib/HNet.c	/^   int t;$/;"	m	struct:pinstinfo	file:
tBuf	HTKLib/HRec.c	/^   Token *tBuf;             \/* Buffer Array[2..N-1] of tok for StepHMM1 *\/$/;"	m	struct:psetinfo	file:
tIdx	HTKLib/HModel.h	/^   int tIdx;               \/* Transition matrix index *\/$/;"	m	struct:__anon64
tMPruneThresh	HTKTools/HRest.c	/^static float tMPruneThresh = 10.0;    \/* tied mix prune threshold *\/$/;"	v	file:
tProb	HTKTools/HHEd.c	/^   float tProb;                 \/* likelihood of total cluster *\/$/;"	m	struct:_Node	file:
tStack	HTKTools/HCopy.c	/^static MemHeap tStack;          \/* trace list  stack *\/$/;"	v	file:
tType	HTKTools/HQuant.c	/^static TreeType tType = linTree;    \/* codebook structure *\/$/;"	v	file:
t_end	HTKLib/HArc.h	/^  int t_end;$/;"	m	struct:_Arc
t_end	HTKLib/HArc.h	/^  int t_start, t_end;$/;"	m	struct:_Acoustic
t_start	HTKLib/HArc.h	/^  int t_start, t_end;$/;"	m	struct:_Acoustic
t_start	HTKLib/HArc.h	/^  int t_start;$/;"	m	struct:_Arc
tabFN	HTKLib/HVQ.h	/^   char * tabFN;        \/* name of this VQ table *\/$/;"	m	struct:_VQTabRec
table	HTKLib/HRNLM.h	/^    HashSlot**   table;$/;"	m	struct:__anon91
tact	HTKLib/HRec.c	/^   int tact;                \/* Cummulative number of active instances *\/$/;"	m	struct:precinfo	file:
tag	HTKLib/HNet.h	/^   char    *tag;        \/* Semantic tagging information *\/$/;"	m	struct:_NetNode
tag	HTKLib/HNet.h	/^   char *tag;          \/* Semantic tag for this node *\/$/;"	m	struct:lnode
tagSentStart	HLMTools/LGPrep.c	/^static Boolean tagSentStart = FALSE;\/* tag senetence start words with _ *\/$/;"	v	file:
tagSources	HTKTools/HDMan.c	/^static Boolean tagSources = FALSE;   \/* tag output words with name of source dict *\/$/;"	v	file:
tail	HLMTools/LGPrep.c	/^   RuleDef * tail;            \/* tail of list of rules *\/$/;"	m	struct:__anon28	file:
tail	HTKLib/HLabel.h	/^   LLink tail;              \/* Pointer to tail of List *\/$/;"	m	struct:_LabList
tail	HTKLib/HLabel.h	/^   LabList *tail;          \/* Pointer to tail of Label List *\/$/;"	m	struct:__anon116
tail	HTKLib/HRec.c	/^   NetInst tail;            \/* Tail (newest) of Inst linked list *\/$/;"	m	struct:precinfo	file:
takeLogs	HTKLib/HSigP.h	/^   Boolean takeLogs;    \/* log filterbank channels *\/$/;"	m	struct:__anon129
tanh_vf_vf	HTKLib/HNLM.c	/^void tanh_vf_vf(int n, const float* in_vec, float* out_vec)$/;"	f
tanhij	HTKLib/HRNLM.c	/^void tanhij (float *ac, int num)$/;"	f
target	HTKLib/Makefile	/^target = HTKLib.a$/;"	m
tee	HTKLib/HNet.c	/^   Boolean tee;     \/* TRUE if word consists solely of tee models *\/$/;"	m	struct:pronholder	file:
teeWords	HTKLib/HNet.h	/^   Boolean teeWords;  \/* True if any tee words are present *\/$/;"	m	struct:__anon128
tempArcStack	HTKLib/HArc.c	/^static MemHeap tempArcStack;                  \/* for temporary structures. *\/$/;"	v	file:
tempHeap	HLMTools/LPlex.c	/^MemHeap tempHeap;                   \/* Stores data valid only for file *\/$/;"	v
tempHeap	HTKTools/HLEd.c	/^static MemHeap tempHeap;            \/* Storage for current file *\/$/;"	v	file:
tempHeap	HTKTools/HResults.c	/^MemHeap tempHeap;                     \/* Stores data valid only for file *\/$/;"	v
tempStack	HTKLib/HFBLat.h	/^  MemHeap tempStack;$/;"	m	struct:__anon54
test	HTKTools/HResults.c	/^static LabList *ref,*test;            \/* the labels being compared *\/$/;"	v	file:
testInfo	HLMTools/LPlex.c	/^static int     testInfo[MAX_TEST];  \/* the array of test records *\/$/;"	v	file:
test_file	HTKLib/HRNLM.h	/^    char test_file[MAX_STRING];$/;"	m	struct:_RNNLM
texttt  AT i j prob itemList  t 	HTKBook/HTKRef/HHEd.tex	/^The \\htool{HHEd} commands are as follows$/;"	b
tff	HTKTools/HResults.c	/^static FileFormat tff   = UNDEFF;     \/* ff of test transcription files *\/$/;"	v	file:
tgInfo	HLMLib/LModel.h	/^   TuringGoodInfo tgInfo;   \/* Turing-Good discounting *\/$/;"	m	union:__anon12
tgt	HLMTools/LGPrep.c	/^   FieldVec tgt;              \/* replacement part of rule *\/$/;"	m	struct:ruledef	file:
tgtFF	HTKLib/HParm.c	/^   FileFormat tgtFF;          \/* Target File format *\/ $/;"	m	struct:__anon76	file:
tgtFF	HTKLib/HParm.h	/^   FileFormat tgtFF;          \/* Target File format *\/ $/;"	m	struct:__anon122
tgtFF	HTKTools/HCopy.c	/^FileFormat tgtFF     = UNDEFF;$/;"	v
tgtFN	HLMTools/HLMCopy.c	/^static char      *tgtFN = NULL;          \/* target file name *\/$/;"	v	file:
tgtFN	HLMTools/LBuild.c	/^static char *tgtFN   = NULL;        \/* output LM filename *\/$/;"	v	file:
tgtFN	HLMTools/LMerge.c	/^static char      *tgtFN;                 \/* output model name *\/$/;"	v	file:
tgtFN	HLMTools/LNorm.c	/^static char      *tgtFN = NULL;          \/* target file name *\/$/;"	v	file:
tgtHdr	HTKTools/HList.c	/^static Boolean tgtHdr  = FALSE;  \/* print target header info *\/$/;"	v	file:
tgtLM	HLMTools/LBuild.c	/^static BackOffLM *tgtLM = NULL;     \/* the generated LM *\/$/;"	v	file:
tgtLM	HLMTools/LMerge.c	/^static BackOffLM *tgtLM;                 \/* target lm *\/$/;"	v	file:
tgtLabFF	HTKTools/HCopy.c	/^FileFormat tgtLabFF  = UNDEFF;$/;"	v
tgtPK	HTKLib/HParm.c	/^   ParmKind tgtPK;            \/* Target ParmKind *\/ $/;"	m	struct:__anon76	file:
tgtPK	HTKLib/HParm.h	/^   ParmKind tgtPK;            \/* Target ParmKind *\/ $/;"	m	struct:__anon122
tgtPK	HTKTools/HCopy.c	/^ParmKind tgtPK       = ANON;$/;"	v
tgtSampRate	HTKLib/HParm.c	/^   HTime tgtSampRate;         \/* Target Sample Rate *\/ $/;"	m	struct:__anon76	file:
tgtSampRate	HTKLib/HParm.h	/^   HTime tgtSampRate;         \/* Target Sample Rate *\/ $/;"	m	struct:__anon122
tgtSampRate	HTKTools/HCopy.c	/^HTime tgtSampRate    = 0.0;$/;"	v
tgtUsed	HTKLib/HParm.c	/^   int tgtUsed;       \/* num columns which will be used once converted *\/$/;"	m	struct:__anon76	file:
tgtVecSize	HTKLib/HParm.h	/^   int tgtVecSize;            \/* Size of target vector *\/$/;"	m	struct:__anon122
tgtVoc	HLMTools/LAdapt.c	/^static WordMap   *tgtVoc = NULL;    \/* target vocabulary *\/          $/;"	v	file:
theBitmap	HTKLib/HGraf_WIN32.c	/^static HBITMAP  theBitmap;        \/* Internal representation of window contents *\/$/;"	v	file:
theBrush	HTKLib/HGraf_WIN32.c	/^static HBRUSH theBrush = NULL;      \/* Used to fill solid areas *\/$/;"	v	file:
theCmap	HTKLib/HGraf.c	/^static Colormap      theCmap;$/;"	v	file:
theDisp	HTKLib/HGraf.c	/^static Display       *theDisp;                           $/;"	v	file:
theFont	HTKLib/HGraf_WIN32.c	/^static HFONT theFont   = NULL;      \/* Current font for text output *\/$/;"	v	file:
theGC	HTKLib/HGraf.c	/^static GC            theGC;$/;"	v	file:
thePen	HTKLib/HGraf_WIN32.c	/^static HPEN thePen     = NULL;      \/* Used to draw lines *\/$/;"	v	file:
theScreen	HTKLib/HGraf.c	/^static int           theScreen;                          $/;"	v	file:
theVisual	HTKLib/HGraf.c	/^static Visual        *theVisual;$/;"	v	file:
theWindow	HTKLib/HGraf.c	/^static Window        rootW, theWindow;                   $/;"	v	file:
theWindow	HTKLib/HGraf_WIN32.c	/^static HWND theWindow = NULL;     \/* A handle to the graphics window *\/$/;"	v	file:
thinPen	HTKLib/HGraf_WIN32.c	/^static HPEN thinPen    = NULL;      \/* Always has width 1, needed for outlining filled shapes *\/$/;"	v	file:
thirdWin	HTKLib/HParm.c	/^   int thirdWin;              \/* Accel window halfsize *\/$/;"	m	struct:__anon76	file:
thisCommand	HTKTools/HHEd.c	/^static int thisCommand;                \/* index of current command *\/$/;"	v	file:
thisP	HTKTools/HInit.c	/^static Vector   thisP,lastP;     \/* Columns of log probabilities *\/$/;"	v	file:
thisWpos	HTKTools/HSLab.c	/^static int thisWpos, lastWpos;      \/* the positions of the waveform pointer *\/$/;"	v	file:
thresh	HTKLib/HModel.h	/^  float thresh;        \/* split threshold to determine stopping in tree *\/$/;"	m	struct:RegTree
tid	HTKLib/HAudio.c	/^   ATransID tid;$/;"	m	struct:_AudioIn	file:
tid	HTKLib/HAudio.c	/^   ATransID tid;$/;"	m	struct:_AudioOut	file:
tiedMixName	HTKTools/HHEd.c	/^static char tiedMixName[MAXSTRLEN] = "TM"; \/* Tied mixture base name *\/$/;"	v	file:
time	HTKLib/HAdapt.c	/^   int time;$/;"	m	struct:_ObsCache	file:
time	HTKLib/HNet.h	/^   HTime time;         \/* Time of word boundary at node *\/$/;"	m	struct:lnode
time	HTKLib/HTrain.h	/^   int   time;       \/* time for which prob is valid *\/$/;"	m	struct:__anon112
time	HTKLib/HTrain.h	/^   int   time;       \/* time for which prob is valid *\/$/;"	m	struct:__anon115
timerDone	HTKLib/HGraf.c	/^static Boolean timerDone;$/;"	v	file:
tl	HTKLib/HTrain.h	/^   IBLink tl;        \/* tail of list of item blocks *\/$/;"	m	struct:__anon108
tlb	HLMLib/LWMap.h	/^   int *tlb;             \/* the actual lookup array *\/$/;"	m	struct:__anon19
tlev	HTKTools/HResults.c	/^static int tlev=0;                    \/* Label level to be scored *\/$/;"	v	file:
tmBeam	HTKLib/HRec.h	/^   LogFloat tmBeam;         \/* Beam width for tied mixtures *\/$/;"	m	struct:vrecinfo
tmBeam	HTKTools/HVite.c	/^static LogFloat tmBeam = 10.0;    \/* tied mix prune threshold *\/$/;"	v	file:
tmFile	HTKTools/HLRescore.c	/^static char *tmFile = NULL;     \/* RNNLM topic model information, set by -x *\/$/;"	v	file:
tmRecs	HTKLib/HModel.h	/^   TMixRec tmRecs[SMAX];   \/* array[1..S]of tied mixture record *\/$/;"	m	struct:_HMMSet
tmp	HLMTools/Cluster.c	/^static char        tmp[256];                \/* Scrap array *\/$/;"	v	file:
tmpCHeap	HTKTools/HSLab.c	/^static MemHeap tmpCHeap;     \/* storage allocated once *\/$/;"	v	file:
tmpHeap	HTKTools/HHEd.c	/^static MemHeap tmpHeap;     \/* Temporary (duration of command or less) heap *\/$/;"	v	file:
tmpHeap	HTKTools/HLStats.c	/^static MemHeap tmpHeap;             \/* Temporary storage *\/$/;"	v	file:
tmpStack	HTKTools/HSLab.c	/^static MemHeap tmpStack;     \/* temporary storage with reset *\/$/;"	v	file:
tmp_c1	HLMTools/Cluster.c	/^static int        *tmp_c1=NULL;             \/* Temporary set of bigrams (1) *\/$/;"	v	file:
tmp_c2	HLMTools/Cluster.c	/^static int        *tmp_c2=NULL;             \/* Temporary set of bigrams (2) *\/$/;"	v	file:
tmp_c3	HLMTools/Cluster.c	/^static int        *tmp_c3=NULL;             \/* Temporary set of bigrams (3) *\/$/;"	v	file:
tmp_c4	HLMTools/Cluster.c	/^static int        *tmp_c4=NULL;             \/* Temporary set of bigrams (4) *\/$/;"	v	file:
tmp_sum1	HLMTools/Cluster.c	/^static int        *tmp_sum1=NULL;           \/* Temporary word-class counts (1) *\/$/;"	v	file:
tmp_sum2	HLMTools/Cluster.c	/^static int        *tmp_sum2=NULL;           \/* Temporary word-class counts (2) *\/$/;"	v	file:
toggle	HTKLib/HGraf.h	/^   Boolean toggle;            \/* if true, clicking toggles state *\/$/;"	m	struct:_HButton
tok	HTKLib/HRec.c	/^   Token tok;                \/* Most likely Token in state *\/$/;"	m	struct:tokenset	file:
token	HTKLib/HRec.h	/^typedef struct token$/;"	s
tokenset	HTKLib/HRec.c	/^typedef struct tokenset$/;"	s	file:
top	HTKTools/HLEd.c	/^static int top=1;    \/* virtual top level of current label list *\/$/;"	v	file:
topM	HTKLib/HModel.h	/^   short topM;           \/* num TMProbs actually used *\/$/;"	m	struct:__anon60
top_srcdir	HTKLib/Makefile	/^top_srcdir = ..$/;"	m
top_srcdir	HTKTools/Makefile	/^top_srcdir = ..$/;"	m
topicfile	HTKLib/HRNLM.h	/^    char topicfile[MAX_STRING];$/;"	m	struct:_RNNLM
topicmatrix	HTKLib/HRNLM.h	/^    float *topicmatrix;$/;"	m	struct:_RNNLM
topicmatrixfile	HTKLib/HRNLM.h	/^    char topicmatrixfile[MAX_STRING];$/;"	m	struct:_RNNLM
totAlloc	HTKLib/HMem.h	/^   size_t totAlloc;     \/*  total #elems alloc'ed    total #bytes alloc'd *\/$/;"	m	struct:__anon73
totUsed	HTKLib/HMem.h	/^   size_t totUsed;      \/*  total #elems used        total #bytes used    *\/$/;"	m	struct:__anon73
total	HTKLib/HAudio.c	/^   int total;               \/* Total number of samples queued *\/$/;"	m	struct:_AudioIn	file:
total	HTKLib/HAudio.c	/^   int total;               \/* Total number of samples queued *\/$/;"	m	struct:_AudioOut	file:
totalConst	HTKTools/HMMIRest.c	/^static int totalConst=0,nonFlooredConst=0; \/*TODO: print.*\/$/;"	v	file:
totalCount	HTKTools/HCompV.c	/^static long totalCount=0;           \/* total number of vector samples*\/$/;"	v	file:
totalDur	HTKTools/HResults.c	/^static HTime totalDur = 0.0;          \/* total duration of test input *\/$/;"	v	file:
totalPr	HTKTools/HERest.c	/^static LogDouble totalPr=0;   \/* total log prob upto current utterance *\/$/;"	v	file:
totalPr	HTKTools/HSmooth.c	/^static LogDouble totalPr;    \/* total log prob of all training utterances *\/$/;"	v	file:
totalPr1	HTKTools/HMMIRest.c	/^static LogDouble totalPr1=0,totalPr2=0,totalPr3=0;              \/* total log prob upto current utterance, totalPr3 for MMI den in MPE with MMI Prior*\/$/;"	v	file:
totalPr2	HTKTools/HMMIRest.c	/^static LogDouble totalPr1=0,totalPr2=0,totalPr3=0;              \/* total log prob upto current utterance, totalPr3 for MMI den in MPE with MMI Prior*\/$/;"	v	file:
totalPr3	HTKTools/HMMIRest.c	/^static LogDouble totalPr1=0,totalPr2=0,totalPr3=0;              \/* total log prob upto current utterance, totalPr3 for MMI den in MPE with MMI Prior*\/$/;"	v	file:
totalProns	HTKTools/HDMan.c	/^   int totalProns;              \/* total prons in this source *\/$/;"	m	struct:__anon162	file:
totalT	HTKTools/HERest.c	/^static int totalT=0;       \/* total number of frames in training data *\/$/;"	v	file:
totalT	HTKTools/HMMIRest.c	/^static int totalT=0;                             \/* total number of frames in training data *\/$/;"	v	file:
totalT	HTKTools/HSmooth.c	/^static int totalT=0;         \/* total number of frames in training data *\/$/;"	v	file:
totalWords	HTKTools/HDMan.c	/^   int totalWords;              \/* total words in this source *\/$/;"	m	struct:__anon162	file:
totals	HLMLib/LModel.h	/^   int *totals;              \/* array of class counts (sum of word counts for each class) *\/$/;"	m	struct:__anon16
totl	HLMTools/LPlex.c	/^static PStats  totl;                \/* global accumulator *\/$/;"	v	file:
tpdf	HTKLib/HModel.h	/^   Vector tpdf;          \/* TIEDHS *\/$/;"	m	union:__anon58
tr	HTKLib/HFB.h	/^  Transcription *tr;  \/* current transcription *\/$/;"	m	struct:__anon136
tr	HTKTools/HCopy.c	/^static Transcription *tr;       \/* current transcription *\/$/;"	v	file:
trC	HTKLib/HTrain.c	/^static int muC,vaC,trC,wtC,prC;$/;"	v	file:
trList	HTKTools/HCopy.c	/^static TrL trList;              \/* 1st element in trace linked list *\/$/;"	v	file:
trNum	HTKLib/HLabel.c	/^static double trNum;$/;"	v	file:
trStr	HTKLib/HLabel.c	/^static char trStr[256];$/;"	v	file:
trStr	HTKTools/HCopy.c	/^static TrPtr trStr = &trList;   \/* ptr to it *\/$/;"	v	file:
trSym	HTKLib/HLabel.c	/^static TrSymbol trSym = TRNULL;$/;"	v	file:
trace	HLMLib/LCMap.c	/^static int trace = 0;$/;"	v	file:
trace	HLMLib/LGBase.c	/^static int trace = 0;$/;"	v	file:
trace	HLMLib/LModel.c	/^static int trace = 0;$/;"	v	file:
trace	HLMLib/LPCalc.c	/^static int trace = 0;$/;"	v	file:
trace	HLMLib/LPMerge.c	/^static int trace = 0;$/;"	v	file:
trace	HLMLib/LUtil.c	/^static int trace = 0;$/;"	v	file:
trace	HLMLib/LWMap.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/Cluster.c	/^static int          trace = 0;              \/* trace setting *\/$/;"	v	file:
trace	HLMTools/HLMCopy.c	/^static int       trace = 0;              \/* trace level *\/$/;"	v	file:
trace	HLMTools/LAdapt.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LBuild.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LFoF.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LGCopy.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LGList.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LGPrep.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LLink.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LMerge.c	/^static int trace = 0;                    \/* trace level *\/$/;"	v	file:
trace	HLMTools/LNewMap.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LNorm.c	/^static int       trace = 0;              \/* trace level *\/$/;"	v	file:
trace	HLMTools/LPlex.c	/^static int trace = 0;               \/* trace level *\/$/;"	v	file:
trace	HLMTools/LSubset.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HAdapt.c	/^static int trace = 0;                   \/* trace info *\/$/;"	v	file:
trace	HTKLib/HArc.c	/^static int trace=1;$/;"	v	file:
trace	HTKLib/HAudio.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HDict.c	/^static int trace=0;$/;"	v	file:
trace	HTKLib/HFB.c	/^static int trace         =  0;$/;"	v	file:
trace	HTKLib/HFBLat.c	/^static int trace     =  1;            \/* Trace level *\/$/;"	v	file:
trace	HTKLib/HGraf.c	/^static int trace = 0;                   \/* Just for consistency *\/$/;"	v	file:
trace	HTKLib/HGraf.null.c	/^static int trace = 0;                   \/* Just for consistency *\/$/;"	v	file:
trace	HTKLib/HGraf_WIN32.c	/^static int trace = 0;                   \/* Just for consistency *\/$/;"	v	file:
trace	HTKLib/HLM.c	/^static int trace=0;$/;"	v	file:
trace	HTKLib/HLabel.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HLat.c	/^static int trace=0;$/;"	v	file:
trace	HTKLib/HMap.c	/^static int trace     = 0;        \/* Trace level *\/$/;"	v	file:
trace	HTKLib/HMath.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HMem.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HModel.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HNLM.c	/^static int trace=0;$/;"	v	file:
trace	HTKLib/HNet.c	/^static int trace=0;$/;"	v	file:
trace	HTKLib/HParm.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HRNLM.c	/^static int trace=128;$/;"	v	file:
trace	HTKLib/HRec.c	/^static int trace=0;$/;"	v	file:
trace	HTKLib/HShell.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HSigP.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HTrain.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HUtil.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HVQ.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HWave.c	/^static int trace = 0;$/;"	v	file:
trace	HTKTools/HBuild.c	/^static int trace     = 0;           \/* Trace flags *\/$/;"	v	file:
trace	HTKTools/HCompV.c	/^static int  trace    = 0;           \/* trace level *\/$/;"	v	file:
trace	HTKTools/HCopy.c	/^static int  trace  = 0;         \/* Trace level *\/$/;"	v	file:
trace	HTKTools/HDMan.c	/^static int  trace    = 0;           \/* trace level *\/$/;"	v	file:
trace	HTKTools/HERest.c	/^static int trace     = 0;        \/* Trace level *\/$/;"	v	file:
trace	HTKTools/HHEd.c	/^static int  trace    = 0;        \/* current trace level *\/$/;"	v	file:
trace	HTKTools/HInit.c	/^static int trace = 0;               \/* Trace level *\/$/;"	v	file:
trace	HTKTools/HLEd.c	/^static int  trace    = 0;           \/* trace level *\/$/;"	v	file:
trace	HTKTools/HLRescore.c	/^static int trace = 0;$/;"	v	file:
trace	HTKTools/HLStats.c	/^static int trace = 0;               \/* trace level *\/$/;"	v	file:
trace	HTKTools/HList.c	/^static int trace = 0;$/;"	v	file:
trace	HTKTools/HMMIRest.c	/^static long int trace     = 1;        \/* Trace level *\/$/;"	v	file:
trace	HTKTools/HParse.c	/^static int trace     = 0;         \/* Trace flags *\/$/;"	v	file:
trace	HTKTools/HQuant.c	/^static int trace = 0;               \/* trace level *\/$/;"	v	file:
trace	HTKTools/HRest.c	/^static int  trace    = 0;        \/* Trace level *\/$/;"	v	file:
trace	HTKTools/HResults.c	/^static int trace = 0;               \/* trace level *\/$/;"	v	file:
trace	HTKTools/HSGen.c	/^static int trace = 0;$/;"	v	file:
trace	HTKTools/HSLab.c	/^static int trace = 0;                \/* trace level *\/$/;"	v	file:
trace	HTKTools/HSmooth.c	/^static int trace     = 0;        \/* Trace level *\/$/;"	v	file:
trace	HTKTools/HVite.c	/^static int trace = 0;$/;"	v	file:
traceBack	HTKTools/HInit.c	/^static short   **traceBack;      \/* array[1..segLen][2..numStates-1] *\/$/;"	v	file:
traceBackStack	HTKTools/HInit.c	/^static MemHeap traceBackStack;   \/* For storage of traceBack info *\/$/;"	v	file:
traceWidth	HTKTools/HCopy.c	/^static int traceWidth = 70;     \/* print this many chars before wrapping ln *\/$/;"	v	file:
train	HTKBook/htkbook-pdf.tex	/^\\include{models}$/;"	i
train	HTKBook/htkbook.tex	/^\\include{models}$/;"	i
train_cur_pos	HTKLib/HRNLM.h	/^    int train_cur_pos;$/;"	m	struct:_RNNLM
train_file	HTKLib/HRNLM.h	/^    char train_file[MAX_STRING];$/;"	m	struct:_RNNLM
train_file_set	HTKLib/HRNLM.h	/^    int alpha_set, train_file_set;$/;"	m	struct:_RNNLM
train_words	HTKLib/HRNLM.h	/^    int train_words;$/;"	m	struct:_RNNLM
traincritmode	HTKLib/HRNLM.h	/^    int traincritmode, nodetype;$/;"	m	struct:_RNNLM
tran	HTKLib/HTrain.h	/^   Matrix tran;      \/* array[1..N][1..N]of transition count *\/$/;"	m	struct:__anon111
trans	HTKTools/HCopy.c	/^static Transcription *trans=NULL;\/* main labels; cat all input to this *\/$/;"	v	file:
trans	HTKTools/HSLab.c	/^static Transcription *trans;    \/* the transcriptions *\/$/;"	v	file:
transAlt	HTKLib/HLabel.c	/^static int transAlt = 0;           \/* if >0 filter all but specified alt *\/$/;"	v	file:
transHeap	HTKTools/HLRescore.c	/^static MemHeap transHeap;$/;"	v	file:
transLev	HTKLib/HLabel.c	/^static int transLev = 0;           \/* if >0 filter all but specified level *\/$/;"	v	file:
transP	HTKLib/HModel.h	/^   SMatrix transP;         \/* transition matrix (logs) *\/$/;"	m	struct:__anon64
transStack	HTKLib/HFB.h	/^  MemHeap transStack; \/* utterance transcript information heap *\/$/;"	m	struct:__anon136
transStack	HTKTools/HInit.c	/^static MemHeap transStack;       \/* For storage of transcription *\/$/;"	v	file:
transStack	HTKTools/HMMIRest.c	/^static MemHeap transStack;         \/* Transcriptions... comment in original HERest says transformations, but it's wrong.*\/$/;"	v	file:
transStack	HTKTools/HRest.c	/^static MemHeap transStack;       \/* For storage of transcription *\/$/;"	v	file:
translm	HTKLib/HExactMPE.c	83;"	d	file:
translm	HTKLib/HFBLat.c	145;"	d	file:
tree	HTKLib/HVQ.h	/^   VQNode tree[SMAX];   \/* 1 tree per stream *\/$/;"	m	struct:_VQTabRec
treeList	HTKTools/HHEd.c	/^static Tree *treeList = NULL;   \/* list of trees *\/$/;"	v	file:
treeMerge	HTKTools/HHEd.c	/^static Boolean treeMerge = TRUE; \/* After tree spltting merge leaves *\/$/;"	v	file:
treeName	HTKTools/HHEd.c	/^static char treeName[256] = "";$/;"	v	file:
triSize	HTKTools/HHEd.c	/^static int triSize;        \/* num items in triTab *\/$/;"	v	file:
triStrip	HTKTools/HLEd.c	/^static Boolean triStrip = FALSE;    \/* ignore triphone contexts in matching *\/$/;"	v	file:
triTab	HTKTools/HHEd.c	/^static TriRec *triTab;     \/* array[0..triSize-1] of TriRec; *\/$/;"	v	file:
tscale	HTKLib/HNet.h	/^   float tscale;                \/* time scale factor (default: 1, i.e. seconds) *\/$/;"	m	struct:lattice
tt AU hmmList	HTKBook/HTKRef/HHEd.tex	/^with probability 0.1.$/;"	b
tt CL hmmList	HTKBook/HTKRef/HHEd.tex	/^using the decision tree.$/;"	b
tt CO newList	HTKBook/HTKRef/HHEd.tex	/^be retained by including them in the new \\texttt{hmmList}).$/;"	b
tt DP s n id ...	HTKBook/HTKRef/HHEd.tex	/^performing a sequence of parameter tying commands.$/;"	b
tt FA varscale	HTKBook/HTKRef/HHEd.tex	/^\\texttt{ax-b:f+d}.$/;"	b
tt FC	HTKBook/HTKRef/HHEd.tex	/^can be inhibited by setting \\texttt{APPLYVFLOOR} to \\texttt{FALSE}.$/;"	b
tt FV file	HTKBook/HTKRef/HHEd.tex	/^system. The tying structure of the original system is kept intact.$/;"	b
tt HK hsetkind	HTKBook/HTKRef/HHEd.tex	/^\\texttt{FALSE}.$/;"	b
tt JO size minw	HTKBook/HTKRef/HHEd.tex	/^most likely to be used when building tied-mixture systems (hsetkind=TIEDHS).$/;"	b
tt PR	HTKBook/HTKRef/HHEd.tex	/^tied cluster is called \\texttt{macroi}.$/;"	b
tt PS nstates power  numiters 	HTKBook/HTKRef/HHEd.tex	/^an input transform.$/;"	b
tt QS name itemList  h 	HTKBook/HTKRef/HHEd.tex	/^from zero.$/;"	b
tt RC N identifier  itemlist 	HTKBook/HTKRef/HHEd.tex	/^command below).$/;"	b
tt TB f macro itemList  s or h 	HTKBook/HTKRef/HHEd.tex	/^tyings which may be in force.$/;"	b
tt TC f macro itemList  s 	HTKBook/HTKRef/HHEd.tex	/^diagonal covariance untied models.$/;"	b
tt TI macro itemList	HTKBook/HTKRef/HHEd.tex	/^the value given by \\texttt{f}.$/;"	b
tt TR n	HTKBook/HTKRef/HHEd.tex	/^\\end{description}$/;"	b
tt UT itemList	HTKBook/HTKRef/HHEd.tex	/^A value of 0010 can be used to show current memory usage.$/;"	b
tt XF filename	HTKBook/HTKRef/HHEd.tex	/^actually shared [see the Tie (\\texttt{TI}) command above].$/;"	b
twoDataFiles	HTKLib/HFB.h	/^  Boolean twoDataFiles; \/* Using two data files *\/$/;"	m	struct:__anon136
twoDataFiles	HTKLib/HFBLat.h	/^  Boolean twoDataFiles;$/;"	m	struct:__anon54
twoDataFiles	HTKTools/HERest.c	/^static Boolean twoDataFiles = FALSE; \/* Enables creation of ot2 for FB$/;"	v	file:
twoDataFiles	HTKTools/HMMIRest.c	/^static Boolean twoDataFiles = FALSE; \/* For training using two data files, probably never needed & code not tested. *\/$/;"	v	file:
twoModels	HTKLib/HFB.h	/^  Boolean twoModels;  \/* Enable two model reestimation *\/$/;"	m	struct:__anon139
txtSrc	HLMTools/LAdapt.c	/^static char *txtSrc  = NULL;        \/* gram file text source descriptor *\/$/;"	v	file:
txtsrc	HLMLib/LGBase.h	/^   char txtsrc[MAXSTRLEN];  \/* text source description *\/$/;"	m	struct:__anon4
txtsrc	HLMTools/LGPrep.c	/^static char *txtsrc  = NULL;        \/* gram file text source descriptor *\/$/;"	v	file:
type	HTKLib/HLM.h	/^   LMType type;                 \/* LM type *\/$/;"	m	struct:lmodel
type	HTKLib/HLabel.h	/^   MLFDefType type;     \/* type of this definition *\/$/;"	m	struct:_MLFEntry
type	HTKLib/HMem.h	/^   HeapType type;       \/*              type of this heap                 *\/$/;"	m	struct:__anon73
type	HTKLib/HModel.h	/^   char type;              \/* type of macro [hluvixdtmps*] *\/$/;"	m	struct:_MacroDef
type	HTKLib/HNLM.h	/^    int32 type;$/;"	m	struct:matheader
type	HTKLib/HNet.h	/^   NetNodeType type;    \/* Type of this node (includes context) *\/$/;"	m	struct:_NetNode
type	HTKLib/HRNLM.h	/^    char type[20];$/;"	m	struct:_Layer
type	HTKLib/HVQ.h	/^   TreeType type;       \/* linear or binary *\/$/;"	m	struct:_VQTabRec
type	HTKLib/esignal.h	/^    short       type;           \/* data type code *\/$/;"	m	struct:Array
type	HTKLib/esignal.h	/^    short       type;           \/* data type code *\/$/;"	m	struct:FieldSpec
u4srt	HLMLib/LUtil.c	/^static void u4srt(int32 *data, int l, int r,$/;"	f	file:
uFlags	HTKLib/HFB.h	/^  UPDSet uFlags;      \/* parameter update flags *\/$/;"	m	struct:__anon139
uFlags	HTKLib/HFBLat.h	/^  UPDSet uFlags;$/;"	m	struct:__anon54
uFlags	HTKTools/HERest.c	/^static UPDSet uFlags = (UPDSet) (UPMEANS|UPVARS|UPTRANS|UPMIXES); \/* update flags *\/$/;"	v	file:
uFlags	HTKTools/HInit.c	/^static UPDSet uFlags = (UPDSet) (UPMEANS|UPVARS|UPMIXES|UPTRANS); \/* update flags *\/$/;"	v	file:
uFlags	HTKTools/HMMIRest.c	/^static UPDSet uFlags = UPMEANS|UPVARS|UPTRANS|UPMIXES;   \/* update flags *\/$/;"	v	file:
uFlags	HTKTools/HRest.c	/^static UPDSet uFlags = (UPDSet) (UPMEANS|UPVARS|UPTRANS|UPMIXES);     \/* update flags *\/$/;"	v	file:
uFlags	HTKTools/HSmooth.c	/^static UPDSet uFlags = (UPDSet) (UPMEANS|UPVARS|UPTRANS|UPMIXES);   \/* update flags *\/$/;"	v	file:
uFlagsAccs	HTKTools/HMMIRest.c	/^static UPDSet uFlagsAccs = UPMEANS|UPVARS|UPTRANS|UPMIXES;   \/* used in storing accs. *\/$/;"	v	file:
uFlagsMLE	HTKTools/HMMIRest.c	/^static UPDSet uFlagsMLE = 0; \/*which we only update with MLE, ignoring the MMI parameters.*\/$/;"	v	file:
ultraKey	HLMLib/LModel.c	/^static short   ultraKey[KEY_LENGTH];    \/* Key used to identify ultra LMs *\/$/;"	v	file:
undo	HTKTools/HSLab.c	/^static UndoRecord undo;                \/* the undo record variable *\/$/;"	v	file:
undoEmpty	HTKTools/HSLab.c	/^static Boolean undoEmpty;              \/* shows the status of the record *\/$/;"	v	file:
uni	HLMTools/Cluster.c	/^static unigram     *uni;                    \/* Unigram store *\/$/;"	v	file:
uniFloor	HLMLib/LPCalc.c	/^static float  uniFloor = 1.0;                 \/* unigram floor *\/$/;"	v	file:
uniFloor	HLMLib/LPCalc.h	/^   float        uniFloor;             \/* unigram floor *\/$/;"	m	struct:__anon2
uniFloor	HTKTools/HLStats.c	/^static float uniFloor   = 1.0;      \/* min count for unigram probs *\/$/;"	v	file:
uniFn	HLMTools/HLMCopy.c	/^static char      *uniFn = NULL;          \/* unigram file name *\/$/;"	v	file:
unigram	HLMTools/Cluster.c	/^typedef UInt unigram;   \/* Occurrence count *\/$/;"	t	file:
unigram_add	HLMTools/Cluster.c	/^void unigram_add(NGram ng, int count)$/;"	f
unigram_init	HLMTools/Cluster.c	/^void unigram_init(int words)$/;"	f
unigram_read	HLMTools/Cluster.c	/^UInt unigram_read(UInt id)$/;"	f
unigrams	HTKLib/HLM.h	/^   Vector unigrams;             \/* Unigram probabilities *\/$/;"	m	struct:ngramlm
uniqOOV	HLMTools/LPlex.c	/^   int uniqOOV;             \/* number of unique oov's *\/$/;"	m	struct:__anon33	file:
units	HTKLib/esignal.h	/^    char        *units;         \/* string giving physical units *\/$/;"	m	struct:FieldSpec
unkEquiv	HLMTools/LPlex.c	/^static int    unkEquiv = 0;         \/* number of equivalent words outside the word list *\/$/;"	v	file:
unkId	HLMTools/LAdapt.c	/^static LabId unkId = NULL;                   \/* OOV marker *\/$/;"	v	file:
unkId	HLMTools/LPlex.c	/^static LabId unkId = NULL;          \/* sentence end marker *\/$/;"	v	file:
unkStr	HLMLib/LCMap.c	/^static char  unkStr[256] = DEF_UNKNOWNNAME;  \/* name of (hdrless) unk class *\/$/;"	v	file:
unkStr	HLMTools/LAdapt.c	/^static char  unkStr[256] = DEF_UNKNOWNNAME;  \/* OOV class string *\/$/;"	v	file:
unk_id	HLMTools/Cluster.c	/^static int         unk_id=-1;               \/* Unknown word token id *\/$/;"	v	file:
unk_sep	HLMTools/Cluster.c	/^static Boolean     unk_sep = FALSE;         \/* Keep unknown word in its own class? *\/$/;"	v	file:
unkid	HLMLib/LCMap.c	/^static LabId unkid  = NULL;	             \/* name of (hdrless) unk class *\/$/;"	v	file:
unkndx	HLMLib/LCMap.c	/^static int  unkndx  = DEF_UNKNOWNID;         \/* ndx of (hdrless) unk class *\/$/;"	v	file:
unknown	HTKTools/HBuild.c	/^typedef enum {unknown, wordLoop, boBiGram, matBiGram, multiLat, wordPair} BuildType;$/;"	e	enum:__anon163	file:
unknown	HTKTools/HParse.c	/^typedef enum {unknown, wdInternal, wdExternal, wdBegin, wdEnd, nullNode} NodeType;$/;"	e	enum:__anon156	file:
unknownId	HTKTools/HBuild.c	/^static LabId unknownId;             \/* id of unknown label in ngram *\/$/;"	v	file:
unknown_w	HLMTools/Cluster.c	/^static char         unknown_w[256];         \/* unknown word token *\/$/;"	v	file:
unqPK	HTKLib/HParm.c	/^   ParmKind unqPK;    \/* Used to track conversion from srcPK to tgtPK *\/$/;"	m	struct:__anon76	file:
up_dataStack	HTKLib/HFBLat.h	/^  MemHeap up_dataStack;$/;"	m	struct:__anon54
up_hmmMMF	HTKTools/HERest.c	/^static char up_hmmMMF[MAXFNAMELEN];  \/* alignment hmm list *\/$/;"	v	file:
up_hset	HTKLib/HFB.h	/^  HMMSet *up_hset;    \/* set of HMMs to be re-estimated *\/$/;"	m	struct:__anon139
up_info	HTKLib/HFBLat.h	/^  BufferInfo up_info;             \/* info from buffer on second data file *\/$/;"	m	struct:__anon54
up_ot	HTKLib/HFBLat.h	/^  Observation up_ot;$/;"	m	struct:__anon54
up_pbuf	HTKLib/HFBLat.h	/^  ParmBuf up_pbuf;$/;"	m	struct:__anon54
up_qList	HTKLib/HFB.h	/^  HLink *up_qList;    \/* array[1..Q] of active HMM defs *\/$/;"	m	struct:__anon138
update	HTKTools/HVite.c	/^static int update = 0;            \/* Perfom MLLR & update every n utts *\/$/;"	v	file:
updateMode	HTKTools/HERest.c	/^static int updateMode = UPMODE_UPDATE; \/* dump summed accs, update models or do both? *\/$/;"	v	file:
updateMode	HTKTools/HMMIRest.c	/^static int updateMode = UPMODE_UPDATE; \/* dump summed accs, update models or do both? *\/$/;"	v	file:
usage	HTKLib/HNet.h	/^   int usage;               \/* Number of references to this SubLat *\/$/;"	m	struct:sublatdef
usage	HTKLib/HRec.c	/^   int usage;           \/* Times struct ref'd (by align or path) *\/$/;"	m	struct:align	file:
usage	HTKLib/HRec.h	/^   int usage;           \/* Times struct ref'd (by next path) *\/$/;"	m	struct:path
useBias	HTKLib/HAdapt.c	/^static Boolean useBias = TRUE;         \/* whether a bias is to be estimated for the xform *\/$/;"	v	file:
useBinSearch	HTKLib/HNLM.c	/^static Boolean useBinSearch = TRUE;$/;"	v	file:
useHam	HTKLib/HParm.c	/^   Boolean useHam;            \/* Use Hamming Window *\/$/;"	m	struct:__anon76	file:
useInXForm	HTKLib/HAdapt.h	/^  Boolean useInXForm;$/;"	m	struct:__anon37
useIntpltLM	HTKLib/HLM.c	/^static Boolean useIntpltLM = FALSE;     \/* Use interpolated LM *\/$/;"	v	file:
useLLF	HTKTools/HMMIRest.c	/^static Boolean useLLF = FALSE;          \/* use directory based LLF files instead of individual lattices *\/$/;"	v	file:
useLeafStats	HTKTools/HHEd.c	/^static Boolean useLeafStats = TRUE; \/* Use leaf stats to init macros *\/$/;"	v	file:
useMLF	HTKTools/HCopy.c	/^static Boolean useMLF=FALSE;    \/* set if we are saving to an mlf *\/$/;"	v	file:
useModelName	HTKTools/HHEd.c	/^static Boolean useModelName = TRUE;    \/* Use base-phone name as tree name *\/$/;"	v	file:
useOutXForm	HTKLib/HAdapt.h	/^  Boolean useOutXForm;$/;"	m	struct:__anon37
usePaXForm	HTKLib/HAdapt.h	/^  Boolean usePaXForm;$/;"	m	struct:__anon37
usePower	HTKLib/HParm.c	/^   Boolean usePower;          \/* Use power instead of Magnitude *\/$/;"	m	struct:__anon76	file:
usePower	HTKLib/HSigP.h	/^   Boolean usePower;    \/* use power rather than magnitude *\/$/;"	m	struct:__anon129
useSilDet	HTKLib/HParm.c	/^   Boolean useSilDet;         \/* Use Silence Detector *\/$/;"	m	struct:__anon76	file:
useSilDet	HTKLib/HParm.h	/^   Boolean useSilDet;         \/* Use Silence Detector *\/$/;"	m	struct:__anon122
use_lmprob	HTKLib/HRNLM.h	/^    int use_lmprob;$/;"	m	struct:_RNNLM
usecuedrnnlm	HTKLib/HRNLM.h	/^    Boolean   usecuedrnnlm;$/;"	m	struct:_RNNLM
usecuedsurnnlm	HTKLib/HRNLM.h	/^    Boolean   usecuedsurnnlm;$/;"	m	struct:_RNNLM
used	HLMLib/LGBase.h	/^   int used;               \/* number used slots in pool *\/$/;"	m	struct:__anon6
used	HLMLib/LWMap.h	/^   int     used;         \/* total words and classes in map *\/$/;"	m	struct:__anon20
used	HLMTools/LAdapt.c	/^   int used;            \/* actual words in register *\/$/;"	m	struct:__anon34	file:
used	HLMTools/LGPrep.c	/^   int used;                  \/* actual words in register *\/$/;"	m	struct:__anon29	file:
used	HTKLib/HAudio.c	/^   int used,size;        \/* used in data, size of data *\/$/;"	m	struct:__anon53	file:
used	HTKLib/HMem.h	/^   ByteP used;          \/* alloc map, 1 bit\/elem         not used         *\/$/;"	m	struct:_Block
used	HTKLib/HRec.c	/^   Boolean used;        \/* Reference to struct by current inst *\/$/;"	m	struct:align	file:
used	HTKLib/HRec.h	/^   Boolean used;        \/* Reference to struct by current inst *\/$/;"	m	struct:path
used	HTKLib/HTrain.h	/^   int used;         \/* num items in this block *\/$/;"	m	struct:_ItemBlock
usefrnnlm	HTKLib/HRNLM.h	/^    Boolean   usefrnnlm;            \/*  the structure of RNNLM is full connected ? (default: c-rnnlm)*\/$/;"	m	struct:_RNNLM
user	HTKLib/HLM.h	/^   void *user;                  \/* Accumulator or cache storage *\/$/;"	m	struct:nentry
user	HTKLib/HShell.h	/^   char *user;          \/* name of module\/tool to use this param *\/$/;"	m	struct:__anon87
user	HTKTools/HParse.c	/^   Ptr  user;       \/* for attaching user defined data *\/$/;"	m	struct:_Node	file:
user	HTKTools/HParse.c	/^   Ptr  user;       \/* for attaching user defined data *\/$/;"	m	struct:__anon154	file:
usort	HLMLib/LUtil.c	/^void usort(void *base, int n, size_t size,$/;"	f
usrt	HLMLib/LUtil.c	/^static void usrt(void *base, int l, int r, size_t size,$/;"	f	file:
utt	HTKTools/HVite.c	/^static UttInfo *utt;              \/* utterance info for state\/frame align *\/$/;"	v	file:
uttStack	HTKTools/HERest.c	/^static MemHeap uttStack;$/;"	v	file:
utterance	HTKLib/HNet.h	/^   char *utterance;		\/* Utterance file name (NULL==unknown) *\/$/;"	m	struct:lattice
v	HTKLib/HNet.h	/^   short v;            \/* Pronunciation variant number *\/$/;"	m	struct:lnode
v	HTKLib/HRNLM.h	/^    float *g, *v;$/;"	m	struct:_Layer
v1Compat	HTKLib/HParm.c	/^   Boolean v1Compat;          \/* V1 compatibility mode *\/$/;"	m	struct:__anon76	file:
v1Compat	HTKTools/HParse.c	/^static Boolean v1Compat=FALSE;        \/* compatability mode? *\/$/;"	v	file:
vCtr	HTKLib/HTrain.h	/^   Vector vCtr;    \/* cluster centre vector *\/$/;"	m	struct:__anon109
vDefunct	HTKTools/HRest.c	/^static float vDefunct=0.0;       \/* variance below which mixture defunct *\/$/;"	v	file:
vFloor	HTKLib/HMap.c	/^static Vector vFloor[SMAX]; \/* variance floor - default is all zero *\/$/;"	v	file:
vFloor	HTKLib/HModel.h	/^   SVector vFloor;      \/* enables flooring for multiple semi-tied transforms *\/$/;"	m	struct:__anon56
vFloor	HTKLib/HModel.h	/^  SVector vFloor;      \/* used for SEMIT variance flooring *\/$/;"	m	struct:__anon68
vFloor	HTKTools/HERest.c	/^static Vector vFloor[SMAX]; \/* variance floor - default is all zero *\/$/;"	v	file:
vFloor	HTKTools/HInit.c	/^static Vector vFloor[SMAX];         \/* variance floor - default is all zero *\/$/;"	v	file:
vFloor	HTKTools/HMMIRest.c	/^static Vector vFloor[SMAX];          \/* variance floor - default is all zero *\/$/;"	v	file:
vFloor	HTKTools/HRest.c	/^static Vector vFloor[SMAX];      \/* variance floor - default is all zero *\/$/;"	v	file:
vFloor	HTKTools/HSmooth.c	/^static Vector vFloor[SMAX];  \/* variance floor - default is all zero *\/$/;"	v	file:
vFloorScale	HTKTools/HCompV.c	/^static float vFloorScale = 0.0;     \/* if >0.0 then vFloor scaling *\/$/;"	v	file:
vInfoHd	HTKLib/HShell.c	/^static VersionEntry *vInfoHd = NULL;  \/* head of version info list *\/$/;"	v	file:
vInfoTl	HTKLib/HShell.c	/^static VersionEntry *vInfoTl = NULL;  \/* tail of version info list *\/$/;"	v	file:
vSize	HTKLib/HTrain.c	/^static int vSize;       \/* size of vectors *\/$/;"	v	file:
vSize	HTKTools/HCompV.c	/^static int vSize = 0;                    \/* target observation vector size *\/$/;"	v	file:
vSize	HTKTools/HMMIRest.c	/^static int vSize;                \/* input vector size *\/$/;"	v	file:
vSize	HTKTools/HSmooth.c	/^static int vSize;                \/* input vector size *\/$/;"	v	file:
vTmp	HTKLib/HTrain.c	/^static Vector vTmp;     \/* temp vector *\/$/;"	v	file:
v_peak	HTKLib/HAudio.c	/^   v_peak=1,$/;"	e	enum:__anon51	file:
v_rms	HTKLib/HAudio.c	/^   v_rms$/;"	e	enum:__anon51	file:
vaC	HTKLib/HTrain.c	/^static int muC,vaC,trC,wtC,prC;$/;"	v	file:
val	HTKLib/HShell.h	/^   ConfVal val;         \/* value *\/$/;"	m	struct:__anon87
valid	HTKLib/HModel.h	/^  Boolean valid;       \/* is it valid to generate a transform at the root node *\/$/;"	m	struct:RegTree
valid_file	HTKLib/HRNLM.h	/^    char valid_file[MAX_STRING];$/;"	m	struct:_RNNLM
value	HLMLib/LUtil.c	/^   char * value;$/;"	m	struct:hdrField	file:
var	HTKLib/HMath.h	/^   SVector var;         \/* if DIAGC or INVDIAGC *\/$/;"	m	union:__anon44
var	HTKLib/HRNLM.c	/^static Vector hists, mean, pmean, pvar, var;$/;"	v	file:
varFloorPercent	HTKTools/HERest.c	/^static float varFloorPercent = 0;$/;"	v	file:
varFloorPercent	HTKTools/HMMIRest.c	/^static float varFloorPercent = 0;$/;"	v	file:
varScale	HTKLib/HParm.c	/^   Vector varScale;   \/* var scaling vector  *\/$/;"	m	struct:__anon76	file:
varScale	HTKLib/HParm.c	/^static float varScale[100];$/;"	v	file:
varScaleDN	HTKLib/HParm.c	/^   char* varScaleDN ;         \/* dir to find variance estimate files *\/$/;"	m	struct:__anon76	file:
varScaleDim	HTKLib/HParm.c	/^static int varScaleDim=0;$/;"	v	file:
varScaleFN	HTKLib/HParm.c	/^   char *varScaleFN;          \/* var scale file name *\/          $/;"	m	struct:__anon76	file:
varScaleFN	HTKLib/HParm.c	/^static char varScaleFN[MAXFNAMELEN] = "\\0";$/;"	v	file:
varScaleMask	HTKLib/HParm.c	/^   char* varScaleMask;        \/* variance estimate file selection mask *\/$/;"	m	struct:__anon76	file:
varScalePathMask	HTKLib/HParm.c	/^   char* varScalePathMask;    \/* variance estimate file path selection mask *\/$/;"	m	struct:__anon76	file:
varScaleVector	HTKLib/HParm.c	/^   Vector varScaleVector; \/* vector loaded from varscale dir *\/$/;"	m	struct:__anon76	file:
varSmooth	HTKTools/HMMIRest.c	/^static float varSmooth = 0;$/;"	v	file:
vaxOrder	HTKLib/HShell.c	/^Boolean vaxOrder = FALSE;$/;"	v
vbnd	HTKTools/HLEd.c	/^static LabId vbnd[MAXIV];           \/* non-interwd bndaries set via NB cmd *\/$/;"	v	file:
vecSize	HTKLib/HModel.h	/^   short vecSize;          \/* dimension of observation vectors *\/$/;"	m	struct:_HMMSet
vecSize	HTKLib/HModel.h	/^  int vecSize;         \/* must be matched to a stream width! *\/$/;"	m	struct:__anon68
ver	HTKLib/HShell.c	/^   char *ver;$/;"	m	struct:_VersionEntry	file:
verbose	HLMTools/Cluster.c	/^static Boolean      verbose = FALSE;        \/* Verbose file logging *\/$/;"	v	file:
version	HTKLib/HRNLM.h	/^    int version;$/;"	m	struct:_RNNLM
version	HTKLib/HWave.c	/^   short version;$/;"	m	struct:__anon100	file:
version	HTKLib/HWave.c	/^   short version;$/;"	m	struct:__anon101	file:
voc	HLMTools/HLMCopy.c	/^static Vocab     *voc   = NULL;          \/* the defining word list *\/$/;"	v	file:
voc	HTKLib/HNet.h	/^   Vocab *voc;                  \/* Dictionary lattice based on *\/$/;"	m	struct:lattice
voc	HTKTools/HSGen.c	/^static Vocab   voc;     \/* associated vocab *\/$/;"	v	file:
vocSize	HLMLib/LModel.h	/^   int vocSize;              \/* vocabulary size *\/$/;"	m	struct:__anon16
vocSize	HTKLib/HLM.h	/^   int vocSize;                 \/* Core LM size *\/$/;"	m	struct:ngramlm
vocab	HLMTools/HLMCopy.c	/^static Vocab     vocab;                  \/* word list buffer *\/$/;"	v	file:
vocab	HTKLib/HNet.h	/^   Vocab *vocab;      \/* Dictionary from which words appear *\/$/;"	m	struct:__anon128
vocab	HTKLib/HNet.h	/^   char *vocab;			\/* Dictionary file name (NULL==unknown) *\/$/;"	m	struct:lattice
vocab	HTKLib/HRNLM.h	/^    struct vocab_word *vocab;       \/*  this records the OUTPUT vocab's word\/cn\/classid\/  *\/$/;"	m	struct:_RNNLM	typeref:struct:_RNNLM::vocab_word
vocab	HTKTools/HLEd.c	/^static Vocab vocab;                 \/* And the associated vocab *\/$/;"	v	file:
vocab	HTKTools/HLRescore.c	/^static Vocab vocab;		\/* wordlist or dictionary *\/$/;"	v	file:
vocab	HTKTools/HMMIRest.c	/^Vocab vocab;$/;"	v
vocab	HTKTools/HVite.c	/^static Vocab vocab;               \/* the dictionary *\/$/;"	v	file:
vocab_hash	HTKLib/HRNLM.h	/^    int *vocab_hash;$/;"	m	struct:_RNNLM
vocab_hash_size	HTKLib/HRNLM.h	/^    int vocab_hash_size;$/;"	m	struct:_RNNLM
vocab_max_size	HTKLib/HRNLM.h	/^    int vocab_max_size;$/;"	m	struct:_RNNLM
vocab_size	HTKLib/HRNLM.h	/^    int vocab_size;$/;"	m	struct:_RNNLM
vocab_word	HTKLib/HRNLM.h	/^struct vocab_word {$/;"	s
vol	HTKLib/HAudio.c	/^   float vol;                \/* current volume *\/$/;"	m	struct:_AudioOut	file:
volStr	HTKTools/HSLab.c	/^static char volStr[10];      \/* the string displayed in the volume button *\/$/;"	v	file:
volType	HTKLib/HAudio.c	/^static VolType volType = v_peak;$/;"	v	file:
vol_btn	HTKTools/HSLab.c	/^static HButton *vol_btn;     \/* pointer to the volume button *\/$/;"	v	file:
vq	HTKLib/HParm.h	/^   short vq[SMAX];       \/* array[1..swidth[0]] of VQ index *\/$/;"	m	struct:__anon120
vqHeap	HTKLib/HVQ.c	/^static MemHeap vqHeap;     \/* MSTAK for allocating VQTables *\/$/;"	v	file:
vqList	HTKLib/HVQ.c	/^static VQTable vqList = NULL;$/;"	v	file:
vqSegs	HTKLib/HTrain.h	/^   Sequence vqSegs;     \/* each seg is a sequence of vq[SMAX] *\/$/;"	m	struct:_SegStoreRec
vqTab	HTKLib/HParm.c	/^   VQTable vqTab;             \/* VQ table *\/$/;"	m	struct:__anon76	file:
vqTabFN	HTKLib/HParm.c	/^   char *vqTabFN;             \/* Name of VQ Table Defn File *\/$/;"	m	struct:__anon76	file:
vqTabFN	HTKLib/HParm.h	/^   char *vqTabFN;             \/* Name of VQ Table Defn File *\/$/;"	m	struct:__anon122
vqfn	HTKTools/HQuant.c	/^static char *vqfn = NULL;           \/* filename for output VQ table *\/$/;"	v	file:
vqidx	HTKLib/HVQ.h	/^   short vqidx;         \/* vq index of this node *\/$/;"	m	struct:_VQNodeRec
vrecinfo	HTKLib/HRec.h	/^struct vrecinfo$/;"	s
vri	HTKTools/HVite.c	/^static VRecInfo *vri;             \/* Visible HRec Info *\/$/;"	v	file:
vsize	HTKLib/HModel.h	/^  int vsize;                \/* vector size associated with the baseclasses of this node *\/$/;"	m	struct:_RegNode
w	HTKLib/HGraf.h	/^   int x, y, w, h;            \/* size of button rectangle *\/$/;"	m	struct:_HButton
w	HTKLib/HParm.c	/^      Wave w;           \/* the waveform file *\/$/;"	m	union:_ParmBuf::__anon78	file:
w	HTKLib/HParm.h	/^   Wave w;                    \/* the wave input - if any *\/$/;"	m	struct:__anon122
w	HTKTools/HSLab.c	/^   int x, y, w, h, bw;    \/* x-pos, y-pos, width, height, fg and bg colours *\/$/;"	m	struct:__anon148	file:
wList	HLMLib/LPMerge.c	/^   WordMap *wList;           \/* the target word list *\/$/;"	m	struct:__anon1	file:
wList	HLMTools/LMerge.c	/^static WordMap   wList;                  \/* the word list *\/$/;"	v	file:
wList	HLMTools/LPlex.c	/^static WordMap wList;               \/* the word list *\/$/;"	v	file:
wList	HTKTools/HDMan.c	/^static LabId *wList = NULL;          \/* filter word list *\/$/;"	v	file:
wListFN	HTKTools/HDMan.c	/^static char *wListFN = NULL;         \/* name of word list file *\/$/;"	v	file:
wSpot	HTKTools/HResults.c	/^static Boolean wSpot      = FALSE;    \/* true if word spotting *\/$/;"	v	file:
waitForSigH	HTKLib/HAudio.c	/^static volatile Boolean waitForSigH;$/;"	v	file:
warpFreq	HTKLib/HParm.c	/^   float warpFreq;            \/* Warp freq axis for vocal tract normalisation *\/$/;"	m	struct:__anon76	file:
warpLowerCutOff	HTKLib/HParm.c	/^   float warpLowerCutOff;     \/* lower and upper threshold frequencies *\/$/;"	m	struct:__anon76	file:
warpUpperCutOff	HTKLib/HParm.c	/^   float warpUpperCutOff;     \/*   for linear frequency warping *\/  $/;"	m	struct:__anon76	file:
wasNewline	HTKLib/HShell.h	/^   Boolean wasNewline;  \/* true if SkipWhiteSpace went over newline *\/$/;"	m	struct:__anon84
wasQuoted	HTKLib/HShell.c	/^static Boolean wasQuoted;     \/* true if next arg was quoted *\/$/;"	v	file:
wasQuoted	HTKLib/HShell.h	/^   Boolean wasQuoted;   \/* true if ReadString returned quoted string *\/$/;"	m	struct:__anon84
wavStack	HTKTools/HSLab.c	/^static MemHeap wavStack;     \/* storage for waveforms *\/$/;"	v	file:
wave	HTKTools/HSLab.c	/^static Wave wave;            \/* the input waveform *\/$/;"	v	file:
waveData	HTKLib/HAudio.c	/^   LPSTR waveData;        \/* Data in buffer *\/$/;"	m	struct:mmapibuf	file:
waveFmt	HTKLib/HAudio.c	/^   LPPCMWAVEFORMAT waveFmt; \/* Pointer to PCMWAVEFORMAT *\/$/;"	m	struct:_AudioIn	file:
waveFmt	HTKLib/HAudio.c	/^   LPPCMWAVEFORMAT waveFmt; \/* Pointer to PCMWAVEFORMAT *\/$/;"	m	struct:_AudioOut	file:
waveHdr	HTKLib/HAudio.c	/^   LPWAVEHDR waveHdr;     \/* Pointer to WAVEHDR *\/$/;"	m	struct:mmapibuf	file:
waveIn	HTKLib/HAudio.c	/^   HWAVEIN waveIn;$/;"	m	struct:_AudioIn	file:
waveOut	HTKLib/HAudio.c	/^   HWAVEOUT waveOut;$/;"	m	struct:_AudioOut	file:
waveOutDev	HTKLib/HAudio.c	/^   UINT waveOutDev;         \/* Device being used for wave output *\/$/;"	m	struct:_AudioOut	file:
wavePos	HTKLib/HAudio.c	/^   LPMMTIME wavePos;        \/* Pointer to MMTIME *\/$/;"	m	struct:_AudioIn	file:
wavePos	HTKLib/HAudio.c	/^   LPMMTIME wavePos;        \/* Pointer to MMTIME *\/$/;"	m	struct:_AudioOut	file:
wavePtrOn	HTKTools/HSLab.c	/^static Boolean wavePtrOn = FALSE;   \/* keeps track of the state of the waveform pointer *\/$/;"	v	file:
waveWin	HTKTools/HSLab.c	/^static RectWin waveWin;      \/* the waveform window *\/$/;"	v	file:
wbar	HTKTools/HSmooth.c	/^static Vector *wbar;         \/* array[0..nBlk]of weight vector *\/$/;"	v	file:
wbnd	HTKTools/HLEd.c	/^static LabId wbnd[MAXIW];           \/* interword bndaries set via WB cmd *\/$/;"	v	file:
wbuf	HTKTools/HDMan.c	/^   WordBuf wbuf;                \/* current input word *\/$/;"	m	struct:__anon162	file:
wcd	HTKTools/HSmooth.c	/^static Vector *wcd;          \/* array[0..nBlk]of weight vector *\/$/;"	v	file:
wd	HTKTools/HBuild.c	/^   Word wd;$/;"	m	struct:_GramEntry	file:
wd	HTKTools/HBuild.c	/^   Word wd;$/;"	m	struct:_WordFllr	file:
wdBegin	HTKTools/HParse.c	/^typedef enum {unknown, wdInternal, wdExternal, wdBegin, wdEnd, nullNode} NodeType;$/;"	e	enum:__anon156	file:
wdBeginId	HTKTools/HParse.c	/^static LabId wdBeginId;               \/* LabId of WD_BEGIN nodes  *\/$/;"	v	file:
wdBnd	HTKTools/HDMan.c	/^static LabId wdBnd;                  \/* LabId of word boundary symbol  *\/   $/;"	v	file:
wdBndSym	HTKTools/HDMan.c	/^static char wdBndSym[10] = "#";      \/* word boundary symbol *\/$/;"	v	file:
wdEnd	HTKTools/HParse.c	/^typedef enum {unknown, wdInternal, wdExternal, wdBegin, wdEnd, nullNode} NodeType;$/;"	e	enum:__anon156	file:
wdEndId	HTKTools/HParse.c	/^static LabId wdEndId;                 \/* LabId of WD_END nodes  *\/$/;"	v	file:
wdExternal	HTKTools/HParse.c	/^typedef enum {unknown, wdInternal, wdExternal, wdBegin, wdEnd, nullNode} NodeType;$/;"	e	enum:__anon156	file:
wdInternal	HTKTools/HParse.c	/^typedef enum {unknown, wdInternal, wdExternal, wdBegin, wdEnd, nullNode} NodeType;$/;"	e	enum:__anon156	file:
wdNet	HTKTools/HVite.c	/^static Lattice *wdNet;            \/* the word level recognition network *\/$/;"	v	file:
wdNetFn	HTKTools/HVite.c	/^static char *wdNetFn = NULL;      \/* Word level lattice *\/$/;"	v	file:
wdThresh	HLMLib/LModel.h	/^   float wdThresh;          \/* Threshold for wd pruning *\/$/;"	m	struct:__anon13
wdThresh	HLMLib/LPCalc.h	/^   int          wdThresh[LM_NSIZE+1]; \/* n-gram wd threshold array *\/$/;"	m	struct:__anon2
wdThresh	HLMTools/LNorm.c	/^static float wdThresh[LM_NSIZE+1];  \/* new wdThresh for COUNT-models *\/$/;"	v	file:
wdThresh	HLMTools/LPlex.c	/^static float wdThresh[LM_NSIZE+1];  \/* new wdThresh for COUNT-models *\/$/;"	v	file:
wd_cmp	HTKTools/HLStats.c	/^static int wd_cmp(const void *v1,const void *v2)$/;"	f	file:
wdid	HLMTools/LGPrep.c	/^   LabId wdid;                \/* word literal *\/$/;"	m	union:__anon25	file:
wdid	HLMTools/LPlex.c	/^   LabId wdid;$/;"	m	struct:__anon32	file:
wdlist	HTKLib/HLM.h	/^   LabId *wdlist;               \/* Lookup table for words from lmId *\/$/;"	m	struct:__anon124
wdlist	HTKLib/HLM.h	/^   LabId *wdlist;               \/* Lookup table for words from lmId *\/$/;"	m	struct:matbilm
wdlist	HTKLib/HLM.h	/^   LabId *wdlist;               \/* Lookup table for words from lmId *\/$/;"	m	struct:mlplm
wdlist	HTKLib/HLM.h	/^   LabId *wdlist;               \/* Lookup table for words from lmId *\/$/;"	m	struct:ngramlm
wdlk	HTKLib/HRec.c	/^   LogFloat wdlk;       \/* Max likelihood of t=0 path to word end node *\/$/;"	m	struct:_NetInst	file:
wdpenalty	HTKLib/HNet.h	/^   LogFloat wdpenalty;		\/* Word insertion penalty *\/$/;"	m	struct:lattice
weight	HLMLib/LGBase.h	/^   float weight;           \/* weight for subsequent mixing *\/$/;"	m	struct:gramfile
weight	HLMLib/LPMerge.h	/^   float weight;            \/* interpolation weight *\/$/;"	m	struct:__anon17
weight	HTKLib/HLM.h	/^   Vector weight;               \/* Interpolation weight *\/$/;"	m	struct:intpltlm
weight	HTKLib/HModel.h	/^   float weight;        \/* mixture weight *\/$/;"	m	struct:__anon57
weight	HTKLib/HNLM.h	/^   MLPWeightFile weight;	\/* MLP weight parameters *\/$/;"	m	struct:nnlm
weight	HTKLib/HRNLM.h	/^    real weight;	\/*weight of synapse *\/$/;"	m	struct:synapse
weight_fp	HTKLib/HNLM.c	/^static FILE *weight_fp;$/;"	v	file:
weights	HTKLib/HModel.h	/^   SVector weights;     \/* vector of stream weights *\/$/;"	m	struct:__anon62
weights12	HTKLib/HNLM.h	/^    float *weights12;$/;"	m	struct:mlpweightfile
weights23	HTKLib/HNLM.h	/^    float *weights23;$/;"	m	struct:mlpweightfile
weights34	HTKLib/HNLM.h	/^    float *weights34;$/;"	m	struct:mlpweightfile
weights45	HTKLib/HNLM.h	/^    float *weights45;$/;"	m	struct:mlpweightfile
wfmt	HTKTools/HSLab.c	/^static FileFormat wfmt=UNDEFF;      \/* wave file format *\/$/;"	v	file:
wgt	HTKLib/HModel.h	/^   Matrix wgt;          \/* for interpolated transforms *\/$/;"	m	union:__anon67
wgtLatGram	HTKLib/HLat.c	/^static float wgtLatGram = 0.5;        \/* interpolation weight of lattice LM *\/$/;"	v	file:
what_is_word	HLMTools/Cluster.c	/^char *what_is_word(UInt id)$/;"	f
white	HTKLib/HGraf.c	/^static unsigned long black, white;$/;"	v	file:
wid	HLMTools/LGList.c	/^   LabId wid;$/;"	m	struct:fitem	file:
width	HTKLib/esignal.h	/^    int     width;$/;"	m	struct:Annot
widthSet	HTKTools/HQuant.c	/^Boolean widthSet = FALSE;          \/* true if width of any stream is set *\/$/;"	v
widx	HTKTools/HDMan.c	/^static int widx = 0;                 \/* next word to take from wordList *\/$/;"	v	file:
winCreated	HTKLib/HGraf.c	/^static Boolean       winCreated = FALSE;$/;"	v	file:
winCreated	HTKLib/HGraf_WIN32.c	/^static Boolean winCreated    = FALSE;               \/* prevent duplicate windows *\/$/;"	v	file:
winDur	HTKLib/HParm.c	/^   HTime winDur;              \/* Source window duration *\/$/;"	m	struct:__anon76	file:
winPoints	HTKLib/HGraf_WIN32.c	/^static POINT winPoints[MAX_POINT];$/;"	v	file:
wlist	HLMTools/HLMCopy.c	/^static WordMap   wlist;                  \/* word list *\/$/;"	v	file:
wlist	HLMTools/LAdapt.c	/^static WordMap   wlist;             \/* restricting the word list *\/$/;"	v	file:
wlist	HLMTools/LNorm.c	/^static WordMap   wlist;                  \/* word list *\/$/;"	v	file:
wlistFN	HLMTools/HLMCopy.c	/^static char      *wlistFN = NULL;        \/* word list file name *\/$/;"	v	file:
wlistFN	HLMTools/LAdapt.c	/^static char *wlistFN = NULL;        \/* file containing edit rules *\/$/;"	v	file:
wlistFN	HLMTools/LNorm.c	/^static char      *wlistFN = NULL;        \/* word list file name *\/$/;"	v	file:
wlistFN	HLMTools/LPlex.c	/^static char   *wlistFN = NULL;$/;"	v	file:
wlt	HLMLib/LWMap.h	/^   LookupTable *wlt;     \/* word lookup table *\/$/;"	m	struct:__anon20
wm	HLMLib/LGBase.h	/^   WordMap *wm;             \/* word map to be used with this source *\/$/;"	m	struct:__anon4
wm	HLMLib/LGBase.h	/^   WordMap *wm;            \/* covering word map *\/$/;"	m	struct:__anon5
wm	HLMLib/LGBase.h	/^   WordMap *wm;            \/* word map for ngrams *\/$/;"	m	struct:__anon6
wmap	HLMLib/LCMap.h	/^   WordMap *wmap;	     	\/* associated word map *\/$/;"	m	struct:__anon21
wmap	HLMLib/LPCalc.h	/^   WordMap      *wmap;                \/* word map *\/$/;"	m	struct:__anon2
wmap	HLMTools/Cluster.c	/^static WordMap      wmap;                   \/* HTK word map *\/$/;"	v	file:
wmap	HLMTools/LAdapt.c	/^static WordMap    wmap;              \/* word map for this corpus *\/$/;"	v	file:
wmap	HLMTools/LBuild.c	/^static WordMap    wmap;$/;"	v	file:
wmap	HLMTools/LFoF.c	/^static WordMap    wmap;             \/* word map for this corpus *\/$/;"	v	file:
wmap	HLMTools/LGCopy.c	/^static WordMap    wmap;             \/* word map for this corpus *\/$/;"	v	file:
wmap	HLMTools/LGList.c	/^static  WordMap wmap;            \/* and the word map *\/$/;"	v	file:
wmap	HLMTools/LGPrep.c	/^static WordMap wmap;                \/* word map for this corpus *\/$/;"	v	file:
wmap	HLMTools/LSubset.c	/^static WordMap  wmap;            \/* the word map *\/$/;"	v	file:
wmapFN	HLMTools/LBuild.c	/^static char *wmapFN  = "wmap";      \/* output word map file name *\/$/;"	v	file:
wnHashTab	HTKLib/HNet.c	/^static NetNode *wnHashTab[WNHASHSIZE];$/;"	v	file:
wop	HTKTools/HDMan.c	/^   EdOp wop;                    \/* Used to apply UCWORD\/LCWORD before sorting inputs *\/$/;"	m	struct:__anon162	file:
word	HLMLib/LModel.h	/^   int *word;                \/* array of word counts *\/$/;"	m	struct:__anon16
word	HTKLib/HArc.h	/^  LabId word; $/;"	m	struct:_Arc
word	HTKLib/HDict.h	/^   Word word;      \/* Word this is a pronuciation of *\/$/;"	m	struct:_WordPron
word	HTKLib/HLM.h	/^   lmId word;                   \/* word id *\/$/;"	m	struct:sentry
word	HTKLib/HLM.h	/^   lmId word[NSIZE-1];          \/* Word history representing this entry *\/$/;"	m	struct:nentry
word	HTKLib/HNet.h	/^   Word word;          \/* Word represented by arc (labels may be on nodes) *\/$/;"	m	struct:lnode
word	HTKLib/HRNLM.h	/^    char word[MAX_STRING];$/;"	m	struct:vocab_word
word	HTKTools/HDMan.c	/^   LabId word;                  \/* a word + its pronunciations *\/$/;"	m	struct:__anon161	file:
word	HTKTools/HLStats.c	/^   unsigned short word[ASIZE];   \/* Bigram id *\/$/;"	m	struct:aentry	file:
word2class	HTKLib/HRNLM.h	/^    int *layersizes, *classinfo, *word2class;$/;"	m	struct:_RNNLM
wordBeam	HTKLib/HRec.h	/^   LogFloat wordBeam;       \/* Separte word end beam width *\/$/;"	m	struct:vrecinfo
wordBeam	HTKTools/HVite.c	/^static LogDouble wordBeam = -LZERO;\/* word-end pruning threshold *\/$/;"	v	file:
wordHeap	HTKLib/HDict.h	/^   MemHeap wordHeap;    \/* for DictEntry structs  *\/$/;"	m	struct:__anon74
wordLoop	HTKTools/HBuild.c	/^typedef enum {unknown, wordLoop, boBiGram, matBiGram, multiLat, wordPair} BuildType;$/;"	e	enum:__anon163	file:
wordMaxNode	HTKLib/HRec.c	/^   NetNode *wordMaxNode;    \/* Most likely word end node in network *\/$/;"	m	struct:precinfo	file:
wordMaxNode	HTKLib/HRec.h	/^   NetNode *wordMaxNode;    \/* Most likely word end node in network *\/$/;"	m	struct:vrecinfo
wordMaxTok	HTKLib/HRec.c	/^   Token wordMaxTok;        \/* Most likely word end token *\/$/;"	m	struct:precinfo	file:
wordMaxTok	HTKLib/HRec.h	/^   Token wordMaxTok;        \/* Most likely word end token *\/$/;"	m	struct:vrecinfo
wordName	HTKLib/HDict.h	/^   LabId wordName;  \/* word identifier *\/$/;"	m	struct:_DictEntry
wordNum	HTKTools/HBuild.c	/^   int wordNum;$/;"	m	struct:_GramEntry	file:
wordPair	HTKTools/HBuild.c	/^typedef enum {unknown, wordLoop, boBiGram, matBiGram, multiLat, wordPair} BuildType;$/;"	e	enum:__anon163	file:
wordPen	HTKTools/HLRescore.c	/^static LogDouble wordPen = 0.0; \/* inter word log penalty *\/$/;"	v	file:
wordPen	HTKTools/HVite.c	/^static LogDouble wordPen = 0.0;   \/* inter model propagation log prob *\/$/;"	v	file:
wordThresh	HTKLib/HRec.c	/^   LogFloat wordThresh;     \/* Cutoff for word end propagation *\/$/;"	m	struct:precinfo	file:
wordinfo	HTKTools/HLStats.c	/^typedef struct wordinfo{         \/* Label Occurrence Counters *\/$/;"	s	file:
wordnum	HLMTools/LGPrep.c	/^static int wordnum = 0;$/;"	v	file:
wordpen	HTKLib/HRec.c	/^   LogFloat wordpen;        \/* Word insertion penalty *\/$/;"	m	struct:precinfo	file:
wordsUsed	HTKTools/HDMan.c	/^   int wordsUsed;               \/* num words actually used *\/$/;"	m	struct:__anon162	file:
wpNet	HTKTools/HLRescore.c	/^static Lattice *wpNet;          \/* the word level recognition network *\/$/;"	v	file:
wpNetFile	HTKTools/HLRescore.c	/^static char *wpNetFile = NULL;  \/* word pair LM network filename *\/$/;"	v	file:
wptr	HLMLib/LUtil.h	/^   struct _NameHolder *wptr;   \/* equivalence class *\/$/;"	m	struct:_NameHolder	typeref:struct:_NameHolder::_NameHolder
writeLat	HTKTools/HLRescore.c	/^static Boolean writeLat = FALSE;    \/* -w *\/$/;"	v	file:
write_logfile	HLMTools/Cluster.c	/^static Boolean      write_logfile = TRUE;   \/* Write a log file during execution *\/$/;"	v	file:
write_word_counts	HLMTools/Cluster.c	/^void write_word_counts(char *filename)$/;"	f
write_word_probs	HLMTools/Cluster.c	/^void write_word_probs(char *filename)$/;"	f
wsStack	HTKTools/HSmooth.c	/^static MemHeap wsStack;$/;"	v	file:
wsi	HTKLib/HLM.h	/^   void *wsi;                   \/* LM weight set *\/$/;"	m	struct:intpltlm
wtAccStack	HTKTools/HSmooth.c	/^static MemHeap wtAccStack;$/;"	v	file:
wtC	HTKLib/HTrain.c	/^static int muC,vaC,trC,wtC,prC;$/;"	v	file:
wtStore	HTKTools/HSmooth.c	/^static WALink ***wtStore;  \/* array [1..nPhyHmms][2..nStates-1][1..nStreams]$/;"	v	file:
wtab	HTKLib/HDict.h	/^   Word *wtab;          \/* hash table for DictEntry's *\/$/;"	m	struct:__anon74
wv	HTKTools/HCopy.c	/^static Wave wv;                 \/* main waveform; cat all input to this *\/$/;"	v	file:
x	HTKLib/HGraf.h	/^   int x, y, w, h;            \/* size of button rectangle *\/$/;"	m	struct:_HButton
x	HTKLib/HGraf.h	/^   int x,y;          \/* position of mouse *\/$/;"	m	struct:__anon96
x	HTKLib/HGraf.h	/^  short x, y;$/;"	m	struct:__anon97
x	HTKLib/HRNLM.h	/^    MemHeap* x;$/;"	m	struct:_RNNLM
x	HTKLib/HSigP.h	/^   Vector x;            \/* array[1..fftN] of fftchans *\/$/;"	m	struct:__anon129
x	HTKLib/HTrain.h	/^   MemHeap *x;     \/* memheap holding this set *\/$/;"	m	struct:__anon110
x	HTKTools/HSLab.c	/^   int x, y, w, h, bw;    \/* x-pos, y-pos, width, height, fg and bg colours *\/$/;"	m	struct:__anon148	file:
x	HTKTools/HSLab.c	/^   int x, y;$/;"	m	struct:__anon149	file:
xInfo	HTKLib/HParm.c	/^   Ptr xInfo;         \/* Application data *\/$/;"	m	struct:hparmsrcdef	file:
xKind	HTKLib/HAdapt.c	/^static XFormKind xKind     = MLLRMEAN;  \/* Transform Kind to be created *\/$/;"	v	file:
xMargin	HTKTools/HCopy.c	/^static HTime xMargin=0.0;       \/* margin to include around extracted labs *\/$/;"	v	file:
xc	HTKLib/HNet.h	/^   int xc;         \/* Number of cross word contexts *\/$/;"	m	struct:hmmsetcxtinfo
xf	HTKLib/HModel.h	/^   InputXForm *xf;         \/* Input transform of HMMSet *\/$/;"	m	struct:_HMMSet
xfInfo	HTKTools/HERest.c	/^static XFInfo xfInfo;$/;"	v	file:
xfInfo	HTKTools/HMMIRest.c	/^static XFInfo xfInfo;$/;"	v	file:
xfInfo	HTKTools/HVite.c	/^static XFInfo xfInfo;$/;"	v	file:
xform	HTKLib/HMath.h	/^   SMatrix xform;       \/* if XFORMC *\/$/;"	m	union:__anon44
xform	HTKLib/HModel.h	/^  LinXForm *xform;     \/* actual transform to be applied *\/$/;"	m	struct:__anon70
xform	HTKLib/HModel.h	/^  SMatrix* xform;      \/* 1..numBlocks matrix transforms *\/$/;"	m	struct:__anon68
xform	HTKLib/HParm.c	/^   InputXForm *xform;$/;"	m	struct:__anon76	file:
xform	HTKLib/HParm.h	/^   Ptr xform;                 \/* Used for input xform associated with this buffer *\/$/;"	m	struct:__anon122
xformAdaptKind	HTKLib/HAdapt.c	/^static AdaptKind xformAdaptKind = BASE;$/;"	v	file:
xformBaseClass	HTKLib/HAdapt.c	/^static char *xformBaseClass = NULL;$/;"	v	file:
xformBlockSize	HTKLib/HAdapt.c	/^static IntVec xformBlockSize = NULL;$/;"	v	file:
xformDirNames	HTKLib/HModel.c	/^static XFDirLink xformDirNames = NULL;  \/* linked list of input transform directories *\/$/;"	v	file:
xformName	HTKLib/HModel.h	/^  char* xformName;                  \/* name of the transform (macroname) *\/$/;"	m	struct:_AdaptXForm
xformName	HTKLib/HModel.h	/^  char* xformName;     \/* name of the transform (macroname) *\/$/;"	m	struct:__anon70
xformRegTree	HTKLib/HAdapt.c	/^static char *xformRegTree = NULL;$/;"	v	file:
xformSet	HTKLib/HModel.h	/^  XFormSet  *xformSet;              \/* set of linear transforms *\/$/;"	m	struct:_AdaptXForm
xformSplitThresh	HTKLib/HAdapt.c	/^static float xformSplitThresh = -1000.0;$/;"	v	file:
xformStack	HTKLib/HModel.c	/^static MemHeap xformStack;              \/* For Storage of xforms with no model sets ... *\/$/;"	v	file:
xformTMF	HTKLib/HAdapt.h	/^  char *xformTMF;$/;"	m	struct:__anon37
xformWgts	HTKLib/HModel.h	/^  AdaptWgt  xformWgts;              \/* set of weights for all the base classes *\/$/;"	m	struct:_AdaptXForm
xforms	HTKLib/HModel.h	/^  LinXForm **xforms;   \/* 1..numTrans linear transforms *\/$/;"	m	struct:__anon69
xkind	HTKLib/HAdapt.c	/^   XFormKind xkind;$/;"	m	struct:__anon92	file:
xkind	HTKLib/HModel.h	/^  XFormKind xkind;     \/* transform kind (MLLRMEAN, CMLLR etc *\/$/;"	m	struct:__anon69
xlist	HTKTools/HLEd.c	/^static Context *xlist = NULL;$/;"	v	file:
y	HTKLib/HGraf.h	/^   int x, y, w, h;            \/* size of button rectangle *\/$/;"	m	struct:_HButton
y	HTKLib/HGraf.h	/^   int x,y;          \/* position of mouse *\/$/;"	m	struct:__anon96
y	HTKLib/HGraf.h	/^  short x, y;$/;"	m	struct:__anon97
y	HTKTools/HSLab.c	/^   int x, y, w, h, bw;    \/* x-pos, y-pos, width, height, fg and bg colours *\/$/;"	m	struct:__anon148	file:
y	HTKTools/HSLab.c	/^   int x, y;$/;"	m	struct:__anon149	file:
yes	HTKTools/HHEd.c	/^   struct _Node *yes;           \/* yes subtree *\/$/;"	m	struct:_Node	typeref:struct:_Node::_Node	file:
yes	HTKTools/HHEd.c	/^static AccSum yes,no;           \/* global accs for yes - no branches *\/$/;"	v	file:
z	HTKLib/HRNLM.h	/^    float *r, *z, *c, *h_;$/;"	m	struct:_Layer
zMeanSrc	HTKLib/HParm.c	/^   Boolean zMeanSrc;          \/* Zero Mean the Source *\/$/;"	m	struct:__anon76	file:
zapUnknown	HTKTools/HBuild.c	/^static Boolean zapUnknown = FALSE;  \/* zap unknown symbols from bigram *\/$/;"	v	file:
zero_buf	HTKLib/HAudio.c	/^static short zero_buf[BUF_SIZE];$/;"	v	file:
zi	HTKLib/HRNLM.h	/^    float *i, *f, *newc, *zi, *fc, *o;  \/* *c *z from GRU layer defination *\/$/;"	m	struct:_Layer
zoomLev	HTKTools/HSLab.c	/^static int zoomLev;                    \/* the current zoom level - ptr in the zoom record *\/$/;"	v	file:
zoomRec	HTKTools/HSLab.c	/^static ZoomRecord zoomRec[MAX_ZOOM];   \/* the zoom record *\/$/;"	v	file:
zot	HTKTools/HRest.c	/^static Vector zot;         \/* temp storage for zero mean obs vector *\/$/;"	v	file:
